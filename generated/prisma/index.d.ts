
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTags
 * 
 */
export type UserTags = $Result.DefaultSelection<Prisma.$UserTagsPayload>
/**
 * Model UserChannels
 * 
 */
export type UserChannels = $Result.DefaultSelection<Prisma.$UserChannelsPayload>
/**
 * Model UserSkills
 * 
 */
export type UserSkills = $Result.DefaultSelection<Prisma.$UserSkillsPayload>
/**
 * Model UserIndustry
 * 
 */
export type UserIndustry = $Result.DefaultSelection<Prisma.$UserIndustryPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model CompanyRevenue
 * 
 */
export type CompanyRevenue = $Result.DefaultSelection<Prisma.$CompanyRevenuePayload>
/**
 * Model FreelanceRevenue
 * 
 */
export type FreelanceRevenue = $Result.DefaultSelection<Prisma.$FreelanceRevenuePayload>
/**
 * Model RevenueStream
 * 
 */
export type RevenueStream = $Result.DefaultSelection<Prisma.$RevenueStreamPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyIndustry
 * 
 */
export type CompanyIndustry = $Result.DefaultSelection<Prisma.$CompanyIndustryPayload>
/**
 * Model Freelance
 * 
 */
export type Freelance = $Result.DefaultSelection<Prisma.$FreelancePayload>
/**
 * Model FreelanceIndustry
 * 
 */
export type FreelanceIndustry = $Result.DefaultSelection<Prisma.$FreelanceIndustryPayload>
/**
 * Model Industry
 * 
 */
export type Industry = $Result.DefaultSelection<Prisma.$IndustryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model LookingFor
 * 
 */
export type LookingFor = $Result.DefaultSelection<Prisma.$LookingForPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Source
 * 
 */
export type Source = $Result.DefaultSelection<Prisma.$SourcePayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Segment
 * 
 */
export type Segment = $Result.DefaultSelection<Prisma.$SegmentPayload>
/**
 * Model Portfolio
 * 
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model PortfolioTag
 * 
 */
export type PortfolioTag = $Result.DefaultSelection<Prisma.$PortfolioTagPayload>
/**
 * Model PortfolioLookingFor
 * 
 */
export type PortfolioLookingFor = $Result.DefaultSelection<Prisma.$PortfolioLookingForPayload>
/**
 * Model PortfolioStandards
 * 
 */
export type PortfolioStandards = $Result.DefaultSelection<Prisma.$PortfolioStandardsPayload>
/**
 * Model PortfolioImage
 * 
 */
export type PortfolioImage = $Result.DefaultSelection<Prisma.$PortfolioImagePayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model Standards
 * 
 */
export type Standards = $Result.DefaultSelection<Prisma.$StandardsPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model PortfolioComment
 * 
 */
export type PortfolioComment = $Result.DefaultSelection<Prisma.$PortfolioCommentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  company: 'company',
  freelance: 'freelance',
  guest: 'guest',
  admin: 'admin'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const PortfolioImageType: {
  cover: 'cover',
  gallery: 'gallery',
  main: 'main'
};

export type PortfolioImageType = (typeof PortfolioImageType)[keyof typeof PortfolioImageType]


export const FavoriteAction: {
  favorite: 'favorite',
  unfavorite: 'unfavorite'
};

export type FavoriteAction = (typeof FavoriteAction)[keyof typeof FavoriteAction]


export const StandardsType: {
  ERSB: 'ERSB',
  PEGI: 'PEGI',
  CERO: 'CERO',
  USK: 'USK',
  ACB: 'ACB',
  IARC: 'IARC',
  GRAC: 'GRAC',
  VSC: 'VSC',
  OFLC: 'OFLC',
  BBFC: 'BBFC',
  FPB: 'FPB',
  RARS: 'RARS',
  GSRB: 'GSRB',
  GSRR: 'GSRR',
  MPA: 'MPA',
  EIRIN: 'EIRIN',
  NBTC: 'NBTC',
  ESRB: 'ESRB'
};

export type StandardsType = (typeof StandardsType)[keyof typeof StandardsType]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type PortfolioImageType = $Enums.PortfolioImageType

export const PortfolioImageType: typeof $Enums.PortfolioImageType

export type FavoriteAction = $Enums.FavoriteAction

export const FavoriteAction: typeof $Enums.FavoriteAction

export type StandardsType = $Enums.StandardsType

export const StandardsType: typeof $Enums.StandardsType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTags`: Exposes CRUD operations for the **UserTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTags.findMany()
    * ```
    */
  get userTags(): Prisma.UserTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userChannels`: Exposes CRUD operations for the **UserChannels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserChannels
    * const userChannels = await prisma.userChannels.findMany()
    * ```
    */
  get userChannels(): Prisma.UserChannelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkills`: Exposes CRUD operations for the **UserSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkills
    * const userSkills = await prisma.userSkills.findMany()
    * ```
    */
  get userSkills(): Prisma.UserSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userIndustry`: Exposes CRUD operations for the **UserIndustry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIndustries
    * const userIndustries = await prisma.userIndustry.findMany()
    * ```
    */
  get userIndustry(): Prisma.UserIndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyRevenue`: Exposes CRUD operations for the **CompanyRevenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyRevenues
    * const companyRevenues = await prisma.companyRevenue.findMany()
    * ```
    */
  get companyRevenue(): Prisma.CompanyRevenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelanceRevenue`: Exposes CRUD operations for the **FreelanceRevenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelanceRevenues
    * const freelanceRevenues = await prisma.freelanceRevenue.findMany()
    * ```
    */
  get freelanceRevenue(): Prisma.FreelanceRevenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.revenueStream`: Exposes CRUD operations for the **RevenueStream** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueStreams
    * const revenueStreams = await prisma.revenueStream.findMany()
    * ```
    */
  get revenueStream(): Prisma.RevenueStreamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyIndustry`: Exposes CRUD operations for the **CompanyIndustry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyIndustries
    * const companyIndustries = await prisma.companyIndustry.findMany()
    * ```
    */
  get companyIndustry(): Prisma.CompanyIndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelance`: Exposes CRUD operations for the **Freelance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Freelances
    * const freelances = await prisma.freelance.findMany()
    * ```
    */
  get freelance(): Prisma.FreelanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelanceIndustry`: Exposes CRUD operations for the **FreelanceIndustry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelanceIndustries
    * const freelanceIndustries = await prisma.freelanceIndustry.findMany()
    * ```
    */
  get freelanceIndustry(): Prisma.FreelanceIndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.industry`: Exposes CRUD operations for the **Industry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Industries
    * const industries = await prisma.industry.findMany()
    * ```
    */
  get industry(): Prisma.IndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lookingFor`: Exposes CRUD operations for the **LookingFor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LookingFors
    * const lookingFors = await prisma.lookingFor.findMany()
    * ```
    */
  get lookingFor(): Prisma.LookingForDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.segment`: Exposes CRUD operations for the **Segment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Segments
    * const segments = await prisma.segment.findMany()
    * ```
    */
  get segment(): Prisma.SegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioTag`: Exposes CRUD operations for the **PortfolioTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioTags
    * const portfolioTags = await prisma.portfolioTag.findMany()
    * ```
    */
  get portfolioTag(): Prisma.PortfolioTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioLookingFor`: Exposes CRUD operations for the **PortfolioLookingFor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioLookingFors
    * const portfolioLookingFors = await prisma.portfolioLookingFor.findMany()
    * ```
    */
  get portfolioLookingFor(): Prisma.PortfolioLookingForDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioStandards`: Exposes CRUD operations for the **PortfolioStandards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioStandards
    * const portfolioStandards = await prisma.portfolioStandards.findMany()
    * ```
    */
  get portfolioStandards(): Prisma.PortfolioStandardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioImage`: Exposes CRUD operations for the **PortfolioImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioImages
    * const portfolioImages = await prisma.portfolioImage.findMany()
    * ```
    */
  get portfolioImage(): Prisma.PortfolioImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standards`: Exposes CRUD operations for the **Standards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Standards
    * const standards = await prisma.standards.findMany()
    * ```
    */
  get standards(): Prisma.StandardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioComment`: Exposes CRUD operations for the **PortfolioComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioComments
    * const portfolioComments = await prisma.portfolioComment.findMany()
    * ```
    */
  get portfolioComment(): Prisma.PortfolioCommentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserTags: 'UserTags',
    UserChannels: 'UserChannels',
    UserSkills: 'UserSkills',
    UserIndustry: 'UserIndustry',
    RefreshToken: 'RefreshToken',
    CompanyRevenue: 'CompanyRevenue',
    FreelanceRevenue: 'FreelanceRevenue',
    RevenueStream: 'RevenueStream',
    Company: 'Company',
    CompanyIndustry: 'CompanyIndustry',
    Freelance: 'Freelance',
    FreelanceIndustry: 'FreelanceIndustry',
    Industry: 'Industry',
    Tag: 'Tag',
    LookingFor: 'LookingFor',
    Category: 'Category',
    Source: 'Source',
    Channel: 'Channel',
    Segment: 'Segment',
    Portfolio: 'Portfolio',
    PortfolioTag: 'PortfolioTag',
    PortfolioLookingFor: 'PortfolioLookingFor',
    PortfolioStandards: 'PortfolioStandards',
    PortfolioImage: 'PortfolioImage',
    Favorite: 'Favorite',
    Standards: 'Standards',
    Skill: 'Skill',
    PortfolioComment: 'PortfolioComment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userTags" | "userChannels" | "userSkills" | "userIndustry" | "refreshToken" | "companyRevenue" | "freelanceRevenue" | "revenueStream" | "company" | "companyIndustry" | "freelance" | "freelanceIndustry" | "industry" | "tag" | "lookingFor" | "category" | "source" | "channel" | "segment" | "portfolio" | "portfolioTag" | "portfolioLookingFor" | "portfolioStandards" | "portfolioImage" | "favorite" | "standards" | "skill" | "portfolioComment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTags: {
        payload: Prisma.$UserTagsPayload<ExtArgs>
        fields: Prisma.UserTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findFirst: {
            args: Prisma.UserTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findMany: {
            args: Prisma.UserTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          create: {
            args: Prisma.UserTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          createMany: {
            args: Prisma.UserTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          delete: {
            args: Prisma.UserTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          update: {
            args: Prisma.UserTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          deleteMany: {
            args: Prisma.UserTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          upsert: {
            args: Prisma.UserTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          aggregate: {
            args: Prisma.UserTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTags>
          }
          groupBy: {
            args: Prisma.UserTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagsCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagsCountAggregateOutputType> | number
          }
        }
      }
      UserChannels: {
        payload: Prisma.$UserChannelsPayload<ExtArgs>
        fields: Prisma.UserChannelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserChannelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserChannelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          findFirst: {
            args: Prisma.UserChannelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserChannelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          findMany: {
            args: Prisma.UserChannelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>[]
          }
          create: {
            args: Prisma.UserChannelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          createMany: {
            args: Prisma.UserChannelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserChannelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>[]
          }
          delete: {
            args: Prisma.UserChannelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          update: {
            args: Prisma.UserChannelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          deleteMany: {
            args: Prisma.UserChannelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserChannelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserChannelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>[]
          }
          upsert: {
            args: Prisma.UserChannelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChannelsPayload>
          }
          aggregate: {
            args: Prisma.UserChannelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserChannels>
          }
          groupBy: {
            args: Prisma.UserChannelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserChannelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserChannelsCountArgs<ExtArgs>
            result: $Utils.Optional<UserChannelsCountAggregateOutputType> | number
          }
        }
      }
      UserSkills: {
        payload: Prisma.$UserSkillsPayload<ExtArgs>
        fields: Prisma.UserSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          findFirst: {
            args: Prisma.UserSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          findMany: {
            args: Prisma.UserSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>[]
          }
          create: {
            args: Prisma.UserSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          createMany: {
            args: Prisma.UserSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>[]
          }
          delete: {
            args: Prisma.UserSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          update: {
            args: Prisma.UserSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          deleteMany: {
            args: Prisma.UserSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>[]
          }
          upsert: {
            args: Prisma.UserSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillsPayload>
          }
          aggregate: {
            args: Prisma.UserSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkills>
          }
          groupBy: {
            args: Prisma.UserSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillsCountAggregateOutputType> | number
          }
        }
      }
      UserIndustry: {
        payload: Prisma.$UserIndustryPayload<ExtArgs>
        fields: Prisma.UserIndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserIndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserIndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          findFirst: {
            args: Prisma.UserIndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserIndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          findMany: {
            args: Prisma.UserIndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>[]
          }
          create: {
            args: Prisma.UserIndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          createMany: {
            args: Prisma.UserIndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserIndustryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>[]
          }
          delete: {
            args: Prisma.UserIndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          update: {
            args: Prisma.UserIndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          deleteMany: {
            args: Prisma.UserIndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserIndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserIndustryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>[]
          }
          upsert: {
            args: Prisma.UserIndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIndustryPayload>
          }
          aggregate: {
            args: Prisma.UserIndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserIndustry>
          }
          groupBy: {
            args: Prisma.UserIndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserIndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserIndustryCountArgs<ExtArgs>
            result: $Utils.Optional<UserIndustryCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      CompanyRevenue: {
        payload: Prisma.$CompanyRevenuePayload<ExtArgs>
        fields: Prisma.CompanyRevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyRevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyRevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          findFirst: {
            args: Prisma.CompanyRevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyRevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          findMany: {
            args: Prisma.CompanyRevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>[]
          }
          create: {
            args: Prisma.CompanyRevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          createMany: {
            args: Prisma.CompanyRevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyRevenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>[]
          }
          delete: {
            args: Prisma.CompanyRevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          update: {
            args: Prisma.CompanyRevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          deleteMany: {
            args: Prisma.CompanyRevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyRevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyRevenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>[]
          }
          upsert: {
            args: Prisma.CompanyRevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRevenuePayload>
          }
          aggregate: {
            args: Prisma.CompanyRevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyRevenue>
          }
          groupBy: {
            args: Prisma.CompanyRevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyRevenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyRevenueCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyRevenueCountAggregateOutputType> | number
          }
        }
      }
      FreelanceRevenue: {
        payload: Prisma.$FreelanceRevenuePayload<ExtArgs>
        fields: Prisma.FreelanceRevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelanceRevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelanceRevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          findFirst: {
            args: Prisma.FreelanceRevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelanceRevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          findMany: {
            args: Prisma.FreelanceRevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>[]
          }
          create: {
            args: Prisma.FreelanceRevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          createMany: {
            args: Prisma.FreelanceRevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelanceRevenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>[]
          }
          delete: {
            args: Prisma.FreelanceRevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          update: {
            args: Prisma.FreelanceRevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          deleteMany: {
            args: Prisma.FreelanceRevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelanceRevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelanceRevenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>[]
          }
          upsert: {
            args: Prisma.FreelanceRevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceRevenuePayload>
          }
          aggregate: {
            args: Prisma.FreelanceRevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelanceRevenue>
          }
          groupBy: {
            args: Prisma.FreelanceRevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelanceRevenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelanceRevenueCountArgs<ExtArgs>
            result: $Utils.Optional<FreelanceRevenueCountAggregateOutputType> | number
          }
        }
      }
      RevenueStream: {
        payload: Prisma.$RevenueStreamPayload<ExtArgs>
        fields: Prisma.RevenueStreamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueStreamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueStreamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          findFirst: {
            args: Prisma.RevenueStreamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueStreamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          findMany: {
            args: Prisma.RevenueStreamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>[]
          }
          create: {
            args: Prisma.RevenueStreamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          createMany: {
            args: Prisma.RevenueStreamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueStreamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>[]
          }
          delete: {
            args: Prisma.RevenueStreamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          update: {
            args: Prisma.RevenueStreamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          deleteMany: {
            args: Prisma.RevenueStreamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueStreamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RevenueStreamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>[]
          }
          upsert: {
            args: Prisma.RevenueStreamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueStreamPayload>
          }
          aggregate: {
            args: Prisma.RevenueStreamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueStream>
          }
          groupBy: {
            args: Prisma.RevenueStreamGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueStreamGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueStreamCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueStreamCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyIndustry: {
        payload: Prisma.$CompanyIndustryPayload<ExtArgs>
        fields: Prisma.CompanyIndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyIndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyIndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          findFirst: {
            args: Prisma.CompanyIndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyIndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          findMany: {
            args: Prisma.CompanyIndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>[]
          }
          create: {
            args: Prisma.CompanyIndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          createMany: {
            args: Prisma.CompanyIndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyIndustryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>[]
          }
          delete: {
            args: Prisma.CompanyIndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          update: {
            args: Prisma.CompanyIndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          deleteMany: {
            args: Prisma.CompanyIndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyIndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyIndustryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>[]
          }
          upsert: {
            args: Prisma.CompanyIndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyIndustryPayload>
          }
          aggregate: {
            args: Prisma.CompanyIndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyIndustry>
          }
          groupBy: {
            args: Prisma.CompanyIndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyIndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyIndustryCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyIndustryCountAggregateOutputType> | number
          }
        }
      }
      Freelance: {
        payload: Prisma.$FreelancePayload<ExtArgs>
        fields: Prisma.FreelanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          findFirst: {
            args: Prisma.FreelanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          findMany: {
            args: Prisma.FreelanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>[]
          }
          create: {
            args: Prisma.FreelanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          createMany: {
            args: Prisma.FreelanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>[]
          }
          delete: {
            args: Prisma.FreelanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          update: {
            args: Prisma.FreelanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          deleteMany: {
            args: Prisma.FreelanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>[]
          }
          upsert: {
            args: Prisma.FreelanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancePayload>
          }
          aggregate: {
            args: Prisma.FreelanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelance>
          }
          groupBy: {
            args: Prisma.FreelanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelanceCountArgs<ExtArgs>
            result: $Utils.Optional<FreelanceCountAggregateOutputType> | number
          }
        }
      }
      FreelanceIndustry: {
        payload: Prisma.$FreelanceIndustryPayload<ExtArgs>
        fields: Prisma.FreelanceIndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelanceIndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelanceIndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          findFirst: {
            args: Prisma.FreelanceIndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelanceIndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          findMany: {
            args: Prisma.FreelanceIndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>[]
          }
          create: {
            args: Prisma.FreelanceIndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          createMany: {
            args: Prisma.FreelanceIndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelanceIndustryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>[]
          }
          delete: {
            args: Prisma.FreelanceIndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          update: {
            args: Prisma.FreelanceIndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          deleteMany: {
            args: Prisma.FreelanceIndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelanceIndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelanceIndustryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>[]
          }
          upsert: {
            args: Prisma.FreelanceIndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceIndustryPayload>
          }
          aggregate: {
            args: Prisma.FreelanceIndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelanceIndustry>
          }
          groupBy: {
            args: Prisma.FreelanceIndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelanceIndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelanceIndustryCountArgs<ExtArgs>
            result: $Utils.Optional<FreelanceIndustryCountAggregateOutputType> | number
          }
        }
      }
      Industry: {
        payload: Prisma.$IndustryPayload<ExtArgs>
        fields: Prisma.IndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findFirst: {
            args: Prisma.IndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findMany: {
            args: Prisma.IndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          create: {
            args: Prisma.IndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          createMany: {
            args: Prisma.IndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndustryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          delete: {
            args: Prisma.IndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          update: {
            args: Prisma.IndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          deleteMany: {
            args: Prisma.IndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndustryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          upsert: {
            args: Prisma.IndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          aggregate: {
            args: Prisma.IndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndustry>
          }
          groupBy: {
            args: Prisma.IndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndustryCountArgs<ExtArgs>
            result: $Utils.Optional<IndustryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      LookingFor: {
        payload: Prisma.$LookingForPayload<ExtArgs>
        fields: Prisma.LookingForFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LookingForFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LookingForFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          findFirst: {
            args: Prisma.LookingForFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LookingForFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          findMany: {
            args: Prisma.LookingForFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>[]
          }
          create: {
            args: Prisma.LookingForCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          createMany: {
            args: Prisma.LookingForCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LookingForCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>[]
          }
          delete: {
            args: Prisma.LookingForDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          update: {
            args: Prisma.LookingForUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          deleteMany: {
            args: Prisma.LookingForDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LookingForUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LookingForUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>[]
          }
          upsert: {
            args: Prisma.LookingForUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LookingForPayload>
          }
          aggregate: {
            args: Prisma.LookingForAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLookingFor>
          }
          groupBy: {
            args: Prisma.LookingForGroupByArgs<ExtArgs>
            result: $Utils.Optional<LookingForGroupByOutputType>[]
          }
          count: {
            args: Prisma.LookingForCountArgs<ExtArgs>
            result: $Utils.Optional<LookingForCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Source: {
        payload: Prisma.$SourcePayload<ExtArgs>
        fields: Prisma.SourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findFirst: {
            args: Prisma.SourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findMany: {
            args: Prisma.SourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          create: {
            args: Prisma.SourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          createMany: {
            args: Prisma.SourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          delete: {
            args: Prisma.SourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          update: {
            args: Prisma.SourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          deleteMany: {
            args: Prisma.SourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          upsert: {
            args: Prisma.SourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSource>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Segment: {
        payload: Prisma.$SegmentPayload<ExtArgs>
        fields: Prisma.SegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findFirst: {
            args: Prisma.SegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findMany: {
            args: Prisma.SegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          create: {
            args: Prisma.SegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          createMany: {
            args: Prisma.SegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          delete: {
            args: Prisma.SegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          update: {
            args: Prisma.SegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          deleteMany: {
            args: Prisma.SegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          upsert: {
            args: Prisma.SegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          aggregate: {
            args: Prisma.SegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegment>
          }
          groupBy: {
            args: Prisma.SegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      PortfolioTag: {
        payload: Prisma.$PortfolioTagPayload<ExtArgs>
        fields: Prisma.PortfolioTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          findFirst: {
            args: Prisma.PortfolioTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          findMany: {
            args: Prisma.PortfolioTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>[]
          }
          create: {
            args: Prisma.PortfolioTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          createMany: {
            args: Prisma.PortfolioTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>[]
          }
          delete: {
            args: Prisma.PortfolioTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          update: {
            args: Prisma.PortfolioTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioTagPayload>
          }
          aggregate: {
            args: Prisma.PortfolioTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioTag>
          }
          groupBy: {
            args: Prisma.PortfolioTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioTagCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioTagCountAggregateOutputType> | number
          }
        }
      }
      PortfolioLookingFor: {
        payload: Prisma.$PortfolioLookingForPayload<ExtArgs>
        fields: Prisma.PortfolioLookingForFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioLookingForFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioLookingForFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          findFirst: {
            args: Prisma.PortfolioLookingForFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioLookingForFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          findMany: {
            args: Prisma.PortfolioLookingForFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>[]
          }
          create: {
            args: Prisma.PortfolioLookingForCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          createMany: {
            args: Prisma.PortfolioLookingForCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioLookingForCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>[]
          }
          delete: {
            args: Prisma.PortfolioLookingForDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          update: {
            args: Prisma.PortfolioLookingForUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioLookingForDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioLookingForUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioLookingForUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioLookingForUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioLookingForPayload>
          }
          aggregate: {
            args: Prisma.PortfolioLookingForAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioLookingFor>
          }
          groupBy: {
            args: Prisma.PortfolioLookingForGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioLookingForGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioLookingForCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioLookingForCountAggregateOutputType> | number
          }
        }
      }
      PortfolioStandards: {
        payload: Prisma.$PortfolioStandardsPayload<ExtArgs>
        fields: Prisma.PortfolioStandardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioStandardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioStandardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          findFirst: {
            args: Prisma.PortfolioStandardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioStandardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          findMany: {
            args: Prisma.PortfolioStandardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>[]
          }
          create: {
            args: Prisma.PortfolioStandardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          createMany: {
            args: Prisma.PortfolioStandardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioStandardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>[]
          }
          delete: {
            args: Prisma.PortfolioStandardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          update: {
            args: Prisma.PortfolioStandardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioStandardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioStandardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioStandardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioStandardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioStandardsPayload>
          }
          aggregate: {
            args: Prisma.PortfolioStandardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioStandards>
          }
          groupBy: {
            args: Prisma.PortfolioStandardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioStandardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioStandardsCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioStandardsCountAggregateOutputType> | number
          }
        }
      }
      PortfolioImage: {
        payload: Prisma.$PortfolioImagePayload<ExtArgs>
        fields: Prisma.PortfolioImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          findFirst: {
            args: Prisma.PortfolioImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          findMany: {
            args: Prisma.PortfolioImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>[]
          }
          create: {
            args: Prisma.PortfolioImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          createMany: {
            args: Prisma.PortfolioImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>[]
          }
          delete: {
            args: Prisma.PortfolioImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          update: {
            args: Prisma.PortfolioImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          deleteMany: {
            args: Prisma.PortfolioImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>[]
          }
          upsert: {
            args: Prisma.PortfolioImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioImagePayload>
          }
          aggregate: {
            args: Prisma.PortfolioImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioImage>
          }
          groupBy: {
            args: Prisma.PortfolioImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioImageCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioImageCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      Standards: {
        payload: Prisma.$StandardsPayload<ExtArgs>
        fields: Prisma.StandardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          findFirst: {
            args: Prisma.StandardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          findMany: {
            args: Prisma.StandardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>[]
          }
          create: {
            args: Prisma.StandardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          createMany: {
            args: Prisma.StandardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>[]
          }
          delete: {
            args: Prisma.StandardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          update: {
            args: Prisma.StandardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          deleteMany: {
            args: Prisma.StandardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>[]
          }
          upsert: {
            args: Prisma.StandardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardsPayload>
          }
          aggregate: {
            args: Prisma.StandardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandards>
          }
          groupBy: {
            args: Prisma.StandardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardsCountArgs<ExtArgs>
            result: $Utils.Optional<StandardsCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      PortfolioComment: {
        payload: Prisma.$PortfolioCommentPayload<ExtArgs>
        fields: Prisma.PortfolioCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          findFirst: {
            args: Prisma.PortfolioCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          findMany: {
            args: Prisma.PortfolioCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>[]
          }
          create: {
            args: Prisma.PortfolioCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          createMany: {
            args: Prisma.PortfolioCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>[]
          }
          delete: {
            args: Prisma.PortfolioCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          update: {
            args: Prisma.PortfolioCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioCommentPayload>
          }
          aggregate: {
            args: Prisma.PortfolioCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioComment>
          }
          groupBy: {
            args: Prisma.PortfolioCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCommentCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userTags?: UserTagsOmit
    userChannels?: UserChannelsOmit
    userSkills?: UserSkillsOmit
    userIndustry?: UserIndustryOmit
    refreshToken?: RefreshTokenOmit
    companyRevenue?: CompanyRevenueOmit
    freelanceRevenue?: FreelanceRevenueOmit
    revenueStream?: RevenueStreamOmit
    company?: CompanyOmit
    companyIndustry?: CompanyIndustryOmit
    freelance?: FreelanceOmit
    freelanceIndustry?: FreelanceIndustryOmit
    industry?: IndustryOmit
    tag?: TagOmit
    lookingFor?: LookingForOmit
    category?: CategoryOmit
    source?: SourceOmit
    channel?: ChannelOmit
    segment?: SegmentOmit
    portfolio?: PortfolioOmit
    portfolioTag?: PortfolioTagOmit
    portfolioLookingFor?: PortfolioLookingForOmit
    portfolioStandards?: PortfolioStandardsOmit
    portfolioImage?: PortfolioImageOmit
    favorite?: FavoriteOmit
    standards?: StandardsOmit
    skill?: SkillOmit
    portfolioComment?: PortfolioCommentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    industriesRelated: number
    industryTags: number
    industryChannels: number
    industrySkills: number
    Favorite: number
    comments: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industriesRelated?: boolean | UserCountOutputTypeCountIndustriesRelatedArgs
    industryTags?: boolean | UserCountOutputTypeCountIndustryTagsArgs
    industryChannels?: boolean | UserCountOutputTypeCountIndustryChannelsArgs
    industrySkills?: boolean | UserCountOutputTypeCountIndustrySkillsArgs
    Favorite?: boolean | UserCountOutputTypeCountFavoriteArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIndustriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIndustryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIndustryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIndustryChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChannelsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIndustrySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    industriesRelated: number
    companyRevenue: number
    RevenueStream: number
    Portfolio: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industriesRelated?: boolean | CompanyCountOutputTypeCountIndustriesRelatedArgs
    companyRevenue?: boolean | CompanyCountOutputTypeCountCompanyRevenueArgs
    RevenueStream?: boolean | CompanyCountOutputTypeCountRevenueStreamArgs
    Portfolio?: boolean | CompanyCountOutputTypeCountPortfolioArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountIndustriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyIndustryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRevenueWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }


  /**
   * Count Type FreelanceCountOutputType
   */

  export type FreelanceCountOutputType = {
    industriesRelated: number
    skills: number
    freelanceRevenue: number
    Portfolio: number
  }

  export type FreelanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industriesRelated?: boolean | FreelanceCountOutputTypeCountIndustriesRelatedArgs
    skills?: boolean | FreelanceCountOutputTypeCountSkillsArgs
    freelanceRevenue?: boolean | FreelanceCountOutputTypeCountFreelanceRevenueArgs
    Portfolio?: boolean | FreelanceCountOutputTypeCountPortfolioArgs
  }

  // Custom InputTypes
  /**
   * FreelanceCountOutputType without action
   */
  export type FreelanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceCountOutputType
     */
    select?: FreelanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FreelanceCountOutputType without action
   */
  export type FreelanceCountOutputTypeCountIndustriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceIndustryWhereInput
  }

  /**
   * FreelanceCountOutputType without action
   */
  export type FreelanceCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * FreelanceCountOutputType without action
   */
  export type FreelanceCountOutputTypeCountFreelanceRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceRevenueWhereInput
  }

  /**
   * FreelanceCountOutputType without action
   */
  export type FreelanceCountOutputTypeCountPortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }


  /**
   * Count Type IndustryCountOutputType
   */

  export type IndustryCountOutputType = {
    Skill: number
    Source: number
    Channel: number
    Segment: number
    Category: number
    companies: number
    freelancers: number
    users: number
    Standards: number
    RevenueStream: number
    Tag: number
    LookingFor: number
  }

  export type IndustryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Skill?: boolean | IndustryCountOutputTypeCountSkillArgs
    Source?: boolean | IndustryCountOutputTypeCountSourceArgs
    Channel?: boolean | IndustryCountOutputTypeCountChannelArgs
    Segment?: boolean | IndustryCountOutputTypeCountSegmentArgs
    Category?: boolean | IndustryCountOutputTypeCountCategoryArgs
    companies?: boolean | IndustryCountOutputTypeCountCompaniesArgs
    freelancers?: boolean | IndustryCountOutputTypeCountFreelancersArgs
    users?: boolean | IndustryCountOutputTypeCountUsersArgs
    Standards?: boolean | IndustryCountOutputTypeCountStandardsArgs
    RevenueStream?: boolean | IndustryCountOutputTypeCountRevenueStreamArgs
    Tag?: boolean | IndustryCountOutputTypeCountTagArgs
    LookingFor?: boolean | IndustryCountOutputTypeCountLookingForArgs
  }

  // Custom InputTypes
  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryCountOutputType
     */
    select?: IndustryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyIndustryWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountFreelancersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceIndustryWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIndustryWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardsWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountLookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LookingForWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    PortfolioTag: number
    UserTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PortfolioTag?: boolean | TagCountOutputTypeCountPortfolioTagArgs
    UserTags?: boolean | TagCountOutputTypeCountUserTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPortfolioTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountUserTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
  }


  /**
   * Count Type LookingForCountOutputType
   */

  export type LookingForCountOutputType = {
    PortfolioLookingFor: number
  }

  export type LookingForCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PortfolioLookingFor?: boolean | LookingForCountOutputTypeCountPortfolioLookingForArgs
  }

  // Custom InputTypes
  /**
   * LookingForCountOutputType without action
   */
  export type LookingForCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingForCountOutputType
     */
    select?: LookingForCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LookingForCountOutputType without action
   */
  export type LookingForCountOutputTypeCountPortfolioLookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioLookingForWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    RevenueStream: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RevenueStream?: boolean | CategoryCountOutputTypeCountRevenueStreamArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }


  /**
   * Count Type SourceCountOutputType
   */

  export type SourceCountOutputType = {
    RevenueStream: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RevenueStream?: boolean | SourceCountOutputTypeCountRevenueStreamArgs
  }

  // Custom InputTypes
  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    RevenueStream: number
    UserChannels: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RevenueStream?: boolean | ChannelCountOutputTypeCountRevenueStreamArgs
    UserChannels?: boolean | ChannelCountOutputTypeCountUserChannelsArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountUserChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChannelsWhereInput
  }


  /**
   * Count Type SegmentCountOutputType
   */

  export type SegmentCountOutputType = {
    RevenueStream: number
  }

  export type SegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RevenueStream?: boolean | SegmentCountOutputTypeCountRevenueStreamArgs
  }

  // Custom InputTypes
  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentCountOutputType
     */
    select?: SegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeCountRevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
  }


  /**
   * Count Type PortfolioCountOutputType
   */

  export type PortfolioCountOutputType = {
    industryTags: number
    industryLookingFor: number
    Favorite: number
    Image: number
    standards: number
    comments: number
  }

  export type PortfolioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industryTags?: boolean | PortfolioCountOutputTypeCountIndustryTagsArgs
    industryLookingFor?: boolean | PortfolioCountOutputTypeCountIndustryLookingForArgs
    Favorite?: boolean | PortfolioCountOutputTypeCountFavoriteArgs
    Image?: boolean | PortfolioCountOutputTypeCountImageArgs
    standards?: boolean | PortfolioCountOutputTypeCountStandardsArgs
    comments?: boolean | PortfolioCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioCountOutputType
     */
    select?: PortfolioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountIndustryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioTagWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountIndustryLookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioLookingForWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioImageWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioStandardsWhereInput
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioCommentWhereInput
  }


  /**
   * Count Type StandardsCountOutputType
   */

  export type StandardsCountOutputType = {
    PortfolioStandards: number
  }

  export type StandardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PortfolioStandards?: boolean | StandardsCountOutputTypeCountPortfolioStandardsArgs
  }

  // Custom InputTypes
  /**
   * StandardsCountOutputType without action
   */
  export type StandardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardsCountOutputType
     */
    select?: StandardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardsCountOutputType without action
   */
  export type StandardsCountOutputTypeCountPortfolioStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioStandardsWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    UserSkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserSkills?: boolean | SkillCountOutputTypeCountUserSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
  }


  /**
   * Count Type PortfolioCommentCountOutputType
   */

  export type PortfolioCommentCountOutputType = {
    replies: number
  }

  export type PortfolioCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | PortfolioCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * PortfolioCommentCountOutputType without action
   */
  export type PortfolioCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioCommentCountOutputType
     */
    select?: PortfolioCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortfolioCommentCountOutputType without action
   */
  export type PortfolioCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    fullnameTh: string | null
    fullnameEn: string | null
    about: string | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    address: string | null
    image: string | null
    userType: $Enums.UserType | null
    role: $Enums.UserType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    fullnameTh: string | null
    fullnameEn: string | null
    about: string | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    address: string | null
    image: string | null
    userType: $Enums.UserType | null
    role: $Enums.UserType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullnameTh: number
    fullnameEn: number
    about: number
    phoneNumber: number
    email: number
    website: number
    address: number
    image: number
    industries: number
    tags: number
    channels: number
    specialists: number
    userType: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    fullnameTh?: true
    fullnameEn?: true
    about?: true
    phoneNumber?: true
    email?: true
    website?: true
    address?: true
    image?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullnameTh?: true
    fullnameEn?: true
    about?: true
    phoneNumber?: true
    email?: true
    website?: true
    address?: true
    image?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullnameTh?: true
    fullnameEn?: true
    about?: true
    phoneNumber?: true
    email?: true
    website?: true
    address?: true
    image?: true
    industries?: true
    tags?: true
    channels?: true
    specialists?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    fullnameTh: string | null
    fullnameEn: string | null
    about: string | null
    phoneNumber: string | null
    email: string
    website: string | null
    address: string | null
    image: string | null
    industries: string[]
    tags: JsonValue[]
    channels: JsonValue[]
    specialists: JsonValue[]
    userType: $Enums.UserType | null
    role: $Enums.UserType | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullnameTh?: boolean
    fullnameEn?: boolean
    about?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    image?: boolean
    industries?: boolean
    tags?: boolean
    channels?: boolean
    specialists?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industriesRelated?: boolean | User$industriesRelatedArgs<ExtArgs>
    industryTags?: boolean | User$industryTagsArgs<ExtArgs>
    industryChannels?: boolean | User$industryChannelsArgs<ExtArgs>
    industrySkills?: boolean | User$industrySkillsArgs<ExtArgs>
    freelance?: boolean | User$freelanceArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    Favorite?: boolean | User$FavoriteArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullnameTh?: boolean
    fullnameEn?: boolean
    about?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    image?: boolean
    industries?: boolean
    tags?: boolean
    channels?: boolean
    specialists?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullnameTh?: boolean
    fullnameEn?: boolean
    about?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    image?: boolean
    industries?: boolean
    tags?: boolean
    channels?: boolean
    specialists?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullnameTh?: boolean
    fullnameEn?: boolean
    about?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    image?: boolean
    industries?: boolean
    tags?: boolean
    channels?: boolean
    specialists?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullnameTh" | "fullnameEn" | "about" | "phoneNumber" | "email" | "website" | "address" | "image" | "industries" | "tags" | "channels" | "specialists" | "userType" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industriesRelated?: boolean | User$industriesRelatedArgs<ExtArgs>
    industryTags?: boolean | User$industryTagsArgs<ExtArgs>
    industryChannels?: boolean | User$industryChannelsArgs<ExtArgs>
    industrySkills?: boolean | User$industrySkillsArgs<ExtArgs>
    freelance?: boolean | User$freelanceArgs<ExtArgs>
    company?: boolean | User$companyArgs<ExtArgs>
    Favorite?: boolean | User$FavoriteArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      industriesRelated: Prisma.$UserIndustryPayload<ExtArgs>[]
      industryTags: Prisma.$UserTagsPayload<ExtArgs>[]
      industryChannels: Prisma.$UserChannelsPayload<ExtArgs>[]
      industrySkills: Prisma.$UserSkillsPayload<ExtArgs>[]
      freelance: Prisma.$FreelancePayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      Favorite: Prisma.$FavoritePayload<ExtArgs>[]
      comments: Prisma.$PortfolioCommentPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullnameTh: string | null
      fullnameEn: string | null
      about: string | null
      phoneNumber: string | null
      email: string
      website: string | null
      address: string | null
      image: string | null
      industries: string[]
      tags: Prisma.JsonValue[]
      channels: Prisma.JsonValue[]
      specialists: Prisma.JsonValue[]
      userType: $Enums.UserType | null
      role: $Enums.UserType | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industriesRelated<T extends User$industriesRelatedArgs<ExtArgs> = {}>(args?: Subset<T, User$industriesRelatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    industryTags<T extends User$industryTagsArgs<ExtArgs> = {}>(args?: Subset<T, User$industryTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    industryChannels<T extends User$industryChannelsArgs<ExtArgs> = {}>(args?: Subset<T, User$industryChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    industrySkills<T extends User$industrySkillsArgs<ExtArgs> = {}>(args?: Subset<T, User$industrySkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelance<T extends User$freelanceArgs<ExtArgs> = {}>(args?: Subset<T, User$freelanceArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Favorite<T extends User$FavoriteArgs<ExtArgs> = {}>(args?: Subset<T, User$FavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly fullnameTh: FieldRef<"User", 'String'>
    readonly fullnameEn: FieldRef<"User", 'String'>
    readonly about: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly industries: FieldRef<"User", 'String[]'>
    readonly tags: FieldRef<"User", 'Json[]'>
    readonly channels: FieldRef<"User", 'Json[]'>
    readonly specialists: FieldRef<"User", 'Json[]'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly role: FieldRef<"User", 'UserType'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.industriesRelated
   */
  export type User$industriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    where?: UserIndustryWhereInput
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    cursor?: UserIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserIndustryScalarFieldEnum | UserIndustryScalarFieldEnum[]
  }

  /**
   * User.industryTags
   */
  export type User$industryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    cursor?: UserTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * User.industryChannels
   */
  export type User$industryChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    where?: UserChannelsWhereInput
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    cursor?: UserChannelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChannelsScalarFieldEnum | UserChannelsScalarFieldEnum[]
  }

  /**
   * User.industrySkills
   */
  export type User$industrySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    cursor?: UserSkillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * User.freelance
   */
  export type User$freelanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    where?: FreelanceWhereInput
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.Favorite
   */
  export type User$FavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    where?: PortfolioCommentWhereInput
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    cursor?: PortfolioCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTags
   */

  export type AggregateUserTags = {
    _count: UserTagsCountAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  export type UserTagsMinAggregateOutputType = {
    userId: string | null
    tagSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagsMaxAggregateOutputType = {
    userId: string | null
    tagSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagsCountAggregateOutputType = {
    userId: number
    tagSlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTagsMinAggregateInputType = {
    userId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagsMaxAggregateInputType = {
    userId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagsCountAggregateInputType = {
    userId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to aggregate.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagsMaxAggregateInputType
  }

  export type GetUserTagsAggregateType<T extends UserTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTags[P]>
      : GetScalarType<T[P], AggregateUserTags[P]>
  }




  export type UserTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithAggregationInput | UserTagsOrderByWithAggregationInput[]
    by: UserTagsScalarFieldEnum[] | UserTagsScalarFieldEnum
    having?: UserTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagsCountAggregateInputType | true
    _min?: UserTagsMinAggregateInputType
    _max?: UserTagsMaxAggregateInputType
  }

  export type UserTagsGroupByOutputType = {
    userId: string
    tagSlug: string
    createdAt: Date
    updatedAt: Date
    _count: UserTagsCountAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  type GetUserTagsGroupByPayload<T extends UserTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
        }
      >
    >


  export type UserTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectScalar = {
    userId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "tagSlug" | "createdAt" | "updatedAt", ExtArgs["result"]["userTags"]>
  export type UserTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $UserTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTags"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      tagSlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTags"]>
    composites: {}
  }

  type UserTagsGetPayload<S extends boolean | null | undefined | UserTagsDefaultArgs> = $Result.GetResult<Prisma.$UserTagsPayload, S>

  type UserTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTagsCountAggregateInputType | true
    }

  export interface UserTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTags'], meta: { name: 'UserTags' } }
    /**
     * Find zero or one UserTags that matches the filter.
     * @param {UserTagsFindUniqueArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagsFindUniqueArgs>(args: SelectSubset<T, UserTagsFindUniqueArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTagsFindUniqueOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagsFindFirstArgs>(args?: SelectSubset<T, UserTagsFindFirstArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTags.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTags.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTagsWithUserIdOnly = await prisma.userTags.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserTagsFindManyArgs>(args?: SelectSubset<T, UserTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTags.
     * @param {UserTagsCreateArgs} args - Arguments to create a UserTags.
     * @example
     * // Create one UserTags
     * const UserTags = await prisma.userTags.create({
     *   data: {
     *     // ... data to create a UserTags
     *   }
     * })
     * 
     */
    create<T extends UserTagsCreateArgs>(args: SelectSubset<T, UserTagsCreateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTags.
     * @param {UserTagsCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagsCreateManyArgs>(args?: SelectSubset<T, UserTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagsCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `userId`
     * const userTagsWithUserIdOnly = await prisma.userTags.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTags.
     * @param {UserTagsDeleteArgs} args - Arguments to delete one UserTags.
     * @example
     * // Delete one UserTags
     * const UserTags = await prisma.userTags.delete({
     *   where: {
     *     // ... filter to delete one UserTags
     *   }
     * })
     * 
     */
    delete<T extends UserTagsDeleteArgs>(args: SelectSubset<T, UserTagsDeleteArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTags.
     * @param {UserTagsUpdateArgs} args - Arguments to update one UserTags.
     * @example
     * // Update one UserTags
     * const userTags = await prisma.userTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagsUpdateArgs>(args: SelectSubset<T, UserTagsUpdateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagsDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagsDeleteManyArgs>(args?: SelectSubset<T, UserTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagsUpdateManyArgs>(args: SelectSubset<T, UserTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags and returns the data updated in the database.
     * @param {UserTagsUpdateManyAndReturnArgs} args - Arguments to update many UserTags.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTags and only return the `userId`
     * const userTagsWithUserIdOnly = await prisma.userTags.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTags.
     * @param {UserTagsUpsertArgs} args - Arguments to update or create a UserTags.
     * @example
     * // Update or create a UserTags
     * const userTags = await prisma.userTags.upsert({
     *   create: {
     *     // ... data to create a UserTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTags we want to update
     *   }
     * })
     */
    upsert<T extends UserTagsUpsertArgs>(args: SelectSubset<T, UserTagsUpsertArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTags.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagsCountArgs>(
      args?: Subset<T, UserTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagsAggregateArgs>(args: Subset<T, UserTagsAggregateArgs>): Prisma.PrismaPromise<GetUserTagsAggregateType<T>>

    /**
     * Group by UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagsGroupByArgs['orderBy'] }
        : { orderBy?: UserTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTags model
   */
  readonly fields: UserTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTags model
   */
  interface UserTagsFieldRefs {
    readonly userId: FieldRef<"UserTags", 'String'>
    readonly tagSlug: FieldRef<"UserTags", 'String'>
    readonly createdAt: FieldRef<"UserTags", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTags findUnique
   */
  export type UserTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findUniqueOrThrow
   */
  export type UserTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findFirst
   */
  export type UserTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findFirstOrThrow
   */
  export type UserTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findMany
   */
  export type UserTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags create
   */
  export type UserTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTags.
     */
    data: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
  }

  /**
   * UserTags createMany
   */
  export type UserTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTags createManyAndReturn
   */
  export type UserTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags update
   */
  export type UserTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTags.
     */
    data: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
    /**
     * Choose, which UserTags to update.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags updateMany
   */
  export type UserTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTags updateManyAndReturn
   */
  export type UserTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags upsert
   */
  export type UserTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTags to update in case it exists.
     */
    where: UserTagsWhereUniqueInput
    /**
     * In case the UserTags found by the `where` argument doesn't exist, create a new UserTags with this data.
     */
    create: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
    /**
     * In case the UserTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
  }

  /**
   * UserTags delete
   */
  export type UserTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter which UserTags to delete.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags deleteMany
   */
  export type UserTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to delete.
     */
    limit?: number
  }

  /**
   * UserTags without action
   */
  export type UserTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
  }


  /**
   * Model UserChannels
   */

  export type AggregateUserChannels = {
    _count: UserChannelsCountAggregateOutputType | null
    _min: UserChannelsMinAggregateOutputType | null
    _max: UserChannelsMaxAggregateOutputType | null
  }

  export type UserChannelsMinAggregateOutputType = {
    userId: string | null
    channelSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserChannelsMaxAggregateOutputType = {
    userId: string | null
    channelSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserChannelsCountAggregateOutputType = {
    userId: number
    channelSlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserChannelsMinAggregateInputType = {
    userId?: true
    channelSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserChannelsMaxAggregateInputType = {
    userId?: true
    channelSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserChannelsCountAggregateInputType = {
    userId?: true
    channelSlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserChannelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChannels to aggregate.
     */
    where?: UserChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChannels to fetch.
     */
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserChannels
    **/
    _count?: true | UserChannelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserChannelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserChannelsMaxAggregateInputType
  }

  export type GetUserChannelsAggregateType<T extends UserChannelsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserChannels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserChannels[P]>
      : GetScalarType<T[P], AggregateUserChannels[P]>
  }




  export type UserChannelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChannelsWhereInput
    orderBy?: UserChannelsOrderByWithAggregationInput | UserChannelsOrderByWithAggregationInput[]
    by: UserChannelsScalarFieldEnum[] | UserChannelsScalarFieldEnum
    having?: UserChannelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserChannelsCountAggregateInputType | true
    _min?: UserChannelsMinAggregateInputType
    _max?: UserChannelsMaxAggregateInputType
  }

  export type UserChannelsGroupByOutputType = {
    userId: string
    channelSlug: string
    createdAt: Date
    updatedAt: Date
    _count: UserChannelsCountAggregateOutputType | null
    _min: UserChannelsMinAggregateOutputType | null
    _max: UserChannelsMaxAggregateOutputType | null
  }

  type GetUserChannelsGroupByPayload<T extends UserChannelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserChannelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserChannelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserChannelsGroupByOutputType[P]>
            : GetScalarType<T[P], UserChannelsGroupByOutputType[P]>
        }
      >
    >


  export type UserChannelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    channelSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChannels"]>

  export type UserChannelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    channelSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChannels"]>

  export type UserChannelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    channelSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChannels"]>

  export type UserChannelsSelectScalar = {
    userId?: boolean
    channelSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserChannelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "channelSlug" | "createdAt" | "updatedAt", ExtArgs["result"]["userChannels"]>
  export type UserChannelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type UserChannelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type UserChannelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $UserChannelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserChannels"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      channelSlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userChannels"]>
    composites: {}
  }

  type UserChannelsGetPayload<S extends boolean | null | undefined | UserChannelsDefaultArgs> = $Result.GetResult<Prisma.$UserChannelsPayload, S>

  type UserChannelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserChannelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserChannelsCountAggregateInputType | true
    }

  export interface UserChannelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserChannels'], meta: { name: 'UserChannels' } }
    /**
     * Find zero or one UserChannels that matches the filter.
     * @param {UserChannelsFindUniqueArgs} args - Arguments to find a UserChannels
     * @example
     * // Get one UserChannels
     * const userChannels = await prisma.userChannels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserChannelsFindUniqueArgs>(args: SelectSubset<T, UserChannelsFindUniqueArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserChannels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserChannelsFindUniqueOrThrowArgs} args - Arguments to find a UserChannels
     * @example
     * // Get one UserChannels
     * const userChannels = await prisma.userChannels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserChannelsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserChannelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsFindFirstArgs} args - Arguments to find a UserChannels
     * @example
     * // Get one UserChannels
     * const userChannels = await prisma.userChannels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserChannelsFindFirstArgs>(args?: SelectSubset<T, UserChannelsFindFirstArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserChannels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsFindFirstOrThrowArgs} args - Arguments to find a UserChannels
     * @example
     * // Get one UserChannels
     * const userChannels = await prisma.userChannels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserChannelsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserChannelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserChannels
     * const userChannels = await prisma.userChannels.findMany()
     * 
     * // Get first 10 UserChannels
     * const userChannels = await prisma.userChannels.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userChannelsWithUserIdOnly = await prisma.userChannels.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserChannelsFindManyArgs>(args?: SelectSubset<T, UserChannelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserChannels.
     * @param {UserChannelsCreateArgs} args - Arguments to create a UserChannels.
     * @example
     * // Create one UserChannels
     * const UserChannels = await prisma.userChannels.create({
     *   data: {
     *     // ... data to create a UserChannels
     *   }
     * })
     * 
     */
    create<T extends UserChannelsCreateArgs>(args: SelectSubset<T, UserChannelsCreateArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserChannels.
     * @param {UserChannelsCreateManyArgs} args - Arguments to create many UserChannels.
     * @example
     * // Create many UserChannels
     * const userChannels = await prisma.userChannels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserChannelsCreateManyArgs>(args?: SelectSubset<T, UserChannelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserChannels and returns the data saved in the database.
     * @param {UserChannelsCreateManyAndReturnArgs} args - Arguments to create many UserChannels.
     * @example
     * // Create many UserChannels
     * const userChannels = await prisma.userChannels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserChannels and only return the `userId`
     * const userChannelsWithUserIdOnly = await prisma.userChannels.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserChannelsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserChannelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserChannels.
     * @param {UserChannelsDeleteArgs} args - Arguments to delete one UserChannels.
     * @example
     * // Delete one UserChannels
     * const UserChannels = await prisma.userChannels.delete({
     *   where: {
     *     // ... filter to delete one UserChannels
     *   }
     * })
     * 
     */
    delete<T extends UserChannelsDeleteArgs>(args: SelectSubset<T, UserChannelsDeleteArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserChannels.
     * @param {UserChannelsUpdateArgs} args - Arguments to update one UserChannels.
     * @example
     * // Update one UserChannels
     * const userChannels = await prisma.userChannels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserChannelsUpdateArgs>(args: SelectSubset<T, UserChannelsUpdateArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserChannels.
     * @param {UserChannelsDeleteManyArgs} args - Arguments to filter UserChannels to delete.
     * @example
     * // Delete a few UserChannels
     * const { count } = await prisma.userChannels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserChannelsDeleteManyArgs>(args?: SelectSubset<T, UserChannelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserChannels
     * const userChannels = await prisma.userChannels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserChannelsUpdateManyArgs>(args: SelectSubset<T, UserChannelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChannels and returns the data updated in the database.
     * @param {UserChannelsUpdateManyAndReturnArgs} args - Arguments to update many UserChannels.
     * @example
     * // Update many UserChannels
     * const userChannels = await prisma.userChannels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserChannels and only return the `userId`
     * const userChannelsWithUserIdOnly = await prisma.userChannels.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserChannelsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserChannelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserChannels.
     * @param {UserChannelsUpsertArgs} args - Arguments to update or create a UserChannels.
     * @example
     * // Update or create a UserChannels
     * const userChannels = await prisma.userChannels.upsert({
     *   create: {
     *     // ... data to create a UserChannels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserChannels we want to update
     *   }
     * })
     */
    upsert<T extends UserChannelsUpsertArgs>(args: SelectSubset<T, UserChannelsUpsertArgs<ExtArgs>>): Prisma__UserChannelsClient<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsCountArgs} args - Arguments to filter UserChannels to count.
     * @example
     * // Count the number of UserChannels
     * const count = await prisma.userChannels.count({
     *   where: {
     *     // ... the filter for the UserChannels we want to count
     *   }
     * })
    **/
    count<T extends UserChannelsCountArgs>(
      args?: Subset<T, UserChannelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserChannelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserChannelsAggregateArgs>(args: Subset<T, UserChannelsAggregateArgs>): Prisma.PrismaPromise<GetUserChannelsAggregateType<T>>

    /**
     * Group by UserChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChannelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserChannelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserChannelsGroupByArgs['orderBy'] }
        : { orderBy?: UserChannelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserChannelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserChannelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserChannels model
   */
  readonly fields: UserChannelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserChannels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserChannelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserChannels model
   */
  interface UserChannelsFieldRefs {
    readonly userId: FieldRef<"UserChannels", 'String'>
    readonly channelSlug: FieldRef<"UserChannels", 'String'>
    readonly createdAt: FieldRef<"UserChannels", 'DateTime'>
    readonly updatedAt: FieldRef<"UserChannels", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserChannels findUnique
   */
  export type UserChannelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter, which UserChannels to fetch.
     */
    where: UserChannelsWhereUniqueInput
  }

  /**
   * UserChannels findUniqueOrThrow
   */
  export type UserChannelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter, which UserChannels to fetch.
     */
    where: UserChannelsWhereUniqueInput
  }

  /**
   * UserChannels findFirst
   */
  export type UserChannelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter, which UserChannels to fetch.
     */
    where?: UserChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChannels to fetch.
     */
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChannels.
     */
    cursor?: UserChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChannels.
     */
    distinct?: UserChannelsScalarFieldEnum | UserChannelsScalarFieldEnum[]
  }

  /**
   * UserChannels findFirstOrThrow
   */
  export type UserChannelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter, which UserChannels to fetch.
     */
    where?: UserChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChannels to fetch.
     */
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChannels.
     */
    cursor?: UserChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChannels.
     */
    distinct?: UserChannelsScalarFieldEnum | UserChannelsScalarFieldEnum[]
  }

  /**
   * UserChannels findMany
   */
  export type UserChannelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter, which UserChannels to fetch.
     */
    where?: UserChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChannels to fetch.
     */
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserChannels.
     */
    cursor?: UserChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChannels.
     */
    skip?: number
    distinct?: UserChannelsScalarFieldEnum | UserChannelsScalarFieldEnum[]
  }

  /**
   * UserChannels create
   */
  export type UserChannelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserChannels.
     */
    data: XOR<UserChannelsCreateInput, UserChannelsUncheckedCreateInput>
  }

  /**
   * UserChannels createMany
   */
  export type UserChannelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserChannels.
     */
    data: UserChannelsCreateManyInput | UserChannelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserChannels createManyAndReturn
   */
  export type UserChannelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * The data used to create many UserChannels.
     */
    data: UserChannelsCreateManyInput | UserChannelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChannels update
   */
  export type UserChannelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserChannels.
     */
    data: XOR<UserChannelsUpdateInput, UserChannelsUncheckedUpdateInput>
    /**
     * Choose, which UserChannels to update.
     */
    where: UserChannelsWhereUniqueInput
  }

  /**
   * UserChannels updateMany
   */
  export type UserChannelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserChannels.
     */
    data: XOR<UserChannelsUpdateManyMutationInput, UserChannelsUncheckedUpdateManyInput>
    /**
     * Filter which UserChannels to update
     */
    where?: UserChannelsWhereInput
    /**
     * Limit how many UserChannels to update.
     */
    limit?: number
  }

  /**
   * UserChannels updateManyAndReturn
   */
  export type UserChannelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * The data used to update UserChannels.
     */
    data: XOR<UserChannelsUpdateManyMutationInput, UserChannelsUncheckedUpdateManyInput>
    /**
     * Filter which UserChannels to update
     */
    where?: UserChannelsWhereInput
    /**
     * Limit how many UserChannels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChannels upsert
   */
  export type UserChannelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserChannels to update in case it exists.
     */
    where: UserChannelsWhereUniqueInput
    /**
     * In case the UserChannels found by the `where` argument doesn't exist, create a new UserChannels with this data.
     */
    create: XOR<UserChannelsCreateInput, UserChannelsUncheckedCreateInput>
    /**
     * In case the UserChannels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserChannelsUpdateInput, UserChannelsUncheckedUpdateInput>
  }

  /**
   * UserChannels delete
   */
  export type UserChannelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    /**
     * Filter which UserChannels to delete.
     */
    where: UserChannelsWhereUniqueInput
  }

  /**
   * UserChannels deleteMany
   */
  export type UserChannelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChannels to delete
     */
    where?: UserChannelsWhereInput
    /**
     * Limit how many UserChannels to delete.
     */
    limit?: number
  }

  /**
   * UserChannels without action
   */
  export type UserChannelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
  }


  /**
   * Model UserSkills
   */

  export type AggregateUserSkills = {
    _count: UserSkillsCountAggregateOutputType | null
    _min: UserSkillsMinAggregateOutputType | null
    _max: UserSkillsMaxAggregateOutputType | null
  }

  export type UserSkillsMinAggregateOutputType = {
    userId: string | null
    skillSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSkillsMaxAggregateOutputType = {
    userId: string | null
    skillSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSkillsCountAggregateOutputType = {
    userId: number
    skillSlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSkillsMinAggregateInputType = {
    userId?: true
    skillSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSkillsMaxAggregateInputType = {
    userId?: true
    skillSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSkillsCountAggregateInputType = {
    userId?: true
    skillSlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to aggregate.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkills
    **/
    _count?: true | UserSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillsMaxAggregateInputType
  }

  export type GetUserSkillsAggregateType<T extends UserSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkills[P]>
      : GetScalarType<T[P], AggregateUserSkills[P]>
  }




  export type UserSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithAggregationInput | UserSkillsOrderByWithAggregationInput[]
    by: UserSkillsScalarFieldEnum[] | UserSkillsScalarFieldEnum
    having?: UserSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillsCountAggregateInputType | true
    _min?: UserSkillsMinAggregateInputType
    _max?: UserSkillsMaxAggregateInputType
  }

  export type UserSkillsGroupByOutputType = {
    userId: string
    skillSlug: string
    createdAt: Date
    updatedAt: Date
    _count: UserSkillsCountAggregateOutputType | null
    _min: UserSkillsMinAggregateOutputType | null
    _max: UserSkillsMaxAggregateOutputType | null
  }

  type GetUserSkillsGroupByPayload<T extends UserSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillsGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkills"]>

  export type UserSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkills"]>

  export type UserSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    skillSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSkills"]>

  export type UserSkillsSelectScalar = {
    userId?: boolean
    skillSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "skillSlug" | "createdAt" | "updatedAt", ExtArgs["result"]["userSkills"]>
  export type UserSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type UserSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $UserSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkills"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      skillSlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSkills"]>
    composites: {}
  }

  type UserSkillsGetPayload<S extends boolean | null | undefined | UserSkillsDefaultArgs> = $Result.GetResult<Prisma.$UserSkillsPayload, S>

  type UserSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillsCountAggregateInputType | true
    }

  export interface UserSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkills'], meta: { name: 'UserSkills' } }
    /**
     * Find zero or one UserSkills that matches the filter.
     * @param {UserSkillsFindUniqueArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillsFindUniqueArgs>(args: SelectSubset<T, UserSkillsFindUniqueArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSkillsFindUniqueOrThrowArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindFirstArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillsFindFirstArgs>(args?: SelectSubset<T, UserSkillsFindFirstArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindFirstOrThrowArgs} args - Arguments to find a UserSkills
     * @example
     * // Get one UserSkills
     * const userSkills = await prisma.userSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkills
     * const userSkills = await prisma.userSkills.findMany()
     * 
     * // Get first 10 UserSkills
     * const userSkills = await prisma.userSkills.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSkillsWithUserIdOnly = await prisma.userSkills.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSkillsFindManyArgs>(args?: SelectSubset<T, UserSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkills.
     * @param {UserSkillsCreateArgs} args - Arguments to create a UserSkills.
     * @example
     * // Create one UserSkills
     * const UserSkills = await prisma.userSkills.create({
     *   data: {
     *     // ... data to create a UserSkills
     *   }
     * })
     * 
     */
    create<T extends UserSkillsCreateArgs>(args: SelectSubset<T, UserSkillsCreateArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkills.
     * @param {UserSkillsCreateManyArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkills = await prisma.userSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillsCreateManyArgs>(args?: SelectSubset<T, UserSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkills and returns the data saved in the database.
     * @param {UserSkillsCreateManyAndReturnArgs} args - Arguments to create many UserSkills.
     * @example
     * // Create many UserSkills
     * const userSkills = await prisma.userSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkills and only return the `userId`
     * const userSkillsWithUserIdOnly = await prisma.userSkills.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSkills.
     * @param {UserSkillsDeleteArgs} args - Arguments to delete one UserSkills.
     * @example
     * // Delete one UserSkills
     * const UserSkills = await prisma.userSkills.delete({
     *   where: {
     *     // ... filter to delete one UserSkills
     *   }
     * })
     * 
     */
    delete<T extends UserSkillsDeleteArgs>(args: SelectSubset<T, UserSkillsDeleteArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkills.
     * @param {UserSkillsUpdateArgs} args - Arguments to update one UserSkills.
     * @example
     * // Update one UserSkills
     * const userSkills = await prisma.userSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillsUpdateArgs>(args: SelectSubset<T, UserSkillsUpdateArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkills.
     * @param {UserSkillsDeleteManyArgs} args - Arguments to filter UserSkills to delete.
     * @example
     * // Delete a few UserSkills
     * const { count } = await prisma.userSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillsDeleteManyArgs>(args?: SelectSubset<T, UserSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkills
     * const userSkills = await prisma.userSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillsUpdateManyArgs>(args: SelectSubset<T, UserSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkills and returns the data updated in the database.
     * @param {UserSkillsUpdateManyAndReturnArgs} args - Arguments to update many UserSkills.
     * @example
     * // Update many UserSkills
     * const userSkills = await prisma.userSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSkills and only return the `userId`
     * const userSkillsWithUserIdOnly = await prisma.userSkills.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSkills.
     * @param {UserSkillsUpsertArgs} args - Arguments to update or create a UserSkills.
     * @example
     * // Update or create a UserSkills
     * const userSkills = await prisma.userSkills.upsert({
     *   create: {
     *     // ... data to create a UserSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkills we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillsUpsertArgs>(args: SelectSubset<T, UserSkillsUpsertArgs<ExtArgs>>): Prisma__UserSkillsClient<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsCountArgs} args - Arguments to filter UserSkills to count.
     * @example
     * // Count the number of UserSkills
     * const count = await prisma.userSkills.count({
     *   where: {
     *     // ... the filter for the UserSkills we want to count
     *   }
     * })
    **/
    count<T extends UserSkillsCountArgs>(
      args?: Subset<T, UserSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillsAggregateArgs>(args: Subset<T, UserSkillsAggregateArgs>): Prisma.PrismaPromise<GetUserSkillsAggregateType<T>>

    /**
     * Group by UserSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillsGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkills model
   */
  readonly fields: UserSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkills model
   */
  interface UserSkillsFieldRefs {
    readonly userId: FieldRef<"UserSkills", 'String'>
    readonly skillSlug: FieldRef<"UserSkills", 'String'>
    readonly createdAt: FieldRef<"UserSkills", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSkills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSkills findUnique
   */
  export type UserSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills findUniqueOrThrow
   */
  export type UserSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills findFirst
   */
  export type UserSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills findFirstOrThrow
   */
  export type UserSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkills.
     */
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills findMany
   */
  export type UserSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter, which UserSkills to fetch.
     */
    where?: UserSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkills to fetch.
     */
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkills.
     */
    cursor?: UserSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkills.
     */
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * UserSkills create
   */
  export type UserSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkills.
     */
    data: XOR<UserSkillsCreateInput, UserSkillsUncheckedCreateInput>
  }

  /**
   * UserSkills createMany
   */
  export type UserSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillsCreateManyInput | UserSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkills createManyAndReturn
   */
  export type UserSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSkills.
     */
    data: UserSkillsCreateManyInput | UserSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkills update
   */
  export type UserSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkills.
     */
    data: XOR<UserSkillsUpdateInput, UserSkillsUncheckedUpdateInput>
    /**
     * Choose, which UserSkills to update.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills updateMany
   */
  export type UserSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillsWhereInput
    /**
     * Limit how many UserSkills to update.
     */
    limit?: number
  }

  /**
   * UserSkills updateManyAndReturn
   */
  export type UserSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * The data used to update UserSkills.
     */
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyInput>
    /**
     * Filter which UserSkills to update
     */
    where?: UserSkillsWhereInput
    /**
     * Limit how many UserSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkills upsert
   */
  export type UserSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkills to update in case it exists.
     */
    where: UserSkillsWhereUniqueInput
    /**
     * In case the UserSkills found by the `where` argument doesn't exist, create a new UserSkills with this data.
     */
    create: XOR<UserSkillsCreateInput, UserSkillsUncheckedCreateInput>
    /**
     * In case the UserSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillsUpdateInput, UserSkillsUncheckedUpdateInput>
  }

  /**
   * UserSkills delete
   */
  export type UserSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    /**
     * Filter which UserSkills to delete.
     */
    where: UserSkillsWhereUniqueInput
  }

  /**
   * UserSkills deleteMany
   */
  export type UserSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkills to delete
     */
    where?: UserSkillsWhereInput
    /**
     * Limit how many UserSkills to delete.
     */
    limit?: number
  }

  /**
   * UserSkills without action
   */
  export type UserSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
  }


  /**
   * Model UserIndustry
   */

  export type AggregateUserIndustry = {
    _count: UserIndustryCountAggregateOutputType | null
    _min: UserIndustryMinAggregateOutputType | null
    _max: UserIndustryMaxAggregateOutputType | null
  }

  export type UserIndustryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    industryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIndustryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    industryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIndustryCountAggregateOutputType = {
    id: number
    userId: number
    industryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserIndustryMinAggregateInputType = {
    id?: true
    userId?: true
    industryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIndustryMaxAggregateInputType = {
    id?: true
    userId?: true
    industryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIndustryCountAggregateInputType = {
    id?: true
    userId?: true
    industryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserIndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIndustry to aggregate.
     */
    where?: UserIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIndustries to fetch.
     */
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIndustries
    **/
    _count?: true | UserIndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIndustryMaxAggregateInputType
  }

  export type GetUserIndustryAggregateType<T extends UserIndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIndustry[P]>
      : GetScalarType<T[P], AggregateUserIndustry[P]>
  }




  export type UserIndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIndustryWhereInput
    orderBy?: UserIndustryOrderByWithAggregationInput | UserIndustryOrderByWithAggregationInput[]
    by: UserIndustryScalarFieldEnum[] | UserIndustryScalarFieldEnum
    having?: UserIndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIndustryCountAggregateInputType | true
    _min?: UserIndustryMinAggregateInputType
    _max?: UserIndustryMaxAggregateInputType
  }

  export type UserIndustryGroupByOutputType = {
    id: string
    userId: string
    industryId: string
    createdAt: Date
    updatedAt: Date
    _count: UserIndustryCountAggregateOutputType | null
    _min: UserIndustryMinAggregateOutputType | null
    _max: UserIndustryMaxAggregateOutputType | null
  }

  type GetUserIndustryGroupByPayload<T extends UserIndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserIndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIndustryGroupByOutputType[P]>
            : GetScalarType<T[P], UserIndustryGroupByOutputType[P]>
        }
      >
    >


  export type UserIndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    industryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIndustry"]>

  export type UserIndustrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    industryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIndustry"]>

  export type UserIndustrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    industryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIndustry"]>

  export type UserIndustrySelectScalar = {
    id?: boolean
    userId?: boolean
    industryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserIndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "industryId" | "createdAt" | "updatedAt", ExtArgs["result"]["userIndustry"]>
  export type UserIndustryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type UserIndustryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type UserIndustryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $UserIndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserIndustry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      industry: Prisma.$IndustryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      industryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userIndustry"]>
    composites: {}
  }

  type UserIndustryGetPayload<S extends boolean | null | undefined | UserIndustryDefaultArgs> = $Result.GetResult<Prisma.$UserIndustryPayload, S>

  type UserIndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserIndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserIndustryCountAggregateInputType | true
    }

  export interface UserIndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserIndustry'], meta: { name: 'UserIndustry' } }
    /**
     * Find zero or one UserIndustry that matches the filter.
     * @param {UserIndustryFindUniqueArgs} args - Arguments to find a UserIndustry
     * @example
     * // Get one UserIndustry
     * const userIndustry = await prisma.userIndustry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserIndustryFindUniqueArgs>(args: SelectSubset<T, UserIndustryFindUniqueArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserIndustry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserIndustryFindUniqueOrThrowArgs} args - Arguments to find a UserIndustry
     * @example
     * // Get one UserIndustry
     * const userIndustry = await prisma.userIndustry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserIndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserIndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserIndustry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryFindFirstArgs} args - Arguments to find a UserIndustry
     * @example
     * // Get one UserIndustry
     * const userIndustry = await prisma.userIndustry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserIndustryFindFirstArgs>(args?: SelectSubset<T, UserIndustryFindFirstArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserIndustry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryFindFirstOrThrowArgs} args - Arguments to find a UserIndustry
     * @example
     * // Get one UserIndustry
     * const userIndustry = await prisma.userIndustry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserIndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserIndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserIndustries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIndustries
     * const userIndustries = await prisma.userIndustry.findMany()
     * 
     * // Get first 10 UserIndustries
     * const userIndustries = await prisma.userIndustry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userIndustryWithIdOnly = await prisma.userIndustry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserIndustryFindManyArgs>(args?: SelectSubset<T, UserIndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserIndustry.
     * @param {UserIndustryCreateArgs} args - Arguments to create a UserIndustry.
     * @example
     * // Create one UserIndustry
     * const UserIndustry = await prisma.userIndustry.create({
     *   data: {
     *     // ... data to create a UserIndustry
     *   }
     * })
     * 
     */
    create<T extends UserIndustryCreateArgs>(args: SelectSubset<T, UserIndustryCreateArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserIndustries.
     * @param {UserIndustryCreateManyArgs} args - Arguments to create many UserIndustries.
     * @example
     * // Create many UserIndustries
     * const userIndustry = await prisma.userIndustry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserIndustryCreateManyArgs>(args?: SelectSubset<T, UserIndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserIndustries and returns the data saved in the database.
     * @param {UserIndustryCreateManyAndReturnArgs} args - Arguments to create many UserIndustries.
     * @example
     * // Create many UserIndustries
     * const userIndustry = await prisma.userIndustry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserIndustries and only return the `id`
     * const userIndustryWithIdOnly = await prisma.userIndustry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserIndustryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserIndustryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserIndustry.
     * @param {UserIndustryDeleteArgs} args - Arguments to delete one UserIndustry.
     * @example
     * // Delete one UserIndustry
     * const UserIndustry = await prisma.userIndustry.delete({
     *   where: {
     *     // ... filter to delete one UserIndustry
     *   }
     * })
     * 
     */
    delete<T extends UserIndustryDeleteArgs>(args: SelectSubset<T, UserIndustryDeleteArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserIndustry.
     * @param {UserIndustryUpdateArgs} args - Arguments to update one UserIndustry.
     * @example
     * // Update one UserIndustry
     * const userIndustry = await prisma.userIndustry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserIndustryUpdateArgs>(args: SelectSubset<T, UserIndustryUpdateArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserIndustries.
     * @param {UserIndustryDeleteManyArgs} args - Arguments to filter UserIndustries to delete.
     * @example
     * // Delete a few UserIndustries
     * const { count } = await prisma.userIndustry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserIndustryDeleteManyArgs>(args?: SelectSubset<T, UserIndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIndustries
     * const userIndustry = await prisma.userIndustry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserIndustryUpdateManyArgs>(args: SelectSubset<T, UserIndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIndustries and returns the data updated in the database.
     * @param {UserIndustryUpdateManyAndReturnArgs} args - Arguments to update many UserIndustries.
     * @example
     * // Update many UserIndustries
     * const userIndustry = await prisma.userIndustry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserIndustries and only return the `id`
     * const userIndustryWithIdOnly = await prisma.userIndustry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserIndustryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserIndustryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserIndustry.
     * @param {UserIndustryUpsertArgs} args - Arguments to update or create a UserIndustry.
     * @example
     * // Update or create a UserIndustry
     * const userIndustry = await prisma.userIndustry.upsert({
     *   create: {
     *     // ... data to create a UserIndustry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIndustry we want to update
     *   }
     * })
     */
    upsert<T extends UserIndustryUpsertArgs>(args: SelectSubset<T, UserIndustryUpsertArgs<ExtArgs>>): Prisma__UserIndustryClient<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryCountArgs} args - Arguments to filter UserIndustries to count.
     * @example
     * // Count the number of UserIndustries
     * const count = await prisma.userIndustry.count({
     *   where: {
     *     // ... the filter for the UserIndustries we want to count
     *   }
     * })
    **/
    count<T extends UserIndustryCountArgs>(
      args?: Subset<T, UserIndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIndustryAggregateArgs>(args: Subset<T, UserIndustryAggregateArgs>): Prisma.PrismaPromise<GetUserIndustryAggregateType<T>>

    /**
     * Group by UserIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIndustryGroupByArgs['orderBy'] }
        : { orderBy?: UserIndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserIndustry model
   */
  readonly fields: UserIndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIndustry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserIndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserIndustry model
   */
  interface UserIndustryFieldRefs {
    readonly id: FieldRef<"UserIndustry", 'String'>
    readonly userId: FieldRef<"UserIndustry", 'String'>
    readonly industryId: FieldRef<"UserIndustry", 'String'>
    readonly createdAt: FieldRef<"UserIndustry", 'DateTime'>
    readonly updatedAt: FieldRef<"UserIndustry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserIndustry findUnique
   */
  export type UserIndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter, which UserIndustry to fetch.
     */
    where: UserIndustryWhereUniqueInput
  }

  /**
   * UserIndustry findUniqueOrThrow
   */
  export type UserIndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter, which UserIndustry to fetch.
     */
    where: UserIndustryWhereUniqueInput
  }

  /**
   * UserIndustry findFirst
   */
  export type UserIndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter, which UserIndustry to fetch.
     */
    where?: UserIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIndustries to fetch.
     */
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIndustries.
     */
    cursor?: UserIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIndustries.
     */
    distinct?: UserIndustryScalarFieldEnum | UserIndustryScalarFieldEnum[]
  }

  /**
   * UserIndustry findFirstOrThrow
   */
  export type UserIndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter, which UserIndustry to fetch.
     */
    where?: UserIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIndustries to fetch.
     */
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIndustries.
     */
    cursor?: UserIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIndustries.
     */
    distinct?: UserIndustryScalarFieldEnum | UserIndustryScalarFieldEnum[]
  }

  /**
   * UserIndustry findMany
   */
  export type UserIndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter, which UserIndustries to fetch.
     */
    where?: UserIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIndustries to fetch.
     */
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIndustries.
     */
    cursor?: UserIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIndustries.
     */
    skip?: number
    distinct?: UserIndustryScalarFieldEnum | UserIndustryScalarFieldEnum[]
  }

  /**
   * UserIndustry create
   */
  export type UserIndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserIndustry.
     */
    data: XOR<UserIndustryCreateInput, UserIndustryUncheckedCreateInput>
  }

  /**
   * UserIndustry createMany
   */
  export type UserIndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserIndustries.
     */
    data: UserIndustryCreateManyInput | UserIndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserIndustry createManyAndReturn
   */
  export type UserIndustryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * The data used to create many UserIndustries.
     */
    data: UserIndustryCreateManyInput | UserIndustryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserIndustry update
   */
  export type UserIndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserIndustry.
     */
    data: XOR<UserIndustryUpdateInput, UserIndustryUncheckedUpdateInput>
    /**
     * Choose, which UserIndustry to update.
     */
    where: UserIndustryWhereUniqueInput
  }

  /**
   * UserIndustry updateMany
   */
  export type UserIndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserIndustries.
     */
    data: XOR<UserIndustryUpdateManyMutationInput, UserIndustryUncheckedUpdateManyInput>
    /**
     * Filter which UserIndustries to update
     */
    where?: UserIndustryWhereInput
    /**
     * Limit how many UserIndustries to update.
     */
    limit?: number
  }

  /**
   * UserIndustry updateManyAndReturn
   */
  export type UserIndustryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * The data used to update UserIndustries.
     */
    data: XOR<UserIndustryUpdateManyMutationInput, UserIndustryUncheckedUpdateManyInput>
    /**
     * Filter which UserIndustries to update
     */
    where?: UserIndustryWhereInput
    /**
     * Limit how many UserIndustries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserIndustry upsert
   */
  export type UserIndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserIndustry to update in case it exists.
     */
    where: UserIndustryWhereUniqueInput
    /**
     * In case the UserIndustry found by the `where` argument doesn't exist, create a new UserIndustry with this data.
     */
    create: XOR<UserIndustryCreateInput, UserIndustryUncheckedCreateInput>
    /**
     * In case the UserIndustry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserIndustryUpdateInput, UserIndustryUncheckedUpdateInput>
  }

  /**
   * UserIndustry delete
   */
  export type UserIndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    /**
     * Filter which UserIndustry to delete.
     */
    where: UserIndustryWhereUniqueInput
  }

  /**
   * UserIndustry deleteMany
   */
  export type UserIndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIndustries to delete
     */
    where?: UserIndustryWhereInput
    /**
     * Limit how many UserIndustries to delete.
     */
    limit?: number
  }

  /**
   * UserIndustry without action
   */
  export type UserIndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    issuedAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    issuedAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    issuedAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    issuedAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    issuedAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    issuedAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    issuedAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    issuedAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    issuedAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    issuedAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    issuedAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "issuedAt" | "revokedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      issuedAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly issuedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model CompanyRevenue
   */

  export type AggregateCompanyRevenue = {
    _count: CompanyRevenueCountAggregateOutputType | null
    _avg: CompanyRevenueAvgAggregateOutputType | null
    _sum: CompanyRevenueSumAggregateOutputType | null
    _min: CompanyRevenueMinAggregateOutputType | null
    _max: CompanyRevenueMaxAggregateOutputType | null
  }

  export type CompanyRevenueAvgAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type CompanyRevenueSumAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type CompanyRevenueMinAggregateOutputType = {
    id: string | null
    year: number | null
    total: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyRevenueMaxAggregateOutputType = {
    id: string | null
    year: number | null
    total: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyRevenueCountAggregateOutputType = {
    id: number
    year: number
    total: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyRevenueAvgAggregateInputType = {
    year?: true
    total?: true
  }

  export type CompanyRevenueSumAggregateInputType = {
    year?: true
    total?: true
  }

  export type CompanyRevenueMinAggregateInputType = {
    id?: true
    year?: true
    total?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyRevenueMaxAggregateInputType = {
    id?: true
    year?: true
    total?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyRevenueCountAggregateInputType = {
    id?: true
    year?: true
    total?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyRevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRevenue to aggregate.
     */
    where?: CompanyRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRevenues to fetch.
     */
    orderBy?: CompanyRevenueOrderByWithRelationInput | CompanyRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyRevenues
    **/
    _count?: true | CompanyRevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyRevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyRevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyRevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyRevenueMaxAggregateInputType
  }

  export type GetCompanyRevenueAggregateType<T extends CompanyRevenueAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyRevenue[P]>
      : GetScalarType<T[P], AggregateCompanyRevenue[P]>
  }




  export type CompanyRevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRevenueWhereInput
    orderBy?: CompanyRevenueOrderByWithAggregationInput | CompanyRevenueOrderByWithAggregationInput[]
    by: CompanyRevenueScalarFieldEnum[] | CompanyRevenueScalarFieldEnum
    having?: CompanyRevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyRevenueCountAggregateInputType | true
    _avg?: CompanyRevenueAvgAggregateInputType
    _sum?: CompanyRevenueSumAggregateInputType
    _min?: CompanyRevenueMinAggregateInputType
    _max?: CompanyRevenueMaxAggregateInputType
  }

  export type CompanyRevenueGroupByOutputType = {
    id: string
    year: number
    total: number
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyRevenueCountAggregateOutputType | null
    _avg: CompanyRevenueAvgAggregateOutputType | null
    _sum: CompanyRevenueSumAggregateOutputType | null
    _min: CompanyRevenueMinAggregateOutputType | null
    _max: CompanyRevenueMaxAggregateOutputType | null
  }

  type GetCompanyRevenueGroupByPayload<T extends CompanyRevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyRevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyRevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyRevenueGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyRevenueGroupByOutputType[P]>
        }
      >
    >


  export type CompanyRevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyRevenue"]>

  export type CompanyRevenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyRevenue"]>

  export type CompanyRevenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyRevenue"]>

  export type CompanyRevenueSelectScalar = {
    id?: boolean
    year?: boolean
    total?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyRevenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "total" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["companyRevenue"]>
  export type CompanyRevenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyRevenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyRevenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyRevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyRevenue"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      total: number
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyRevenue"]>
    composites: {}
  }

  type CompanyRevenueGetPayload<S extends boolean | null | undefined | CompanyRevenueDefaultArgs> = $Result.GetResult<Prisma.$CompanyRevenuePayload, S>

  type CompanyRevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyRevenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyRevenueCountAggregateInputType | true
    }

  export interface CompanyRevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyRevenue'], meta: { name: 'CompanyRevenue' } }
    /**
     * Find zero or one CompanyRevenue that matches the filter.
     * @param {CompanyRevenueFindUniqueArgs} args - Arguments to find a CompanyRevenue
     * @example
     * // Get one CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyRevenueFindUniqueArgs>(args: SelectSubset<T, CompanyRevenueFindUniqueArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyRevenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyRevenueFindUniqueOrThrowArgs} args - Arguments to find a CompanyRevenue
     * @example
     * // Get one CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyRevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyRevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRevenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueFindFirstArgs} args - Arguments to find a CompanyRevenue
     * @example
     * // Get one CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyRevenueFindFirstArgs>(args?: SelectSubset<T, CompanyRevenueFindFirstArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRevenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueFindFirstOrThrowArgs} args - Arguments to find a CompanyRevenue
     * @example
     * // Get one CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyRevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyRevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyRevenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyRevenues
     * const companyRevenues = await prisma.companyRevenue.findMany()
     * 
     * // Get first 10 CompanyRevenues
     * const companyRevenues = await prisma.companyRevenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyRevenueWithIdOnly = await prisma.companyRevenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyRevenueFindManyArgs>(args?: SelectSubset<T, CompanyRevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyRevenue.
     * @param {CompanyRevenueCreateArgs} args - Arguments to create a CompanyRevenue.
     * @example
     * // Create one CompanyRevenue
     * const CompanyRevenue = await prisma.companyRevenue.create({
     *   data: {
     *     // ... data to create a CompanyRevenue
     *   }
     * })
     * 
     */
    create<T extends CompanyRevenueCreateArgs>(args: SelectSubset<T, CompanyRevenueCreateArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyRevenues.
     * @param {CompanyRevenueCreateManyArgs} args - Arguments to create many CompanyRevenues.
     * @example
     * // Create many CompanyRevenues
     * const companyRevenue = await prisma.companyRevenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyRevenueCreateManyArgs>(args?: SelectSubset<T, CompanyRevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyRevenues and returns the data saved in the database.
     * @param {CompanyRevenueCreateManyAndReturnArgs} args - Arguments to create many CompanyRevenues.
     * @example
     * // Create many CompanyRevenues
     * const companyRevenue = await prisma.companyRevenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyRevenues and only return the `id`
     * const companyRevenueWithIdOnly = await prisma.companyRevenue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyRevenueCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyRevenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyRevenue.
     * @param {CompanyRevenueDeleteArgs} args - Arguments to delete one CompanyRevenue.
     * @example
     * // Delete one CompanyRevenue
     * const CompanyRevenue = await prisma.companyRevenue.delete({
     *   where: {
     *     // ... filter to delete one CompanyRevenue
     *   }
     * })
     * 
     */
    delete<T extends CompanyRevenueDeleteArgs>(args: SelectSubset<T, CompanyRevenueDeleteArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyRevenue.
     * @param {CompanyRevenueUpdateArgs} args - Arguments to update one CompanyRevenue.
     * @example
     * // Update one CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyRevenueUpdateArgs>(args: SelectSubset<T, CompanyRevenueUpdateArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyRevenues.
     * @param {CompanyRevenueDeleteManyArgs} args - Arguments to filter CompanyRevenues to delete.
     * @example
     * // Delete a few CompanyRevenues
     * const { count } = await prisma.companyRevenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyRevenueDeleteManyArgs>(args?: SelectSubset<T, CompanyRevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyRevenues
     * const companyRevenue = await prisma.companyRevenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyRevenueUpdateManyArgs>(args: SelectSubset<T, CompanyRevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyRevenues and returns the data updated in the database.
     * @param {CompanyRevenueUpdateManyAndReturnArgs} args - Arguments to update many CompanyRevenues.
     * @example
     * // Update many CompanyRevenues
     * const companyRevenue = await prisma.companyRevenue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyRevenues and only return the `id`
     * const companyRevenueWithIdOnly = await prisma.companyRevenue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyRevenueUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyRevenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyRevenue.
     * @param {CompanyRevenueUpsertArgs} args - Arguments to update or create a CompanyRevenue.
     * @example
     * // Update or create a CompanyRevenue
     * const companyRevenue = await prisma.companyRevenue.upsert({
     *   create: {
     *     // ... data to create a CompanyRevenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyRevenue we want to update
     *   }
     * })
     */
    upsert<T extends CompanyRevenueUpsertArgs>(args: SelectSubset<T, CompanyRevenueUpsertArgs<ExtArgs>>): Prisma__CompanyRevenueClient<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueCountArgs} args - Arguments to filter CompanyRevenues to count.
     * @example
     * // Count the number of CompanyRevenues
     * const count = await prisma.companyRevenue.count({
     *   where: {
     *     // ... the filter for the CompanyRevenues we want to count
     *   }
     * })
    **/
    count<T extends CompanyRevenueCountArgs>(
      args?: Subset<T, CompanyRevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyRevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyRevenueAggregateArgs>(args: Subset<T, CompanyRevenueAggregateArgs>): Prisma.PrismaPromise<GetCompanyRevenueAggregateType<T>>

    /**
     * Group by CompanyRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyRevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyRevenueGroupByArgs['orderBy'] }
        : { orderBy?: CompanyRevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyRevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyRevenue model
   */
  readonly fields: CompanyRevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyRevenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyRevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyRevenue model
   */
  interface CompanyRevenueFieldRefs {
    readonly id: FieldRef<"CompanyRevenue", 'String'>
    readonly year: FieldRef<"CompanyRevenue", 'Int'>
    readonly total: FieldRef<"CompanyRevenue", 'Float'>
    readonly companyId: FieldRef<"CompanyRevenue", 'String'>
    readonly createdAt: FieldRef<"CompanyRevenue", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyRevenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyRevenue findUnique
   */
  export type CompanyRevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRevenue to fetch.
     */
    where: CompanyRevenueWhereUniqueInput
  }

  /**
   * CompanyRevenue findUniqueOrThrow
   */
  export type CompanyRevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRevenue to fetch.
     */
    where: CompanyRevenueWhereUniqueInput
  }

  /**
   * CompanyRevenue findFirst
   */
  export type CompanyRevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRevenue to fetch.
     */
    where?: CompanyRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRevenues to fetch.
     */
    orderBy?: CompanyRevenueOrderByWithRelationInput | CompanyRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRevenues.
     */
    cursor?: CompanyRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRevenues.
     */
    distinct?: CompanyRevenueScalarFieldEnum | CompanyRevenueScalarFieldEnum[]
  }

  /**
   * CompanyRevenue findFirstOrThrow
   */
  export type CompanyRevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRevenue to fetch.
     */
    where?: CompanyRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRevenues to fetch.
     */
    orderBy?: CompanyRevenueOrderByWithRelationInput | CompanyRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRevenues.
     */
    cursor?: CompanyRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRevenues.
     */
    distinct?: CompanyRevenueScalarFieldEnum | CompanyRevenueScalarFieldEnum[]
  }

  /**
   * CompanyRevenue findMany
   */
  export type CompanyRevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRevenues to fetch.
     */
    where?: CompanyRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRevenues to fetch.
     */
    orderBy?: CompanyRevenueOrderByWithRelationInput | CompanyRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyRevenues.
     */
    cursor?: CompanyRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRevenues.
     */
    skip?: number
    distinct?: CompanyRevenueScalarFieldEnum | CompanyRevenueScalarFieldEnum[]
  }

  /**
   * CompanyRevenue create
   */
  export type CompanyRevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyRevenue.
     */
    data: XOR<CompanyRevenueCreateInput, CompanyRevenueUncheckedCreateInput>
  }

  /**
   * CompanyRevenue createMany
   */
  export type CompanyRevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyRevenues.
     */
    data: CompanyRevenueCreateManyInput | CompanyRevenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyRevenue createManyAndReturn
   */
  export type CompanyRevenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyRevenues.
     */
    data: CompanyRevenueCreateManyInput | CompanyRevenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyRevenue update
   */
  export type CompanyRevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyRevenue.
     */
    data: XOR<CompanyRevenueUpdateInput, CompanyRevenueUncheckedUpdateInput>
    /**
     * Choose, which CompanyRevenue to update.
     */
    where: CompanyRevenueWhereUniqueInput
  }

  /**
   * CompanyRevenue updateMany
   */
  export type CompanyRevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyRevenues.
     */
    data: XOR<CompanyRevenueUpdateManyMutationInput, CompanyRevenueUncheckedUpdateManyInput>
    /**
     * Filter which CompanyRevenues to update
     */
    where?: CompanyRevenueWhereInput
    /**
     * Limit how many CompanyRevenues to update.
     */
    limit?: number
  }

  /**
   * CompanyRevenue updateManyAndReturn
   */
  export type CompanyRevenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * The data used to update CompanyRevenues.
     */
    data: XOR<CompanyRevenueUpdateManyMutationInput, CompanyRevenueUncheckedUpdateManyInput>
    /**
     * Filter which CompanyRevenues to update
     */
    where?: CompanyRevenueWhereInput
    /**
     * Limit how many CompanyRevenues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyRevenue upsert
   */
  export type CompanyRevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyRevenue to update in case it exists.
     */
    where: CompanyRevenueWhereUniqueInput
    /**
     * In case the CompanyRevenue found by the `where` argument doesn't exist, create a new CompanyRevenue with this data.
     */
    create: XOR<CompanyRevenueCreateInput, CompanyRevenueUncheckedCreateInput>
    /**
     * In case the CompanyRevenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyRevenueUpdateInput, CompanyRevenueUncheckedUpdateInput>
  }

  /**
   * CompanyRevenue delete
   */
  export type CompanyRevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    /**
     * Filter which CompanyRevenue to delete.
     */
    where: CompanyRevenueWhereUniqueInput
  }

  /**
   * CompanyRevenue deleteMany
   */
  export type CompanyRevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRevenues to delete
     */
    where?: CompanyRevenueWhereInput
    /**
     * Limit how many CompanyRevenues to delete.
     */
    limit?: number
  }

  /**
   * CompanyRevenue without action
   */
  export type CompanyRevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
  }


  /**
   * Model FreelanceRevenue
   */

  export type AggregateFreelanceRevenue = {
    _count: FreelanceRevenueCountAggregateOutputType | null
    _avg: FreelanceRevenueAvgAggregateOutputType | null
    _sum: FreelanceRevenueSumAggregateOutputType | null
    _min: FreelanceRevenueMinAggregateOutputType | null
    _max: FreelanceRevenueMaxAggregateOutputType | null
  }

  export type FreelanceRevenueAvgAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type FreelanceRevenueSumAggregateOutputType = {
    year: number | null
    total: number | null
  }

  export type FreelanceRevenueMinAggregateOutputType = {
    id: string | null
    year: number | null
    total: number | null
    freelanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceRevenueMaxAggregateOutputType = {
    id: string | null
    year: number | null
    total: number | null
    freelanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceRevenueCountAggregateOutputType = {
    id: number
    year: number
    total: number
    freelanceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelanceRevenueAvgAggregateInputType = {
    year?: true
    total?: true
  }

  export type FreelanceRevenueSumAggregateInputType = {
    year?: true
    total?: true
  }

  export type FreelanceRevenueMinAggregateInputType = {
    id?: true
    year?: true
    total?: true
    freelanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceRevenueMaxAggregateInputType = {
    id?: true
    year?: true
    total?: true
    freelanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceRevenueCountAggregateInputType = {
    id?: true
    year?: true
    total?: true
    freelanceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelanceRevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceRevenue to aggregate.
     */
    where?: FreelanceRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceRevenues to fetch.
     */
    orderBy?: FreelanceRevenueOrderByWithRelationInput | FreelanceRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelanceRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelanceRevenues
    **/
    _count?: true | FreelanceRevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelanceRevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelanceRevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelanceRevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelanceRevenueMaxAggregateInputType
  }

  export type GetFreelanceRevenueAggregateType<T extends FreelanceRevenueAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelanceRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelanceRevenue[P]>
      : GetScalarType<T[P], AggregateFreelanceRevenue[P]>
  }




  export type FreelanceRevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceRevenueWhereInput
    orderBy?: FreelanceRevenueOrderByWithAggregationInput | FreelanceRevenueOrderByWithAggregationInput[]
    by: FreelanceRevenueScalarFieldEnum[] | FreelanceRevenueScalarFieldEnum
    having?: FreelanceRevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelanceRevenueCountAggregateInputType | true
    _avg?: FreelanceRevenueAvgAggregateInputType
    _sum?: FreelanceRevenueSumAggregateInputType
    _min?: FreelanceRevenueMinAggregateInputType
    _max?: FreelanceRevenueMaxAggregateInputType
  }

  export type FreelanceRevenueGroupByOutputType = {
    id: string
    year: number
    total: number
    freelanceId: string
    createdAt: Date
    updatedAt: Date
    _count: FreelanceRevenueCountAggregateOutputType | null
    _avg: FreelanceRevenueAvgAggregateOutputType | null
    _sum: FreelanceRevenueSumAggregateOutputType | null
    _min: FreelanceRevenueMinAggregateOutputType | null
    _max: FreelanceRevenueMaxAggregateOutputType | null
  }

  type GetFreelanceRevenueGroupByPayload<T extends FreelanceRevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelanceRevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelanceRevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelanceRevenueGroupByOutputType[P]>
            : GetScalarType<T[P], FreelanceRevenueGroupByOutputType[P]>
        }
      >
    >


  export type FreelanceRevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    freelanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceRevenue"]>

  export type FreelanceRevenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    freelanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceRevenue"]>

  export type FreelanceRevenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    total?: boolean
    freelanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceRevenue"]>

  export type FreelanceRevenueSelectScalar = {
    id?: boolean
    year?: boolean
    total?: boolean
    freelanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelanceRevenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "total" | "freelanceId" | "createdAt" | "updatedAt", ExtArgs["result"]["freelanceRevenue"]>
  export type FreelanceRevenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }
  export type FreelanceRevenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }
  export type FreelanceRevenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
  }

  export type $FreelanceRevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelanceRevenue"
    objects: {
      Freelance: Prisma.$FreelancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      total: number
      freelanceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelanceRevenue"]>
    composites: {}
  }

  type FreelanceRevenueGetPayload<S extends boolean | null | undefined | FreelanceRevenueDefaultArgs> = $Result.GetResult<Prisma.$FreelanceRevenuePayload, S>

  type FreelanceRevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelanceRevenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelanceRevenueCountAggregateInputType | true
    }

  export interface FreelanceRevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelanceRevenue'], meta: { name: 'FreelanceRevenue' } }
    /**
     * Find zero or one FreelanceRevenue that matches the filter.
     * @param {FreelanceRevenueFindUniqueArgs} args - Arguments to find a FreelanceRevenue
     * @example
     * // Get one FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelanceRevenueFindUniqueArgs>(args: SelectSubset<T, FreelanceRevenueFindUniqueArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreelanceRevenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelanceRevenueFindUniqueOrThrowArgs} args - Arguments to find a FreelanceRevenue
     * @example
     * // Get one FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelanceRevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelanceRevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceRevenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueFindFirstArgs} args - Arguments to find a FreelanceRevenue
     * @example
     * // Get one FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelanceRevenueFindFirstArgs>(args?: SelectSubset<T, FreelanceRevenueFindFirstArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceRevenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueFindFirstOrThrowArgs} args - Arguments to find a FreelanceRevenue
     * @example
     * // Get one FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelanceRevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelanceRevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreelanceRevenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelanceRevenues
     * const freelanceRevenues = await prisma.freelanceRevenue.findMany()
     * 
     * // Get first 10 FreelanceRevenues
     * const freelanceRevenues = await prisma.freelanceRevenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelanceRevenueWithIdOnly = await prisma.freelanceRevenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelanceRevenueFindManyArgs>(args?: SelectSubset<T, FreelanceRevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreelanceRevenue.
     * @param {FreelanceRevenueCreateArgs} args - Arguments to create a FreelanceRevenue.
     * @example
     * // Create one FreelanceRevenue
     * const FreelanceRevenue = await prisma.freelanceRevenue.create({
     *   data: {
     *     // ... data to create a FreelanceRevenue
     *   }
     * })
     * 
     */
    create<T extends FreelanceRevenueCreateArgs>(args: SelectSubset<T, FreelanceRevenueCreateArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreelanceRevenues.
     * @param {FreelanceRevenueCreateManyArgs} args - Arguments to create many FreelanceRevenues.
     * @example
     * // Create many FreelanceRevenues
     * const freelanceRevenue = await prisma.freelanceRevenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelanceRevenueCreateManyArgs>(args?: SelectSubset<T, FreelanceRevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelanceRevenues and returns the data saved in the database.
     * @param {FreelanceRevenueCreateManyAndReturnArgs} args - Arguments to create many FreelanceRevenues.
     * @example
     * // Create many FreelanceRevenues
     * const freelanceRevenue = await prisma.freelanceRevenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelanceRevenues and only return the `id`
     * const freelanceRevenueWithIdOnly = await prisma.freelanceRevenue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelanceRevenueCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelanceRevenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreelanceRevenue.
     * @param {FreelanceRevenueDeleteArgs} args - Arguments to delete one FreelanceRevenue.
     * @example
     * // Delete one FreelanceRevenue
     * const FreelanceRevenue = await prisma.freelanceRevenue.delete({
     *   where: {
     *     // ... filter to delete one FreelanceRevenue
     *   }
     * })
     * 
     */
    delete<T extends FreelanceRevenueDeleteArgs>(args: SelectSubset<T, FreelanceRevenueDeleteArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreelanceRevenue.
     * @param {FreelanceRevenueUpdateArgs} args - Arguments to update one FreelanceRevenue.
     * @example
     * // Update one FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelanceRevenueUpdateArgs>(args: SelectSubset<T, FreelanceRevenueUpdateArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreelanceRevenues.
     * @param {FreelanceRevenueDeleteManyArgs} args - Arguments to filter FreelanceRevenues to delete.
     * @example
     * // Delete a few FreelanceRevenues
     * const { count } = await prisma.freelanceRevenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelanceRevenueDeleteManyArgs>(args?: SelectSubset<T, FreelanceRevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelanceRevenues
     * const freelanceRevenue = await prisma.freelanceRevenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelanceRevenueUpdateManyArgs>(args: SelectSubset<T, FreelanceRevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceRevenues and returns the data updated in the database.
     * @param {FreelanceRevenueUpdateManyAndReturnArgs} args - Arguments to update many FreelanceRevenues.
     * @example
     * // Update many FreelanceRevenues
     * const freelanceRevenue = await prisma.freelanceRevenue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreelanceRevenues and only return the `id`
     * const freelanceRevenueWithIdOnly = await prisma.freelanceRevenue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelanceRevenueUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelanceRevenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreelanceRevenue.
     * @param {FreelanceRevenueUpsertArgs} args - Arguments to update or create a FreelanceRevenue.
     * @example
     * // Update or create a FreelanceRevenue
     * const freelanceRevenue = await prisma.freelanceRevenue.upsert({
     *   create: {
     *     // ... data to create a FreelanceRevenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelanceRevenue we want to update
     *   }
     * })
     */
    upsert<T extends FreelanceRevenueUpsertArgs>(args: SelectSubset<T, FreelanceRevenueUpsertArgs<ExtArgs>>): Prisma__FreelanceRevenueClient<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreelanceRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueCountArgs} args - Arguments to filter FreelanceRevenues to count.
     * @example
     * // Count the number of FreelanceRevenues
     * const count = await prisma.freelanceRevenue.count({
     *   where: {
     *     // ... the filter for the FreelanceRevenues we want to count
     *   }
     * })
    **/
    count<T extends FreelanceRevenueCountArgs>(
      args?: Subset<T, FreelanceRevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelanceRevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelanceRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelanceRevenueAggregateArgs>(args: Subset<T, FreelanceRevenueAggregateArgs>): Prisma.PrismaPromise<GetFreelanceRevenueAggregateType<T>>

    /**
     * Group by FreelanceRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceRevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelanceRevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelanceRevenueGroupByArgs['orderBy'] }
        : { orderBy?: FreelanceRevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelanceRevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelanceRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelanceRevenue model
   */
  readonly fields: FreelanceRevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelanceRevenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelanceRevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Freelance<T extends FreelanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FreelanceDefaultArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelanceRevenue model
   */
  interface FreelanceRevenueFieldRefs {
    readonly id: FieldRef<"FreelanceRevenue", 'String'>
    readonly year: FieldRef<"FreelanceRevenue", 'Int'>
    readonly total: FieldRef<"FreelanceRevenue", 'Float'>
    readonly freelanceId: FieldRef<"FreelanceRevenue", 'String'>
    readonly createdAt: FieldRef<"FreelanceRevenue", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelanceRevenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelanceRevenue findUnique
   */
  export type FreelanceRevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceRevenue to fetch.
     */
    where: FreelanceRevenueWhereUniqueInput
  }

  /**
   * FreelanceRevenue findUniqueOrThrow
   */
  export type FreelanceRevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceRevenue to fetch.
     */
    where: FreelanceRevenueWhereUniqueInput
  }

  /**
   * FreelanceRevenue findFirst
   */
  export type FreelanceRevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceRevenue to fetch.
     */
    where?: FreelanceRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceRevenues to fetch.
     */
    orderBy?: FreelanceRevenueOrderByWithRelationInput | FreelanceRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceRevenues.
     */
    cursor?: FreelanceRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceRevenues.
     */
    distinct?: FreelanceRevenueScalarFieldEnum | FreelanceRevenueScalarFieldEnum[]
  }

  /**
   * FreelanceRevenue findFirstOrThrow
   */
  export type FreelanceRevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceRevenue to fetch.
     */
    where?: FreelanceRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceRevenues to fetch.
     */
    orderBy?: FreelanceRevenueOrderByWithRelationInput | FreelanceRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceRevenues.
     */
    cursor?: FreelanceRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceRevenues.
     */
    distinct?: FreelanceRevenueScalarFieldEnum | FreelanceRevenueScalarFieldEnum[]
  }

  /**
   * FreelanceRevenue findMany
   */
  export type FreelanceRevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceRevenues to fetch.
     */
    where?: FreelanceRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceRevenues to fetch.
     */
    orderBy?: FreelanceRevenueOrderByWithRelationInput | FreelanceRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelanceRevenues.
     */
    cursor?: FreelanceRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceRevenues.
     */
    skip?: number
    distinct?: FreelanceRevenueScalarFieldEnum | FreelanceRevenueScalarFieldEnum[]
  }

  /**
   * FreelanceRevenue create
   */
  export type FreelanceRevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelanceRevenue.
     */
    data: XOR<FreelanceRevenueCreateInput, FreelanceRevenueUncheckedCreateInput>
  }

  /**
   * FreelanceRevenue createMany
   */
  export type FreelanceRevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelanceRevenues.
     */
    data: FreelanceRevenueCreateManyInput | FreelanceRevenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelanceRevenue createManyAndReturn
   */
  export type FreelanceRevenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * The data used to create many FreelanceRevenues.
     */
    data: FreelanceRevenueCreateManyInput | FreelanceRevenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceRevenue update
   */
  export type FreelanceRevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelanceRevenue.
     */
    data: XOR<FreelanceRevenueUpdateInput, FreelanceRevenueUncheckedUpdateInput>
    /**
     * Choose, which FreelanceRevenue to update.
     */
    where: FreelanceRevenueWhereUniqueInput
  }

  /**
   * FreelanceRevenue updateMany
   */
  export type FreelanceRevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelanceRevenues.
     */
    data: XOR<FreelanceRevenueUpdateManyMutationInput, FreelanceRevenueUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceRevenues to update
     */
    where?: FreelanceRevenueWhereInput
    /**
     * Limit how many FreelanceRevenues to update.
     */
    limit?: number
  }

  /**
   * FreelanceRevenue updateManyAndReturn
   */
  export type FreelanceRevenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * The data used to update FreelanceRevenues.
     */
    data: XOR<FreelanceRevenueUpdateManyMutationInput, FreelanceRevenueUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceRevenues to update
     */
    where?: FreelanceRevenueWhereInput
    /**
     * Limit how many FreelanceRevenues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceRevenue upsert
   */
  export type FreelanceRevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelanceRevenue to update in case it exists.
     */
    where: FreelanceRevenueWhereUniqueInput
    /**
     * In case the FreelanceRevenue found by the `where` argument doesn't exist, create a new FreelanceRevenue with this data.
     */
    create: XOR<FreelanceRevenueCreateInput, FreelanceRevenueUncheckedCreateInput>
    /**
     * In case the FreelanceRevenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelanceRevenueUpdateInput, FreelanceRevenueUncheckedUpdateInput>
  }

  /**
   * FreelanceRevenue delete
   */
  export type FreelanceRevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    /**
     * Filter which FreelanceRevenue to delete.
     */
    where: FreelanceRevenueWhereUniqueInput
  }

  /**
   * FreelanceRevenue deleteMany
   */
  export type FreelanceRevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceRevenues to delete
     */
    where?: FreelanceRevenueWhereInput
    /**
     * Limit how many FreelanceRevenues to delete.
     */
    limit?: number
  }

  /**
   * FreelanceRevenue without action
   */
  export type FreelanceRevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
  }


  /**
   * Model RevenueStream
   */

  export type AggregateRevenueStream = {
    _count: RevenueStreamCountAggregateOutputType | null
    _avg: RevenueStreamAvgAggregateOutputType | null
    _sum: RevenueStreamSumAggregateOutputType | null
    _min: RevenueStreamMinAggregateOutputType | null
    _max: RevenueStreamMaxAggregateOutputType | null
  }

  export type RevenueStreamAvgAggregateOutputType = {
    year: number | null
    percent: number | null
    ctrPercent: number | null
    value: number | null
  }

  export type RevenueStreamSumAggregateOutputType = {
    year: number | null
    percent: number | null
    ctrPercent: number | null
    value: number | null
  }

  export type RevenueStreamMinAggregateOutputType = {
    id: string | null
    year: number | null
    industryTypeSlug: string | null
    categorySlug: string | null
    sourceSlug: string | null
    channelSlug: string | null
    segmentSlug: string | null
    percent: number | null
    ctrPercent: number | null
    value: number | null
    companyId: string | null
    companyJuristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueStreamMaxAggregateOutputType = {
    id: string | null
    year: number | null
    industryTypeSlug: string | null
    categorySlug: string | null
    sourceSlug: string | null
    channelSlug: string | null
    segmentSlug: string | null
    percent: number | null
    ctrPercent: number | null
    value: number | null
    companyId: string | null
    companyJuristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueStreamCountAggregateOutputType = {
    id: number
    year: number
    industryTypeSlug: number
    categorySlug: number
    sourceSlug: number
    channelSlug: number
    segmentSlug: number
    percent: number
    ctrPercent: number
    value: number
    companyId: number
    companyJuristicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RevenueStreamAvgAggregateInputType = {
    year?: true
    percent?: true
    ctrPercent?: true
    value?: true
  }

  export type RevenueStreamSumAggregateInputType = {
    year?: true
    percent?: true
    ctrPercent?: true
    value?: true
  }

  export type RevenueStreamMinAggregateInputType = {
    id?: true
    year?: true
    industryTypeSlug?: true
    categorySlug?: true
    sourceSlug?: true
    channelSlug?: true
    segmentSlug?: true
    percent?: true
    ctrPercent?: true
    value?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueStreamMaxAggregateInputType = {
    id?: true
    year?: true
    industryTypeSlug?: true
    categorySlug?: true
    sourceSlug?: true
    channelSlug?: true
    segmentSlug?: true
    percent?: true
    ctrPercent?: true
    value?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueStreamCountAggregateInputType = {
    id?: true
    year?: true
    industryTypeSlug?: true
    categorySlug?: true
    sourceSlug?: true
    channelSlug?: true
    segmentSlug?: true
    percent?: true
    ctrPercent?: true
    value?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RevenueStreamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueStream to aggregate.
     */
    where?: RevenueStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueStreams to fetch.
     */
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueStreams
    **/
    _count?: true | RevenueStreamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueStreamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueStreamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueStreamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueStreamMaxAggregateInputType
  }

  export type GetRevenueStreamAggregateType<T extends RevenueStreamAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueStream]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueStream[P]>
      : GetScalarType<T[P], AggregateRevenueStream[P]>
  }




  export type RevenueStreamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithAggregationInput | RevenueStreamOrderByWithAggregationInput[]
    by: RevenueStreamScalarFieldEnum[] | RevenueStreamScalarFieldEnum
    having?: RevenueStreamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueStreamCountAggregateInputType | true
    _avg?: RevenueStreamAvgAggregateInputType
    _sum?: RevenueStreamSumAggregateInputType
    _min?: RevenueStreamMinAggregateInputType
    _max?: RevenueStreamMaxAggregateInputType
  }

  export type RevenueStreamGroupByOutputType = {
    id: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value: number | null
    companyId: string
    companyJuristicId: string
    createdAt: Date
    updatedAt: Date
    _count: RevenueStreamCountAggregateOutputType | null
    _avg: RevenueStreamAvgAggregateOutputType | null
    _sum: RevenueStreamSumAggregateOutputType | null
    _min: RevenueStreamMinAggregateOutputType | null
    _max: RevenueStreamMaxAggregateOutputType | null
  }

  type GetRevenueStreamGroupByPayload<T extends RevenueStreamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueStreamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueStreamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueStreamGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueStreamGroupByOutputType[P]>
        }
      >
    >


  export type RevenueStreamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    industryTypeSlug?: boolean
    categorySlug?: boolean
    sourceSlug?: boolean
    channelSlug?: boolean
    segmentSlug?: boolean
    percent?: boolean
    ctrPercent?: boolean
    value?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueStream"]>

  export type RevenueStreamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    industryTypeSlug?: boolean
    categorySlug?: boolean
    sourceSlug?: boolean
    channelSlug?: boolean
    segmentSlug?: boolean
    percent?: boolean
    ctrPercent?: boolean
    value?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueStream"]>

  export type RevenueStreamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    industryTypeSlug?: boolean
    categorySlug?: boolean
    sourceSlug?: boolean
    channelSlug?: boolean
    segmentSlug?: boolean
    percent?: boolean
    ctrPercent?: boolean
    value?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueStream"]>

  export type RevenueStreamSelectScalar = {
    id?: boolean
    year?: boolean
    industryTypeSlug?: boolean
    categorySlug?: boolean
    sourceSlug?: boolean
    channelSlug?: boolean
    segmentSlug?: boolean
    percent?: boolean
    ctrPercent?: boolean
    value?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RevenueStreamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "industryTypeSlug" | "categorySlug" | "sourceSlug" | "channelSlug" | "segmentSlug" | "percent" | "ctrPercent" | "value" | "companyId" | "companyJuristicId" | "createdAt" | "updatedAt", ExtArgs["result"]["revenueStream"]>
  export type RevenueStreamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type RevenueStreamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type RevenueStreamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    source?: boolean | SourceDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $RevenueStreamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueStream"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      source: Prisma.$SourcePayload<ExtArgs>
      channel: Prisma.$ChannelPayload<ExtArgs>
      segment: Prisma.$SegmentPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      industryTypeSlug: string
      categorySlug: string
      sourceSlug: string
      channelSlug: string
      segmentSlug: string
      percent: number
      ctrPercent: number
      value: number | null
      companyId: string
      companyJuristicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["revenueStream"]>
    composites: {}
  }

  type RevenueStreamGetPayload<S extends boolean | null | undefined | RevenueStreamDefaultArgs> = $Result.GetResult<Prisma.$RevenueStreamPayload, S>

  type RevenueStreamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RevenueStreamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RevenueStreamCountAggregateInputType | true
    }

  export interface RevenueStreamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueStream'], meta: { name: 'RevenueStream' } }
    /**
     * Find zero or one RevenueStream that matches the filter.
     * @param {RevenueStreamFindUniqueArgs} args - Arguments to find a RevenueStream
     * @example
     * // Get one RevenueStream
     * const revenueStream = await prisma.revenueStream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueStreamFindUniqueArgs>(args: SelectSubset<T, RevenueStreamFindUniqueArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RevenueStream that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RevenueStreamFindUniqueOrThrowArgs} args - Arguments to find a RevenueStream
     * @example
     * // Get one RevenueStream
     * const revenueStream = await prisma.revenueStream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueStreamFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueStreamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RevenueStream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamFindFirstArgs} args - Arguments to find a RevenueStream
     * @example
     * // Get one RevenueStream
     * const revenueStream = await prisma.revenueStream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueStreamFindFirstArgs>(args?: SelectSubset<T, RevenueStreamFindFirstArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RevenueStream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamFindFirstOrThrowArgs} args - Arguments to find a RevenueStream
     * @example
     * // Get one RevenueStream
     * const revenueStream = await prisma.revenueStream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueStreamFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueStreamFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RevenueStreams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueStreams
     * const revenueStreams = await prisma.revenueStream.findMany()
     * 
     * // Get first 10 RevenueStreams
     * const revenueStreams = await prisma.revenueStream.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueStreamWithIdOnly = await prisma.revenueStream.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueStreamFindManyArgs>(args?: SelectSubset<T, RevenueStreamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RevenueStream.
     * @param {RevenueStreamCreateArgs} args - Arguments to create a RevenueStream.
     * @example
     * // Create one RevenueStream
     * const RevenueStream = await prisma.revenueStream.create({
     *   data: {
     *     // ... data to create a RevenueStream
     *   }
     * })
     * 
     */
    create<T extends RevenueStreamCreateArgs>(args: SelectSubset<T, RevenueStreamCreateArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RevenueStreams.
     * @param {RevenueStreamCreateManyArgs} args - Arguments to create many RevenueStreams.
     * @example
     * // Create many RevenueStreams
     * const revenueStream = await prisma.revenueStream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueStreamCreateManyArgs>(args?: SelectSubset<T, RevenueStreamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueStreams and returns the data saved in the database.
     * @param {RevenueStreamCreateManyAndReturnArgs} args - Arguments to create many RevenueStreams.
     * @example
     * // Create many RevenueStreams
     * const revenueStream = await prisma.revenueStream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueStreams and only return the `id`
     * const revenueStreamWithIdOnly = await prisma.revenueStream.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueStreamCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueStreamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RevenueStream.
     * @param {RevenueStreamDeleteArgs} args - Arguments to delete one RevenueStream.
     * @example
     * // Delete one RevenueStream
     * const RevenueStream = await prisma.revenueStream.delete({
     *   where: {
     *     // ... filter to delete one RevenueStream
     *   }
     * })
     * 
     */
    delete<T extends RevenueStreamDeleteArgs>(args: SelectSubset<T, RevenueStreamDeleteArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RevenueStream.
     * @param {RevenueStreamUpdateArgs} args - Arguments to update one RevenueStream.
     * @example
     * // Update one RevenueStream
     * const revenueStream = await prisma.revenueStream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueStreamUpdateArgs>(args: SelectSubset<T, RevenueStreamUpdateArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RevenueStreams.
     * @param {RevenueStreamDeleteManyArgs} args - Arguments to filter RevenueStreams to delete.
     * @example
     * // Delete a few RevenueStreams
     * const { count } = await prisma.revenueStream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueStreamDeleteManyArgs>(args?: SelectSubset<T, RevenueStreamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueStreams
     * const revenueStream = await prisma.revenueStream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueStreamUpdateManyArgs>(args: SelectSubset<T, RevenueStreamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueStreams and returns the data updated in the database.
     * @param {RevenueStreamUpdateManyAndReturnArgs} args - Arguments to update many RevenueStreams.
     * @example
     * // Update many RevenueStreams
     * const revenueStream = await prisma.revenueStream.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RevenueStreams and only return the `id`
     * const revenueStreamWithIdOnly = await prisma.revenueStream.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RevenueStreamUpdateManyAndReturnArgs>(args: SelectSubset<T, RevenueStreamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RevenueStream.
     * @param {RevenueStreamUpsertArgs} args - Arguments to update or create a RevenueStream.
     * @example
     * // Update or create a RevenueStream
     * const revenueStream = await prisma.revenueStream.upsert({
     *   create: {
     *     // ... data to create a RevenueStream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueStream we want to update
     *   }
     * })
     */
    upsert<T extends RevenueStreamUpsertArgs>(args: SelectSubset<T, RevenueStreamUpsertArgs<ExtArgs>>): Prisma__RevenueStreamClient<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RevenueStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamCountArgs} args - Arguments to filter RevenueStreams to count.
     * @example
     * // Count the number of RevenueStreams
     * const count = await prisma.revenueStream.count({
     *   where: {
     *     // ... the filter for the RevenueStreams we want to count
     *   }
     * })
    **/
    count<T extends RevenueStreamCountArgs>(
      args?: Subset<T, RevenueStreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueStreamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueStreamAggregateArgs>(args: Subset<T, RevenueStreamAggregateArgs>): Prisma.PrismaPromise<GetRevenueStreamAggregateType<T>>

    /**
     * Group by RevenueStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueStreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueStreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueStreamGroupByArgs['orderBy'] }
        : { orderBy?: RevenueStreamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueStreamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueStreamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueStream model
   */
  readonly fields: RevenueStreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueStream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueStreamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    source<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    segment<T extends SegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SegmentDefaultArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueStream model
   */
  interface RevenueStreamFieldRefs {
    readonly id: FieldRef<"RevenueStream", 'String'>
    readonly year: FieldRef<"RevenueStream", 'Int'>
    readonly industryTypeSlug: FieldRef<"RevenueStream", 'String'>
    readonly categorySlug: FieldRef<"RevenueStream", 'String'>
    readonly sourceSlug: FieldRef<"RevenueStream", 'String'>
    readonly channelSlug: FieldRef<"RevenueStream", 'String'>
    readonly segmentSlug: FieldRef<"RevenueStream", 'String'>
    readonly percent: FieldRef<"RevenueStream", 'Float'>
    readonly ctrPercent: FieldRef<"RevenueStream", 'Float'>
    readonly value: FieldRef<"RevenueStream", 'Float'>
    readonly companyId: FieldRef<"RevenueStream", 'String'>
    readonly companyJuristicId: FieldRef<"RevenueStream", 'String'>
    readonly createdAt: FieldRef<"RevenueStream", 'DateTime'>
    readonly updatedAt: FieldRef<"RevenueStream", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevenueStream findUnique
   */
  export type RevenueStreamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter, which RevenueStream to fetch.
     */
    where: RevenueStreamWhereUniqueInput
  }

  /**
   * RevenueStream findUniqueOrThrow
   */
  export type RevenueStreamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter, which RevenueStream to fetch.
     */
    where: RevenueStreamWhereUniqueInput
  }

  /**
   * RevenueStream findFirst
   */
  export type RevenueStreamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter, which RevenueStream to fetch.
     */
    where?: RevenueStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueStreams to fetch.
     */
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueStreams.
     */
    cursor?: RevenueStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueStreams.
     */
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * RevenueStream findFirstOrThrow
   */
  export type RevenueStreamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter, which RevenueStream to fetch.
     */
    where?: RevenueStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueStreams to fetch.
     */
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueStreams.
     */
    cursor?: RevenueStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueStreams.
     */
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * RevenueStream findMany
   */
  export type RevenueStreamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter, which RevenueStreams to fetch.
     */
    where?: RevenueStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueStreams to fetch.
     */
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueStreams.
     */
    cursor?: RevenueStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueStreams.
     */
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * RevenueStream create
   */
  export type RevenueStreamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * The data needed to create a RevenueStream.
     */
    data: XOR<RevenueStreamCreateInput, RevenueStreamUncheckedCreateInput>
  }

  /**
   * RevenueStream createMany
   */
  export type RevenueStreamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueStreams.
     */
    data: RevenueStreamCreateManyInput | RevenueStreamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueStream createManyAndReturn
   */
  export type RevenueStreamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * The data used to create many RevenueStreams.
     */
    data: RevenueStreamCreateManyInput | RevenueStreamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RevenueStream update
   */
  export type RevenueStreamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * The data needed to update a RevenueStream.
     */
    data: XOR<RevenueStreamUpdateInput, RevenueStreamUncheckedUpdateInput>
    /**
     * Choose, which RevenueStream to update.
     */
    where: RevenueStreamWhereUniqueInput
  }

  /**
   * RevenueStream updateMany
   */
  export type RevenueStreamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueStreams.
     */
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyInput>
    /**
     * Filter which RevenueStreams to update
     */
    where?: RevenueStreamWhereInput
    /**
     * Limit how many RevenueStreams to update.
     */
    limit?: number
  }

  /**
   * RevenueStream updateManyAndReturn
   */
  export type RevenueStreamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * The data used to update RevenueStreams.
     */
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyInput>
    /**
     * Filter which RevenueStreams to update
     */
    where?: RevenueStreamWhereInput
    /**
     * Limit how many RevenueStreams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RevenueStream upsert
   */
  export type RevenueStreamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * The filter to search for the RevenueStream to update in case it exists.
     */
    where: RevenueStreamWhereUniqueInput
    /**
     * In case the RevenueStream found by the `where` argument doesn't exist, create a new RevenueStream with this data.
     */
    create: XOR<RevenueStreamCreateInput, RevenueStreamUncheckedCreateInput>
    /**
     * In case the RevenueStream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueStreamUpdateInput, RevenueStreamUncheckedUpdateInput>
  }

  /**
   * RevenueStream delete
   */
  export type RevenueStreamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    /**
     * Filter which RevenueStream to delete.
     */
    where: RevenueStreamWhereUniqueInput
  }

  /**
   * RevenueStream deleteMany
   */
  export type RevenueStreamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueStreams to delete
     */
    where?: RevenueStreamWhereInput
    /**
     * Limit how many RevenueStreams to delete.
     */
    limit?: number
  }

  /**
   * RevenueStream without action
   */
  export type RevenueStreamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    registerdCapital: number | null
    employeeCount: number | null
  }

  export type CompanySumAggregateOutputType = {
    registerdCapital: number | null
    employeeCount: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    juristicId: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    registerdCapital: number | null
    employeeCount: number | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    logo: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    juristicId: string | null
    nameTh: string | null
    nameEn: string | null
    description: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    registerdCapital: number | null
    employeeCount: number | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    logo: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    juristicId: number
    nameTh: number
    nameEn: number
    description: number
    image: number
    cover_image: number
    address: number
    subDistrict: number
    district: number
    province: number
    postalCode: number
    registerdCapital: number
    employeeCount: number
    phoneNumber: number
    email: number
    website: number
    logo: number
    userId: number
    createdAt: number
    updatedAt: number
    industries: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    registerdCapital?: true
    employeeCount?: true
  }

  export type CompanySumAggregateInputType = {
    registerdCapital?: true
    employeeCount?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    juristicId?: true
    nameTh?: true
    nameEn?: true
    description?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    registerdCapital?: true
    employeeCount?: true
    phoneNumber?: true
    email?: true
    website?: true
    logo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    juristicId?: true
    nameTh?: true
    nameEn?: true
    description?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    registerdCapital?: true
    employeeCount?: true
    phoneNumber?: true
    email?: true
    website?: true
    logo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    juristicId?: true
    nameTh?: true
    nameEn?: true
    description?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    registerdCapital?: true
    employeeCount?: true
    phoneNumber?: true
    email?: true
    website?: true
    logo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    industries?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    juristicId: string
    nameTh: string
    nameEn: string | null
    description: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    registerdCapital: number | null
    employeeCount: number | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    logo: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    industries: string[]
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    juristicId?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    registerdCapital?: boolean
    employeeCount?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industries?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    industriesRelated?: boolean | Company$industriesRelatedArgs<ExtArgs>
    companyRevenue?: boolean | Company$companyRevenueArgs<ExtArgs>
    RevenueStream?: boolean | Company$RevenueStreamArgs<ExtArgs>
    Portfolio?: boolean | Company$PortfolioArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    juristicId?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    registerdCapital?: boolean
    employeeCount?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industries?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    juristicId?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    registerdCapital?: boolean
    employeeCount?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industries?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    juristicId?: boolean
    nameTh?: boolean
    nameEn?: boolean
    description?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    registerdCapital?: boolean
    employeeCount?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industries?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "juristicId" | "nameTh" | "nameEn" | "description" | "image" | "cover_image" | "address" | "subDistrict" | "district" | "province" | "postalCode" | "registerdCapital" | "employeeCount" | "phoneNumber" | "email" | "website" | "logo" | "userId" | "createdAt" | "updatedAt" | "industries", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    industriesRelated?: boolean | Company$industriesRelatedArgs<ExtArgs>
    companyRevenue?: boolean | Company$companyRevenueArgs<ExtArgs>
    RevenueStream?: boolean | Company$RevenueStreamArgs<ExtArgs>
    Portfolio?: boolean | Company$PortfolioArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      industriesRelated: Prisma.$CompanyIndustryPayload<ExtArgs>[]
      companyRevenue: Prisma.$CompanyRevenuePayload<ExtArgs>[]
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
      Portfolio: Prisma.$PortfolioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      juristicId: string
      nameTh: string
      nameEn: string | null
      description: string | null
      image: string | null
      cover_image: string | null
      address: string | null
      subDistrict: string | null
      district: string | null
      province: string | null
      postalCode: string | null
      registerdCapital: number | null
      employeeCount: number | null
      phoneNumber: string | null
      email: string | null
      website: string | null
      logo: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      industries: string[]
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industriesRelated<T extends Company$industriesRelatedArgs<ExtArgs> = {}>(args?: Subset<T, Company$industriesRelatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyRevenue<T extends Company$companyRevenueArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyRevenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RevenueStream<T extends Company$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Company$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Portfolio<T extends Company$PortfolioArgs<ExtArgs> = {}>(args?: Subset<T, Company$PortfolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly juristicId: FieldRef<"Company", 'String'>
    readonly nameTh: FieldRef<"Company", 'String'>
    readonly nameEn: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly image: FieldRef<"Company", 'String'>
    readonly cover_image: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly subDistrict: FieldRef<"Company", 'String'>
    readonly district: FieldRef<"Company", 'String'>
    readonly province: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly registerdCapital: FieldRef<"Company", 'Float'>
    readonly employeeCount: FieldRef<"Company", 'Int'>
    readonly phoneNumber: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly userId: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly industries: FieldRef<"Company", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.industriesRelated
   */
  export type Company$industriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    where?: CompanyIndustryWhereInput
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    cursor?: CompanyIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyIndustryScalarFieldEnum | CompanyIndustryScalarFieldEnum[]
  }

  /**
   * Company.companyRevenue
   */
  export type Company$companyRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRevenue
     */
    select?: CompanyRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRevenue
     */
    omit?: CompanyRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRevenueInclude<ExtArgs> | null
    where?: CompanyRevenueWhereInput
    orderBy?: CompanyRevenueOrderByWithRelationInput | CompanyRevenueOrderByWithRelationInput[]
    cursor?: CompanyRevenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyRevenueScalarFieldEnum | CompanyRevenueScalarFieldEnum[]
  }

  /**
   * Company.RevenueStream
   */
  export type Company$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Company.Portfolio
   */
  export type Company$PortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyIndustry
   */

  export type AggregateCompanyIndustry = {
    _count: CompanyIndustryCountAggregateOutputType | null
    _min: CompanyIndustryMinAggregateOutputType | null
    _max: CompanyIndustryMaxAggregateOutputType | null
  }

  export type CompanyIndustryMinAggregateOutputType = {
    companyId: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyIndustryMaxAggregateOutputType = {
    companyId: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyIndustryCountAggregateOutputType = {
    companyId: number
    industrySlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyIndustryMinAggregateInputType = {
    companyId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyIndustryMaxAggregateInputType = {
    companyId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyIndustryCountAggregateInputType = {
    companyId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyIndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyIndustry to aggregate.
     */
    where?: CompanyIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyIndustries to fetch.
     */
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyIndustries
    **/
    _count?: true | CompanyIndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyIndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyIndustryMaxAggregateInputType
  }

  export type GetCompanyIndustryAggregateType<T extends CompanyIndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyIndustry[P]>
      : GetScalarType<T[P], AggregateCompanyIndustry[P]>
  }




  export type CompanyIndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyIndustryWhereInput
    orderBy?: CompanyIndustryOrderByWithAggregationInput | CompanyIndustryOrderByWithAggregationInput[]
    by: CompanyIndustryScalarFieldEnum[] | CompanyIndustryScalarFieldEnum
    having?: CompanyIndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyIndustryCountAggregateInputType | true
    _min?: CompanyIndustryMinAggregateInputType
    _max?: CompanyIndustryMaxAggregateInputType
  }

  export type CompanyIndustryGroupByOutputType = {
    companyId: string
    industrySlug: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyIndustryCountAggregateOutputType | null
    _min: CompanyIndustryMinAggregateOutputType | null
    _max: CompanyIndustryMaxAggregateOutputType | null
  }

  type GetCompanyIndustryGroupByPayload<T extends CompanyIndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyIndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyIndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyIndustryGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyIndustryGroupByOutputType[P]>
        }
      >
    >


  export type CompanyIndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyIndustry"]>

  export type CompanyIndustrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyIndustry"]>

  export type CompanyIndustrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyIndustry"]>

  export type CompanyIndustrySelectScalar = {
    companyId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyIndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"companyId" | "industrySlug" | "createdAt" | "updatedAt", ExtArgs["result"]["companyIndustry"]>
  export type CompanyIndustryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type CompanyIndustryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type CompanyIndustryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $CompanyIndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyIndustry"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      industry: Prisma.$IndustryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      companyId: string
      industrySlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyIndustry"]>
    composites: {}
  }

  type CompanyIndustryGetPayload<S extends boolean | null | undefined | CompanyIndustryDefaultArgs> = $Result.GetResult<Prisma.$CompanyIndustryPayload, S>

  type CompanyIndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyIndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyIndustryCountAggregateInputType | true
    }

  export interface CompanyIndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyIndustry'], meta: { name: 'CompanyIndustry' } }
    /**
     * Find zero or one CompanyIndustry that matches the filter.
     * @param {CompanyIndustryFindUniqueArgs} args - Arguments to find a CompanyIndustry
     * @example
     * // Get one CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyIndustryFindUniqueArgs>(args: SelectSubset<T, CompanyIndustryFindUniqueArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyIndustry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyIndustryFindUniqueOrThrowArgs} args - Arguments to find a CompanyIndustry
     * @example
     * // Get one CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyIndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyIndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyIndustry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryFindFirstArgs} args - Arguments to find a CompanyIndustry
     * @example
     * // Get one CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyIndustryFindFirstArgs>(args?: SelectSubset<T, CompanyIndustryFindFirstArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyIndustry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryFindFirstOrThrowArgs} args - Arguments to find a CompanyIndustry
     * @example
     * // Get one CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyIndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyIndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyIndustries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyIndustries
     * const companyIndustries = await prisma.companyIndustry.findMany()
     * 
     * // Get first 10 CompanyIndustries
     * const companyIndustries = await prisma.companyIndustry.findMany({ take: 10 })
     * 
     * // Only select the `companyId`
     * const companyIndustryWithCompanyIdOnly = await prisma.companyIndustry.findMany({ select: { companyId: true } })
     * 
     */
    findMany<T extends CompanyIndustryFindManyArgs>(args?: SelectSubset<T, CompanyIndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyIndustry.
     * @param {CompanyIndustryCreateArgs} args - Arguments to create a CompanyIndustry.
     * @example
     * // Create one CompanyIndustry
     * const CompanyIndustry = await prisma.companyIndustry.create({
     *   data: {
     *     // ... data to create a CompanyIndustry
     *   }
     * })
     * 
     */
    create<T extends CompanyIndustryCreateArgs>(args: SelectSubset<T, CompanyIndustryCreateArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyIndustries.
     * @param {CompanyIndustryCreateManyArgs} args - Arguments to create many CompanyIndustries.
     * @example
     * // Create many CompanyIndustries
     * const companyIndustry = await prisma.companyIndustry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyIndustryCreateManyArgs>(args?: SelectSubset<T, CompanyIndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyIndustries and returns the data saved in the database.
     * @param {CompanyIndustryCreateManyAndReturnArgs} args - Arguments to create many CompanyIndustries.
     * @example
     * // Create many CompanyIndustries
     * const companyIndustry = await prisma.companyIndustry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyIndustries and only return the `companyId`
     * const companyIndustryWithCompanyIdOnly = await prisma.companyIndustry.createManyAndReturn({
     *   select: { companyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyIndustryCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyIndustryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyIndustry.
     * @param {CompanyIndustryDeleteArgs} args - Arguments to delete one CompanyIndustry.
     * @example
     * // Delete one CompanyIndustry
     * const CompanyIndustry = await prisma.companyIndustry.delete({
     *   where: {
     *     // ... filter to delete one CompanyIndustry
     *   }
     * })
     * 
     */
    delete<T extends CompanyIndustryDeleteArgs>(args: SelectSubset<T, CompanyIndustryDeleteArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyIndustry.
     * @param {CompanyIndustryUpdateArgs} args - Arguments to update one CompanyIndustry.
     * @example
     * // Update one CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyIndustryUpdateArgs>(args: SelectSubset<T, CompanyIndustryUpdateArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyIndustries.
     * @param {CompanyIndustryDeleteManyArgs} args - Arguments to filter CompanyIndustries to delete.
     * @example
     * // Delete a few CompanyIndustries
     * const { count } = await prisma.companyIndustry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyIndustryDeleteManyArgs>(args?: SelectSubset<T, CompanyIndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyIndustries
     * const companyIndustry = await prisma.companyIndustry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyIndustryUpdateManyArgs>(args: SelectSubset<T, CompanyIndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyIndustries and returns the data updated in the database.
     * @param {CompanyIndustryUpdateManyAndReturnArgs} args - Arguments to update many CompanyIndustries.
     * @example
     * // Update many CompanyIndustries
     * const companyIndustry = await prisma.companyIndustry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyIndustries and only return the `companyId`
     * const companyIndustryWithCompanyIdOnly = await prisma.companyIndustry.updateManyAndReturn({
     *   select: { companyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyIndustryUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyIndustryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyIndustry.
     * @param {CompanyIndustryUpsertArgs} args - Arguments to update or create a CompanyIndustry.
     * @example
     * // Update or create a CompanyIndustry
     * const companyIndustry = await prisma.companyIndustry.upsert({
     *   create: {
     *     // ... data to create a CompanyIndustry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyIndustry we want to update
     *   }
     * })
     */
    upsert<T extends CompanyIndustryUpsertArgs>(args: SelectSubset<T, CompanyIndustryUpsertArgs<ExtArgs>>): Prisma__CompanyIndustryClient<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryCountArgs} args - Arguments to filter CompanyIndustries to count.
     * @example
     * // Count the number of CompanyIndustries
     * const count = await prisma.companyIndustry.count({
     *   where: {
     *     // ... the filter for the CompanyIndustries we want to count
     *   }
     * })
    **/
    count<T extends CompanyIndustryCountArgs>(
      args?: Subset<T, CompanyIndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyIndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyIndustryAggregateArgs>(args: Subset<T, CompanyIndustryAggregateArgs>): Prisma.PrismaPromise<GetCompanyIndustryAggregateType<T>>

    /**
     * Group by CompanyIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyIndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyIndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyIndustryGroupByArgs['orderBy'] }
        : { orderBy?: CompanyIndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyIndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyIndustry model
   */
  readonly fields: CompanyIndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyIndustry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyIndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyIndustry model
   */
  interface CompanyIndustryFieldRefs {
    readonly companyId: FieldRef<"CompanyIndustry", 'String'>
    readonly industrySlug: FieldRef<"CompanyIndustry", 'String'>
    readonly createdAt: FieldRef<"CompanyIndustry", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyIndustry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyIndustry findUnique
   */
  export type CompanyIndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter, which CompanyIndustry to fetch.
     */
    where: CompanyIndustryWhereUniqueInput
  }

  /**
   * CompanyIndustry findUniqueOrThrow
   */
  export type CompanyIndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter, which CompanyIndustry to fetch.
     */
    where: CompanyIndustryWhereUniqueInput
  }

  /**
   * CompanyIndustry findFirst
   */
  export type CompanyIndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter, which CompanyIndustry to fetch.
     */
    where?: CompanyIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyIndustries to fetch.
     */
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyIndustries.
     */
    cursor?: CompanyIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyIndustries.
     */
    distinct?: CompanyIndustryScalarFieldEnum | CompanyIndustryScalarFieldEnum[]
  }

  /**
   * CompanyIndustry findFirstOrThrow
   */
  export type CompanyIndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter, which CompanyIndustry to fetch.
     */
    where?: CompanyIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyIndustries to fetch.
     */
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyIndustries.
     */
    cursor?: CompanyIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyIndustries.
     */
    distinct?: CompanyIndustryScalarFieldEnum | CompanyIndustryScalarFieldEnum[]
  }

  /**
   * CompanyIndustry findMany
   */
  export type CompanyIndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter, which CompanyIndustries to fetch.
     */
    where?: CompanyIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyIndustries to fetch.
     */
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyIndustries.
     */
    cursor?: CompanyIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyIndustries.
     */
    skip?: number
    distinct?: CompanyIndustryScalarFieldEnum | CompanyIndustryScalarFieldEnum[]
  }

  /**
   * CompanyIndustry create
   */
  export type CompanyIndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyIndustry.
     */
    data: XOR<CompanyIndustryCreateInput, CompanyIndustryUncheckedCreateInput>
  }

  /**
   * CompanyIndustry createMany
   */
  export type CompanyIndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyIndustries.
     */
    data: CompanyIndustryCreateManyInput | CompanyIndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyIndustry createManyAndReturn
   */
  export type CompanyIndustryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyIndustries.
     */
    data: CompanyIndustryCreateManyInput | CompanyIndustryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyIndustry update
   */
  export type CompanyIndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyIndustry.
     */
    data: XOR<CompanyIndustryUpdateInput, CompanyIndustryUncheckedUpdateInput>
    /**
     * Choose, which CompanyIndustry to update.
     */
    where: CompanyIndustryWhereUniqueInput
  }

  /**
   * CompanyIndustry updateMany
   */
  export type CompanyIndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyIndustries.
     */
    data: XOR<CompanyIndustryUpdateManyMutationInput, CompanyIndustryUncheckedUpdateManyInput>
    /**
     * Filter which CompanyIndustries to update
     */
    where?: CompanyIndustryWhereInput
    /**
     * Limit how many CompanyIndustries to update.
     */
    limit?: number
  }

  /**
   * CompanyIndustry updateManyAndReturn
   */
  export type CompanyIndustryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * The data used to update CompanyIndustries.
     */
    data: XOR<CompanyIndustryUpdateManyMutationInput, CompanyIndustryUncheckedUpdateManyInput>
    /**
     * Filter which CompanyIndustries to update
     */
    where?: CompanyIndustryWhereInput
    /**
     * Limit how many CompanyIndustries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyIndustry upsert
   */
  export type CompanyIndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyIndustry to update in case it exists.
     */
    where: CompanyIndustryWhereUniqueInput
    /**
     * In case the CompanyIndustry found by the `where` argument doesn't exist, create a new CompanyIndustry with this data.
     */
    create: XOR<CompanyIndustryCreateInput, CompanyIndustryUncheckedCreateInput>
    /**
     * In case the CompanyIndustry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyIndustryUpdateInput, CompanyIndustryUncheckedUpdateInput>
  }

  /**
   * CompanyIndustry delete
   */
  export type CompanyIndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    /**
     * Filter which CompanyIndustry to delete.
     */
    where: CompanyIndustryWhereUniqueInput
  }

  /**
   * CompanyIndustry deleteMany
   */
  export type CompanyIndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyIndustries to delete
     */
    where?: CompanyIndustryWhereInput
    /**
     * Limit how many CompanyIndustries to delete.
     */
    limit?: number
  }

  /**
   * CompanyIndustry without action
   */
  export type CompanyIndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
  }


  /**
   * Model Freelance
   */

  export type AggregateFreelance = {
    _count: FreelanceCountAggregateOutputType | null
    _min: FreelanceMinAggregateOutputType | null
    _max: FreelanceMaxAggregateOutputType | null
  }

  export type FreelanceMinAggregateOutputType = {
    id: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    firstNameEn: string | null
    lastNameEn: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    phoneNumber: string | null
    email: string | null
    juristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type FreelanceMaxAggregateOutputType = {
    id: string | null
    firstNameTh: string | null
    lastNameTh: string | null
    firstNameEn: string | null
    lastNameEn: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    phoneNumber: string | null
    email: string | null
    juristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type FreelanceCountAggregateOutputType = {
    id: number
    firstNameTh: number
    lastNameTh: number
    firstNameEn: number
    lastNameEn: number
    image: number
    cover_image: number
    address: number
    subDistrict: number
    district: number
    province: number
    postalCode: number
    phoneNumber: number
    email: number
    juristicId: number
    industryTypes: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type FreelanceMinAggregateInputType = {
    id?: true
    firstNameTh?: true
    lastNameTh?: true
    firstNameEn?: true
    lastNameEn?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    phoneNumber?: true
    email?: true
    juristicId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type FreelanceMaxAggregateInputType = {
    id?: true
    firstNameTh?: true
    lastNameTh?: true
    firstNameEn?: true
    lastNameEn?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    phoneNumber?: true
    email?: true
    juristicId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type FreelanceCountAggregateInputType = {
    id?: true
    firstNameTh?: true
    lastNameTh?: true
    firstNameEn?: true
    lastNameEn?: true
    image?: true
    cover_image?: true
    address?: true
    subDistrict?: true
    district?: true
    province?: true
    postalCode?: true
    phoneNumber?: true
    email?: true
    juristicId?: true
    industryTypes?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type FreelanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Freelance to aggregate.
     */
    where?: FreelanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Freelances to fetch.
     */
    orderBy?: FreelanceOrderByWithRelationInput | FreelanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Freelances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Freelances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Freelances
    **/
    _count?: true | FreelanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelanceMaxAggregateInputType
  }

  export type GetFreelanceAggregateType<T extends FreelanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelance[P]>
      : GetScalarType<T[P], AggregateFreelance[P]>
  }




  export type FreelanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceWhereInput
    orderBy?: FreelanceOrderByWithAggregationInput | FreelanceOrderByWithAggregationInput[]
    by: FreelanceScalarFieldEnum[] | FreelanceScalarFieldEnum
    having?: FreelanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelanceCountAggregateInputType | true
    _min?: FreelanceMinAggregateInputType
    _max?: FreelanceMaxAggregateInputType
  }

  export type FreelanceGroupByOutputType = {
    id: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn: string | null
    lastNameEn: string | null
    image: string | null
    cover_image: string | null
    address: string | null
    subDistrict: string | null
    district: string | null
    province: string | null
    postalCode: string | null
    phoneNumber: string | null
    email: string | null
    juristicId: string | null
    industryTypes: string[]
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: FreelanceCountAggregateOutputType | null
    _min: FreelanceMinAggregateOutputType | null
    _max: FreelanceMaxAggregateOutputType | null
  }

  type GetFreelanceGroupByPayload<T extends FreelanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelanceGroupByOutputType[P]>
            : GetScalarType<T[P], FreelanceGroupByOutputType[P]>
        }
      >
    >


  export type FreelanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    firstNameEn?: boolean
    lastNameEn?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    email?: boolean
    juristicId?: boolean
    industryTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    industriesRelated?: boolean | Freelance$industriesRelatedArgs<ExtArgs>
    skills?: boolean | Freelance$skillsArgs<ExtArgs>
    freelanceRevenue?: boolean | Freelance$freelanceRevenueArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Portfolio?: boolean | Freelance$PortfolioArgs<ExtArgs>
    _count?: boolean | FreelanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelance"]>

  export type FreelanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    firstNameEn?: boolean
    lastNameEn?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    email?: boolean
    juristicId?: boolean
    industryTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelance"]>

  export type FreelanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    firstNameEn?: boolean
    lastNameEn?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    email?: boolean
    juristicId?: boolean
    industryTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelance"]>

  export type FreelanceSelectScalar = {
    id?: boolean
    firstNameTh?: boolean
    lastNameTh?: boolean
    firstNameEn?: boolean
    lastNameEn?: boolean
    image?: boolean
    cover_image?: boolean
    address?: boolean
    subDistrict?: boolean
    district?: boolean
    province?: boolean
    postalCode?: boolean
    phoneNumber?: boolean
    email?: boolean
    juristicId?: boolean
    industryTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type FreelanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstNameTh" | "lastNameTh" | "firstNameEn" | "lastNameEn" | "image" | "cover_image" | "address" | "subDistrict" | "district" | "province" | "postalCode" | "phoneNumber" | "email" | "juristicId" | "industryTypes" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["freelance"]>
  export type FreelanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industriesRelated?: boolean | Freelance$industriesRelatedArgs<ExtArgs>
    skills?: boolean | Freelance$skillsArgs<ExtArgs>
    freelanceRevenue?: boolean | Freelance$freelanceRevenueArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Portfolio?: boolean | Freelance$PortfolioArgs<ExtArgs>
    _count?: boolean | FreelanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FreelanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FreelanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FreelancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Freelance"
    objects: {
      industriesRelated: Prisma.$FreelanceIndustryPayload<ExtArgs>[]
      skills: Prisma.$SkillPayload<ExtArgs>[]
      freelanceRevenue: Prisma.$FreelanceRevenuePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      Portfolio: Prisma.$PortfolioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstNameTh: string
      lastNameTh: string
      firstNameEn: string | null
      lastNameEn: string | null
      image: string | null
      cover_image: string | null
      address: string | null
      subDistrict: string | null
      district: string | null
      province: string | null
      postalCode: string | null
      phoneNumber: string | null
      email: string | null
      juristicId: string | null
      industryTypes: string[]
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["freelance"]>
    composites: {}
  }

  type FreelanceGetPayload<S extends boolean | null | undefined | FreelanceDefaultArgs> = $Result.GetResult<Prisma.$FreelancePayload, S>

  type FreelanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelanceCountAggregateInputType | true
    }

  export interface FreelanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Freelance'], meta: { name: 'Freelance' } }
    /**
     * Find zero or one Freelance that matches the filter.
     * @param {FreelanceFindUniqueArgs} args - Arguments to find a Freelance
     * @example
     * // Get one Freelance
     * const freelance = await prisma.freelance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelanceFindUniqueArgs>(args: SelectSubset<T, FreelanceFindUniqueArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Freelance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelanceFindUniqueOrThrowArgs} args - Arguments to find a Freelance
     * @example
     * // Get one Freelance
     * const freelance = await prisma.freelance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Freelance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceFindFirstArgs} args - Arguments to find a Freelance
     * @example
     * // Get one Freelance
     * const freelance = await prisma.freelance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelanceFindFirstArgs>(args?: SelectSubset<T, FreelanceFindFirstArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Freelance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceFindFirstOrThrowArgs} args - Arguments to find a Freelance
     * @example
     * // Get one Freelance
     * const freelance = await prisma.freelance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Freelances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Freelances
     * const freelances = await prisma.freelance.findMany()
     * 
     * // Get first 10 Freelances
     * const freelances = await prisma.freelance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelanceWithIdOnly = await prisma.freelance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelanceFindManyArgs>(args?: SelectSubset<T, FreelanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Freelance.
     * @param {FreelanceCreateArgs} args - Arguments to create a Freelance.
     * @example
     * // Create one Freelance
     * const Freelance = await prisma.freelance.create({
     *   data: {
     *     // ... data to create a Freelance
     *   }
     * })
     * 
     */
    create<T extends FreelanceCreateArgs>(args: SelectSubset<T, FreelanceCreateArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Freelances.
     * @param {FreelanceCreateManyArgs} args - Arguments to create many Freelances.
     * @example
     * // Create many Freelances
     * const freelance = await prisma.freelance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelanceCreateManyArgs>(args?: SelectSubset<T, FreelanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Freelances and returns the data saved in the database.
     * @param {FreelanceCreateManyAndReturnArgs} args - Arguments to create many Freelances.
     * @example
     * // Create many Freelances
     * const freelance = await prisma.freelance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Freelances and only return the `id`
     * const freelanceWithIdOnly = await prisma.freelance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelanceCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Freelance.
     * @param {FreelanceDeleteArgs} args - Arguments to delete one Freelance.
     * @example
     * // Delete one Freelance
     * const Freelance = await prisma.freelance.delete({
     *   where: {
     *     // ... filter to delete one Freelance
     *   }
     * })
     * 
     */
    delete<T extends FreelanceDeleteArgs>(args: SelectSubset<T, FreelanceDeleteArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Freelance.
     * @param {FreelanceUpdateArgs} args - Arguments to update one Freelance.
     * @example
     * // Update one Freelance
     * const freelance = await prisma.freelance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelanceUpdateArgs>(args: SelectSubset<T, FreelanceUpdateArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Freelances.
     * @param {FreelanceDeleteManyArgs} args - Arguments to filter Freelances to delete.
     * @example
     * // Delete a few Freelances
     * const { count } = await prisma.freelance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelanceDeleteManyArgs>(args?: SelectSubset<T, FreelanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Freelances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Freelances
     * const freelance = await prisma.freelance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelanceUpdateManyArgs>(args: SelectSubset<T, FreelanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Freelances and returns the data updated in the database.
     * @param {FreelanceUpdateManyAndReturnArgs} args - Arguments to update many Freelances.
     * @example
     * // Update many Freelances
     * const freelance = await prisma.freelance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Freelances and only return the `id`
     * const freelanceWithIdOnly = await prisma.freelance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelanceUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Freelance.
     * @param {FreelanceUpsertArgs} args - Arguments to update or create a Freelance.
     * @example
     * // Update or create a Freelance
     * const freelance = await prisma.freelance.upsert({
     *   create: {
     *     // ... data to create a Freelance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Freelance we want to update
     *   }
     * })
     */
    upsert<T extends FreelanceUpsertArgs>(args: SelectSubset<T, FreelanceUpsertArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Freelances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceCountArgs} args - Arguments to filter Freelances to count.
     * @example
     * // Count the number of Freelances
     * const count = await prisma.freelance.count({
     *   where: {
     *     // ... the filter for the Freelances we want to count
     *   }
     * })
    **/
    count<T extends FreelanceCountArgs>(
      args?: Subset<T, FreelanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Freelance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelanceAggregateArgs>(args: Subset<T, FreelanceAggregateArgs>): Prisma.PrismaPromise<GetFreelanceAggregateType<T>>

    /**
     * Group by Freelance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelanceGroupByArgs['orderBy'] }
        : { orderBy?: FreelanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Freelance model
   */
  readonly fields: FreelanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Freelance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industriesRelated<T extends Freelance$industriesRelatedArgs<ExtArgs> = {}>(args?: Subset<T, Freelance$industriesRelatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Freelance$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Freelance$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelanceRevenue<T extends Freelance$freelanceRevenueArgs<ExtArgs> = {}>(args?: Subset<T, Freelance$freelanceRevenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Portfolio<T extends Freelance$PortfolioArgs<ExtArgs> = {}>(args?: Subset<T, Freelance$PortfolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Freelance model
   */
  interface FreelanceFieldRefs {
    readonly id: FieldRef<"Freelance", 'String'>
    readonly firstNameTh: FieldRef<"Freelance", 'String'>
    readonly lastNameTh: FieldRef<"Freelance", 'String'>
    readonly firstNameEn: FieldRef<"Freelance", 'String'>
    readonly lastNameEn: FieldRef<"Freelance", 'String'>
    readonly image: FieldRef<"Freelance", 'String'>
    readonly cover_image: FieldRef<"Freelance", 'String'>
    readonly address: FieldRef<"Freelance", 'String'>
    readonly subDistrict: FieldRef<"Freelance", 'String'>
    readonly district: FieldRef<"Freelance", 'String'>
    readonly province: FieldRef<"Freelance", 'String'>
    readonly postalCode: FieldRef<"Freelance", 'String'>
    readonly phoneNumber: FieldRef<"Freelance", 'String'>
    readonly email: FieldRef<"Freelance", 'String'>
    readonly juristicId: FieldRef<"Freelance", 'String'>
    readonly industryTypes: FieldRef<"Freelance", 'String[]'>
    readonly createdAt: FieldRef<"Freelance", 'DateTime'>
    readonly updatedAt: FieldRef<"Freelance", 'DateTime'>
    readonly userId: FieldRef<"Freelance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Freelance findUnique
   */
  export type FreelanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter, which Freelance to fetch.
     */
    where: FreelanceWhereUniqueInput
  }

  /**
   * Freelance findUniqueOrThrow
   */
  export type FreelanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter, which Freelance to fetch.
     */
    where: FreelanceWhereUniqueInput
  }

  /**
   * Freelance findFirst
   */
  export type FreelanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter, which Freelance to fetch.
     */
    where?: FreelanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Freelances to fetch.
     */
    orderBy?: FreelanceOrderByWithRelationInput | FreelanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Freelances.
     */
    cursor?: FreelanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Freelances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Freelances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Freelances.
     */
    distinct?: FreelanceScalarFieldEnum | FreelanceScalarFieldEnum[]
  }

  /**
   * Freelance findFirstOrThrow
   */
  export type FreelanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter, which Freelance to fetch.
     */
    where?: FreelanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Freelances to fetch.
     */
    orderBy?: FreelanceOrderByWithRelationInput | FreelanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Freelances.
     */
    cursor?: FreelanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Freelances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Freelances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Freelances.
     */
    distinct?: FreelanceScalarFieldEnum | FreelanceScalarFieldEnum[]
  }

  /**
   * Freelance findMany
   */
  export type FreelanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter, which Freelances to fetch.
     */
    where?: FreelanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Freelances to fetch.
     */
    orderBy?: FreelanceOrderByWithRelationInput | FreelanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Freelances.
     */
    cursor?: FreelanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Freelances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Freelances.
     */
    skip?: number
    distinct?: FreelanceScalarFieldEnum | FreelanceScalarFieldEnum[]
  }

  /**
   * Freelance create
   */
  export type FreelanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Freelance.
     */
    data: XOR<FreelanceCreateInput, FreelanceUncheckedCreateInput>
  }

  /**
   * Freelance createMany
   */
  export type FreelanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Freelances.
     */
    data: FreelanceCreateManyInput | FreelanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Freelance createManyAndReturn
   */
  export type FreelanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * The data used to create many Freelances.
     */
    data: FreelanceCreateManyInput | FreelanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Freelance update
   */
  export type FreelanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Freelance.
     */
    data: XOR<FreelanceUpdateInput, FreelanceUncheckedUpdateInput>
    /**
     * Choose, which Freelance to update.
     */
    where: FreelanceWhereUniqueInput
  }

  /**
   * Freelance updateMany
   */
  export type FreelanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Freelances.
     */
    data: XOR<FreelanceUpdateManyMutationInput, FreelanceUncheckedUpdateManyInput>
    /**
     * Filter which Freelances to update
     */
    where?: FreelanceWhereInput
    /**
     * Limit how many Freelances to update.
     */
    limit?: number
  }

  /**
   * Freelance updateManyAndReturn
   */
  export type FreelanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * The data used to update Freelances.
     */
    data: XOR<FreelanceUpdateManyMutationInput, FreelanceUncheckedUpdateManyInput>
    /**
     * Filter which Freelances to update
     */
    where?: FreelanceWhereInput
    /**
     * Limit how many Freelances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Freelance upsert
   */
  export type FreelanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Freelance to update in case it exists.
     */
    where: FreelanceWhereUniqueInput
    /**
     * In case the Freelance found by the `where` argument doesn't exist, create a new Freelance with this data.
     */
    create: XOR<FreelanceCreateInput, FreelanceUncheckedCreateInput>
    /**
     * In case the Freelance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelanceUpdateInput, FreelanceUncheckedUpdateInput>
  }

  /**
   * Freelance delete
   */
  export type FreelanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    /**
     * Filter which Freelance to delete.
     */
    where: FreelanceWhereUniqueInput
  }

  /**
   * Freelance deleteMany
   */
  export type FreelanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Freelances to delete
     */
    where?: FreelanceWhereInput
    /**
     * Limit how many Freelances to delete.
     */
    limit?: number
  }

  /**
   * Freelance.industriesRelated
   */
  export type Freelance$industriesRelatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    where?: FreelanceIndustryWhereInput
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    cursor?: FreelanceIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceIndustryScalarFieldEnum | FreelanceIndustryScalarFieldEnum[]
  }

  /**
   * Freelance.skills
   */
  export type Freelance$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Freelance.freelanceRevenue
   */
  export type Freelance$freelanceRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceRevenue
     */
    select?: FreelanceRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceRevenue
     */
    omit?: FreelanceRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceRevenueInclude<ExtArgs> | null
    where?: FreelanceRevenueWhereInput
    orderBy?: FreelanceRevenueOrderByWithRelationInput | FreelanceRevenueOrderByWithRelationInput[]
    cursor?: FreelanceRevenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceRevenueScalarFieldEnum | FreelanceRevenueScalarFieldEnum[]
  }

  /**
   * Freelance.Portfolio
   */
  export type Freelance$PortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Freelance without action
   */
  export type FreelanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
  }


  /**
   * Model FreelanceIndustry
   */

  export type AggregateFreelanceIndustry = {
    _count: FreelanceIndustryCountAggregateOutputType | null
    _min: FreelanceIndustryMinAggregateOutputType | null
    _max: FreelanceIndustryMaxAggregateOutputType | null
  }

  export type FreelanceIndustryMinAggregateOutputType = {
    freelanceId: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceIndustryMaxAggregateOutputType = {
    freelanceId: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceIndustryCountAggregateOutputType = {
    freelanceId: number
    industrySlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelanceIndustryMinAggregateInputType = {
    freelanceId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceIndustryMaxAggregateInputType = {
    freelanceId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceIndustryCountAggregateInputType = {
    freelanceId?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelanceIndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceIndustry to aggregate.
     */
    where?: FreelanceIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceIndustries to fetch.
     */
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelanceIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelanceIndustries
    **/
    _count?: true | FreelanceIndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelanceIndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelanceIndustryMaxAggregateInputType
  }

  export type GetFreelanceIndustryAggregateType<T extends FreelanceIndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelanceIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelanceIndustry[P]>
      : GetScalarType<T[P], AggregateFreelanceIndustry[P]>
  }




  export type FreelanceIndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceIndustryWhereInput
    orderBy?: FreelanceIndustryOrderByWithAggregationInput | FreelanceIndustryOrderByWithAggregationInput[]
    by: FreelanceIndustryScalarFieldEnum[] | FreelanceIndustryScalarFieldEnum
    having?: FreelanceIndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelanceIndustryCountAggregateInputType | true
    _min?: FreelanceIndustryMinAggregateInputType
    _max?: FreelanceIndustryMaxAggregateInputType
  }

  export type FreelanceIndustryGroupByOutputType = {
    freelanceId: string
    industrySlug: string
    createdAt: Date
    updatedAt: Date
    _count: FreelanceIndustryCountAggregateOutputType | null
    _min: FreelanceIndustryMinAggregateOutputType | null
    _max: FreelanceIndustryMaxAggregateOutputType | null
  }

  type GetFreelanceIndustryGroupByPayload<T extends FreelanceIndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelanceIndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelanceIndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelanceIndustryGroupByOutputType[P]>
            : GetScalarType<T[P], FreelanceIndustryGroupByOutputType[P]>
        }
      >
    >


  export type FreelanceIndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    freelanceId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceIndustry"]>

  export type FreelanceIndustrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    freelanceId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceIndustry"]>

  export type FreelanceIndustrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    freelanceId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceIndustry"]>

  export type FreelanceIndustrySelectScalar = {
    freelanceId?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelanceIndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"freelanceId" | "industrySlug" | "createdAt" | "updatedAt", ExtArgs["result"]["freelanceIndustry"]>
  export type FreelanceIndustryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type FreelanceIndustryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type FreelanceIndustryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelance?: boolean | FreelanceDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $FreelanceIndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelanceIndustry"
    objects: {
      freelance: Prisma.$FreelancePayload<ExtArgs>
      industry: Prisma.$IndustryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      freelanceId: string
      industrySlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelanceIndustry"]>
    composites: {}
  }

  type FreelanceIndustryGetPayload<S extends boolean | null | undefined | FreelanceIndustryDefaultArgs> = $Result.GetResult<Prisma.$FreelanceIndustryPayload, S>

  type FreelanceIndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelanceIndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelanceIndustryCountAggregateInputType | true
    }

  export interface FreelanceIndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelanceIndustry'], meta: { name: 'FreelanceIndustry' } }
    /**
     * Find zero or one FreelanceIndustry that matches the filter.
     * @param {FreelanceIndustryFindUniqueArgs} args - Arguments to find a FreelanceIndustry
     * @example
     * // Get one FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelanceIndustryFindUniqueArgs>(args: SelectSubset<T, FreelanceIndustryFindUniqueArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreelanceIndustry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelanceIndustryFindUniqueOrThrowArgs} args - Arguments to find a FreelanceIndustry
     * @example
     * // Get one FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelanceIndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelanceIndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceIndustry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryFindFirstArgs} args - Arguments to find a FreelanceIndustry
     * @example
     * // Get one FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelanceIndustryFindFirstArgs>(args?: SelectSubset<T, FreelanceIndustryFindFirstArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceIndustry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryFindFirstOrThrowArgs} args - Arguments to find a FreelanceIndustry
     * @example
     * // Get one FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelanceIndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelanceIndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreelanceIndustries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelanceIndustries
     * const freelanceIndustries = await prisma.freelanceIndustry.findMany()
     * 
     * // Get first 10 FreelanceIndustries
     * const freelanceIndustries = await prisma.freelanceIndustry.findMany({ take: 10 })
     * 
     * // Only select the `freelanceId`
     * const freelanceIndustryWithFreelanceIdOnly = await prisma.freelanceIndustry.findMany({ select: { freelanceId: true } })
     * 
     */
    findMany<T extends FreelanceIndustryFindManyArgs>(args?: SelectSubset<T, FreelanceIndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreelanceIndustry.
     * @param {FreelanceIndustryCreateArgs} args - Arguments to create a FreelanceIndustry.
     * @example
     * // Create one FreelanceIndustry
     * const FreelanceIndustry = await prisma.freelanceIndustry.create({
     *   data: {
     *     // ... data to create a FreelanceIndustry
     *   }
     * })
     * 
     */
    create<T extends FreelanceIndustryCreateArgs>(args: SelectSubset<T, FreelanceIndustryCreateArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreelanceIndustries.
     * @param {FreelanceIndustryCreateManyArgs} args - Arguments to create many FreelanceIndustries.
     * @example
     * // Create many FreelanceIndustries
     * const freelanceIndustry = await prisma.freelanceIndustry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelanceIndustryCreateManyArgs>(args?: SelectSubset<T, FreelanceIndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelanceIndustries and returns the data saved in the database.
     * @param {FreelanceIndustryCreateManyAndReturnArgs} args - Arguments to create many FreelanceIndustries.
     * @example
     * // Create many FreelanceIndustries
     * const freelanceIndustry = await prisma.freelanceIndustry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelanceIndustries and only return the `freelanceId`
     * const freelanceIndustryWithFreelanceIdOnly = await prisma.freelanceIndustry.createManyAndReturn({
     *   select: { freelanceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelanceIndustryCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelanceIndustryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreelanceIndustry.
     * @param {FreelanceIndustryDeleteArgs} args - Arguments to delete one FreelanceIndustry.
     * @example
     * // Delete one FreelanceIndustry
     * const FreelanceIndustry = await prisma.freelanceIndustry.delete({
     *   where: {
     *     // ... filter to delete one FreelanceIndustry
     *   }
     * })
     * 
     */
    delete<T extends FreelanceIndustryDeleteArgs>(args: SelectSubset<T, FreelanceIndustryDeleteArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreelanceIndustry.
     * @param {FreelanceIndustryUpdateArgs} args - Arguments to update one FreelanceIndustry.
     * @example
     * // Update one FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelanceIndustryUpdateArgs>(args: SelectSubset<T, FreelanceIndustryUpdateArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreelanceIndustries.
     * @param {FreelanceIndustryDeleteManyArgs} args - Arguments to filter FreelanceIndustries to delete.
     * @example
     * // Delete a few FreelanceIndustries
     * const { count } = await prisma.freelanceIndustry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelanceIndustryDeleteManyArgs>(args?: SelectSubset<T, FreelanceIndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelanceIndustries
     * const freelanceIndustry = await prisma.freelanceIndustry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelanceIndustryUpdateManyArgs>(args: SelectSubset<T, FreelanceIndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceIndustries and returns the data updated in the database.
     * @param {FreelanceIndustryUpdateManyAndReturnArgs} args - Arguments to update many FreelanceIndustries.
     * @example
     * // Update many FreelanceIndustries
     * const freelanceIndustry = await prisma.freelanceIndustry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreelanceIndustries and only return the `freelanceId`
     * const freelanceIndustryWithFreelanceIdOnly = await prisma.freelanceIndustry.updateManyAndReturn({
     *   select: { freelanceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelanceIndustryUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelanceIndustryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreelanceIndustry.
     * @param {FreelanceIndustryUpsertArgs} args - Arguments to update or create a FreelanceIndustry.
     * @example
     * // Update or create a FreelanceIndustry
     * const freelanceIndustry = await prisma.freelanceIndustry.upsert({
     *   create: {
     *     // ... data to create a FreelanceIndustry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelanceIndustry we want to update
     *   }
     * })
     */
    upsert<T extends FreelanceIndustryUpsertArgs>(args: SelectSubset<T, FreelanceIndustryUpsertArgs<ExtArgs>>): Prisma__FreelanceIndustryClient<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreelanceIndustries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryCountArgs} args - Arguments to filter FreelanceIndustries to count.
     * @example
     * // Count the number of FreelanceIndustries
     * const count = await prisma.freelanceIndustry.count({
     *   where: {
     *     // ... the filter for the FreelanceIndustries we want to count
     *   }
     * })
    **/
    count<T extends FreelanceIndustryCountArgs>(
      args?: Subset<T, FreelanceIndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelanceIndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelanceIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelanceIndustryAggregateArgs>(args: Subset<T, FreelanceIndustryAggregateArgs>): Prisma.PrismaPromise<GetFreelanceIndustryAggregateType<T>>

    /**
     * Group by FreelanceIndustry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceIndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelanceIndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelanceIndustryGroupByArgs['orderBy'] }
        : { orderBy?: FreelanceIndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelanceIndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelanceIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelanceIndustry model
   */
  readonly fields: FreelanceIndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelanceIndustry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelanceIndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    freelance<T extends FreelanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FreelanceDefaultArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelanceIndustry model
   */
  interface FreelanceIndustryFieldRefs {
    readonly freelanceId: FieldRef<"FreelanceIndustry", 'String'>
    readonly industrySlug: FieldRef<"FreelanceIndustry", 'String'>
    readonly createdAt: FieldRef<"FreelanceIndustry", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelanceIndustry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelanceIndustry findUnique
   */
  export type FreelanceIndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceIndustry to fetch.
     */
    where: FreelanceIndustryWhereUniqueInput
  }

  /**
   * FreelanceIndustry findUniqueOrThrow
   */
  export type FreelanceIndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceIndustry to fetch.
     */
    where: FreelanceIndustryWhereUniqueInput
  }

  /**
   * FreelanceIndustry findFirst
   */
  export type FreelanceIndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceIndustry to fetch.
     */
    where?: FreelanceIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceIndustries to fetch.
     */
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceIndustries.
     */
    cursor?: FreelanceIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceIndustries.
     */
    distinct?: FreelanceIndustryScalarFieldEnum | FreelanceIndustryScalarFieldEnum[]
  }

  /**
   * FreelanceIndustry findFirstOrThrow
   */
  export type FreelanceIndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceIndustry to fetch.
     */
    where?: FreelanceIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceIndustries to fetch.
     */
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceIndustries.
     */
    cursor?: FreelanceIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceIndustries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceIndustries.
     */
    distinct?: FreelanceIndustryScalarFieldEnum | FreelanceIndustryScalarFieldEnum[]
  }

  /**
   * FreelanceIndustry findMany
   */
  export type FreelanceIndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceIndustries to fetch.
     */
    where?: FreelanceIndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceIndustries to fetch.
     */
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelanceIndustries.
     */
    cursor?: FreelanceIndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceIndustries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceIndustries.
     */
    skip?: number
    distinct?: FreelanceIndustryScalarFieldEnum | FreelanceIndustryScalarFieldEnum[]
  }

  /**
   * FreelanceIndustry create
   */
  export type FreelanceIndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelanceIndustry.
     */
    data: XOR<FreelanceIndustryCreateInput, FreelanceIndustryUncheckedCreateInput>
  }

  /**
   * FreelanceIndustry createMany
   */
  export type FreelanceIndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelanceIndustries.
     */
    data: FreelanceIndustryCreateManyInput | FreelanceIndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelanceIndustry createManyAndReturn
   */
  export type FreelanceIndustryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * The data used to create many FreelanceIndustries.
     */
    data: FreelanceIndustryCreateManyInput | FreelanceIndustryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceIndustry update
   */
  export type FreelanceIndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelanceIndustry.
     */
    data: XOR<FreelanceIndustryUpdateInput, FreelanceIndustryUncheckedUpdateInput>
    /**
     * Choose, which FreelanceIndustry to update.
     */
    where: FreelanceIndustryWhereUniqueInput
  }

  /**
   * FreelanceIndustry updateMany
   */
  export type FreelanceIndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelanceIndustries.
     */
    data: XOR<FreelanceIndustryUpdateManyMutationInput, FreelanceIndustryUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceIndustries to update
     */
    where?: FreelanceIndustryWhereInput
    /**
     * Limit how many FreelanceIndustries to update.
     */
    limit?: number
  }

  /**
   * FreelanceIndustry updateManyAndReturn
   */
  export type FreelanceIndustryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * The data used to update FreelanceIndustries.
     */
    data: XOR<FreelanceIndustryUpdateManyMutationInput, FreelanceIndustryUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceIndustries to update
     */
    where?: FreelanceIndustryWhereInput
    /**
     * Limit how many FreelanceIndustries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceIndustry upsert
   */
  export type FreelanceIndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelanceIndustry to update in case it exists.
     */
    where: FreelanceIndustryWhereUniqueInput
    /**
     * In case the FreelanceIndustry found by the `where` argument doesn't exist, create a new FreelanceIndustry with this data.
     */
    create: XOR<FreelanceIndustryCreateInput, FreelanceIndustryUncheckedCreateInput>
    /**
     * In case the FreelanceIndustry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelanceIndustryUpdateInput, FreelanceIndustryUncheckedUpdateInput>
  }

  /**
   * FreelanceIndustry delete
   */
  export type FreelanceIndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    /**
     * Filter which FreelanceIndustry to delete.
     */
    where: FreelanceIndustryWhereUniqueInput
  }

  /**
   * FreelanceIndustry deleteMany
   */
  export type FreelanceIndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceIndustries to delete
     */
    where?: FreelanceIndustryWhereInput
    /**
     * Limit how many FreelanceIndustries to delete.
     */
    limit?: number
  }

  /**
   * FreelanceIndustry without action
   */
  export type FreelanceIndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
  }


  /**
   * Model Industry
   */

  export type AggregateIndustry = {
    _count: IndustryCountAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  export type IndustryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndustryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndustryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndustryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndustryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndustryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industry to aggregate.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Industries
    **/
    _count?: true | IndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryMaxAggregateInputType
  }

  export type GetIndustryAggregateType<T extends IndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustry[P]>
      : GetScalarType<T[P], AggregateIndustry[P]>
  }




  export type IndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndustryWhereInput
    orderBy?: IndustryOrderByWithAggregationInput | IndustryOrderByWithAggregationInput[]
    by: IndustryScalarFieldEnum[] | IndustryScalarFieldEnum
    having?: IndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryCountAggregateInputType | true
    _min?: IndustryMinAggregateInputType
    _max?: IndustryMaxAggregateInputType
  }

  export type IndustryGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: IndustryCountAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  type GetIndustryGroupByPayload<T extends IndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryGroupByOutputType[P]>
        }
      >
    >


  export type IndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Skill?: boolean | Industry$SkillArgs<ExtArgs>
    Source?: boolean | Industry$SourceArgs<ExtArgs>
    Channel?: boolean | Industry$ChannelArgs<ExtArgs>
    Segment?: boolean | Industry$SegmentArgs<ExtArgs>
    Category?: boolean | Industry$CategoryArgs<ExtArgs>
    companies?: boolean | Industry$companiesArgs<ExtArgs>
    freelancers?: boolean | Industry$freelancersArgs<ExtArgs>
    users?: boolean | Industry$usersArgs<ExtArgs>
    Standards?: boolean | Industry$StandardsArgs<ExtArgs>
    RevenueStream?: boolean | Industry$RevenueStreamArgs<ExtArgs>
    Tag?: boolean | Industry$TagArgs<ExtArgs>
    LookingFor?: boolean | Industry$LookingForArgs<ExtArgs>
    _count?: boolean | IndustryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["industry"]>
  export type IndustryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Skill?: boolean | Industry$SkillArgs<ExtArgs>
    Source?: boolean | Industry$SourceArgs<ExtArgs>
    Channel?: boolean | Industry$ChannelArgs<ExtArgs>
    Segment?: boolean | Industry$SegmentArgs<ExtArgs>
    Category?: boolean | Industry$CategoryArgs<ExtArgs>
    companies?: boolean | Industry$companiesArgs<ExtArgs>
    freelancers?: boolean | Industry$freelancersArgs<ExtArgs>
    users?: boolean | Industry$usersArgs<ExtArgs>
    Standards?: boolean | Industry$StandardsArgs<ExtArgs>
    RevenueStream?: boolean | Industry$RevenueStreamArgs<ExtArgs>
    Tag?: boolean | Industry$TagArgs<ExtArgs>
    LookingFor?: boolean | Industry$LookingForArgs<ExtArgs>
    _count?: boolean | IndustryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndustryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IndustryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Industry"
    objects: {
      Skill: Prisma.$SkillPayload<ExtArgs>[]
      Source: Prisma.$SourcePayload<ExtArgs>[]
      Channel: Prisma.$ChannelPayload<ExtArgs>[]
      Segment: Prisma.$SegmentPayload<ExtArgs>[]
      Category: Prisma.$CategoryPayload<ExtArgs>[]
      companies: Prisma.$CompanyIndustryPayload<ExtArgs>[]
      freelancers: Prisma.$FreelanceIndustryPayload<ExtArgs>[]
      users: Prisma.$UserIndustryPayload<ExtArgs>[]
      Standards: Prisma.$StandardsPayload<ExtArgs>[]
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
      Tag: Prisma.$TagPayload<ExtArgs>[]
      LookingFor: Prisma.$LookingForPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["industry"]>
    composites: {}
  }

  type IndustryGetPayload<S extends boolean | null | undefined | IndustryDefaultArgs> = $Result.GetResult<Prisma.$IndustryPayload, S>

  type IndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndustryCountAggregateInputType | true
    }

  export interface IndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Industry'], meta: { name: 'Industry' } }
    /**
     * Find zero or one Industry that matches the filter.
     * @param {IndustryFindUniqueArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndustryFindUniqueArgs>(args: SelectSubset<T, IndustryFindUniqueArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Industry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndustryFindUniqueOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, IndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndustryFindFirstArgs>(args?: SelectSubset<T, IndustryFindFirstArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, IndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Industries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Industries
     * const industries = await prisma.industry.findMany()
     * 
     * // Get first 10 Industries
     * const industries = await prisma.industry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const industryWithIdOnly = await prisma.industry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndustryFindManyArgs>(args?: SelectSubset<T, IndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Industry.
     * @param {IndustryCreateArgs} args - Arguments to create a Industry.
     * @example
     * // Create one Industry
     * const Industry = await prisma.industry.create({
     *   data: {
     *     // ... data to create a Industry
     *   }
     * })
     * 
     */
    create<T extends IndustryCreateArgs>(args: SelectSubset<T, IndustryCreateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Industries.
     * @param {IndustryCreateManyArgs} args - Arguments to create many Industries.
     * @example
     * // Create many Industries
     * const industry = await prisma.industry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndustryCreateManyArgs>(args?: SelectSubset<T, IndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Industries and returns the data saved in the database.
     * @param {IndustryCreateManyAndReturnArgs} args - Arguments to create many Industries.
     * @example
     * // Create many Industries
     * const industry = await prisma.industry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Industries and only return the `id`
     * const industryWithIdOnly = await prisma.industry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndustryCreateManyAndReturnArgs>(args?: SelectSubset<T, IndustryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Industry.
     * @param {IndustryDeleteArgs} args - Arguments to delete one Industry.
     * @example
     * // Delete one Industry
     * const Industry = await prisma.industry.delete({
     *   where: {
     *     // ... filter to delete one Industry
     *   }
     * })
     * 
     */
    delete<T extends IndustryDeleteArgs>(args: SelectSubset<T, IndustryDeleteArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Industry.
     * @param {IndustryUpdateArgs} args - Arguments to update one Industry.
     * @example
     * // Update one Industry
     * const industry = await prisma.industry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndustryUpdateArgs>(args: SelectSubset<T, IndustryUpdateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Industries.
     * @param {IndustryDeleteManyArgs} args - Arguments to filter Industries to delete.
     * @example
     * // Delete a few Industries
     * const { count } = await prisma.industry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndustryDeleteManyArgs>(args?: SelectSubset<T, IndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Industries
     * const industry = await prisma.industry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndustryUpdateManyArgs>(args: SelectSubset<T, IndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industries and returns the data updated in the database.
     * @param {IndustryUpdateManyAndReturnArgs} args - Arguments to update many Industries.
     * @example
     * // Update many Industries
     * const industry = await prisma.industry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Industries and only return the `id`
     * const industryWithIdOnly = await prisma.industry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndustryUpdateManyAndReturnArgs>(args: SelectSubset<T, IndustryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Industry.
     * @param {IndustryUpsertArgs} args - Arguments to update or create a Industry.
     * @example
     * // Update or create a Industry
     * const industry = await prisma.industry.upsert({
     *   create: {
     *     // ... data to create a Industry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Industry we want to update
     *   }
     * })
     */
    upsert<T extends IndustryUpsertArgs>(args: SelectSubset<T, IndustryUpsertArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryCountArgs} args - Arguments to filter Industries to count.
     * @example
     * // Count the number of Industries
     * const count = await prisma.industry.count({
     *   where: {
     *     // ... the filter for the Industries we want to count
     *   }
     * })
    **/
    count<T extends IndustryCountArgs>(
      args?: Subset<T, IndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryAggregateArgs>(args: Subset<T, IndustryAggregateArgs>): Prisma.PrismaPromise<GetIndustryAggregateType<T>>

    /**
     * Group by Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryGroupByArgs['orderBy'] }
        : { orderBy?: IndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Industry model
   */
  readonly fields: IndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Industry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Skill<T extends Industry$SkillArgs<ExtArgs> = {}>(args?: Subset<T, Industry$SkillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Source<T extends Industry$SourceArgs<ExtArgs> = {}>(args?: Subset<T, Industry$SourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Channel<T extends Industry$ChannelArgs<ExtArgs> = {}>(args?: Subset<T, Industry$ChannelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Segment<T extends Industry$SegmentArgs<ExtArgs> = {}>(args?: Subset<T, Industry$SegmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Category<T extends Industry$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Industry$CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends Industry$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Industry$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelancers<T extends Industry$freelancersArgs<ExtArgs> = {}>(args?: Subset<T, Industry$freelancersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Industry$usersArgs<ExtArgs> = {}>(args?: Subset<T, Industry$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Standards<T extends Industry$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, Industry$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RevenueStream<T extends Industry$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Industry$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tag<T extends Industry$TagArgs<ExtArgs> = {}>(args?: Subset<T, Industry$TagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LookingFor<T extends Industry$LookingForArgs<ExtArgs> = {}>(args?: Subset<T, Industry$LookingForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Industry model
   */
  interface IndustryFieldRefs {
    readonly id: FieldRef<"Industry", 'String'>
    readonly name: FieldRef<"Industry", 'String'>
    readonly slug: FieldRef<"Industry", 'String'>
    readonly createdAt: FieldRef<"Industry", 'DateTime'>
    readonly updatedAt: FieldRef<"Industry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Industry findUnique
   */
  export type IndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findUniqueOrThrow
   */
  export type IndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findFirst
   */
  export type IndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findFirstOrThrow
   */
  export type IndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findMany
   */
  export type IndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industries to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry create
   */
  export type IndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The data needed to create a Industry.
     */
    data: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
  }

  /**
   * Industry createMany
   */
  export type IndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Industries.
     */
    data: IndustryCreateManyInput | IndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Industry createManyAndReturn
   */
  export type IndustryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data used to create many Industries.
     */
    data: IndustryCreateManyInput | IndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Industry update
   */
  export type IndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The data needed to update a Industry.
     */
    data: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
    /**
     * Choose, which Industry to update.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry updateMany
   */
  export type IndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Industries.
     */
    data: XOR<IndustryUpdateManyMutationInput, IndustryUncheckedUpdateManyInput>
    /**
     * Filter which Industries to update
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to update.
     */
    limit?: number
  }

  /**
   * Industry updateManyAndReturn
   */
  export type IndustryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data used to update Industries.
     */
    data: XOR<IndustryUpdateManyMutationInput, IndustryUncheckedUpdateManyInput>
    /**
     * Filter which Industries to update
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to update.
     */
    limit?: number
  }

  /**
   * Industry upsert
   */
  export type IndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The filter to search for the Industry to update in case it exists.
     */
    where: IndustryWhereUniqueInput
    /**
     * In case the Industry found by the `where` argument doesn't exist, create a new Industry with this data.
     */
    create: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
    /**
     * In case the Industry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
  }

  /**
   * Industry delete
   */
  export type IndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter which Industry to delete.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry deleteMany
   */
  export type IndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industries to delete
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to delete.
     */
    limit?: number
  }

  /**
   * Industry.Skill
   */
  export type Industry$SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Industry.Source
   */
  export type Industry$SourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    cursor?: SourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Industry.Channel
   */
  export type Industry$ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Industry.Segment
   */
  export type Industry$SegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    cursor?: SegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Industry.Category
   */
  export type Industry$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Industry.companies
   */
  export type Industry$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyIndustry
     */
    select?: CompanyIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyIndustry
     */
    omit?: CompanyIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIndustryInclude<ExtArgs> | null
    where?: CompanyIndustryWhereInput
    orderBy?: CompanyIndustryOrderByWithRelationInput | CompanyIndustryOrderByWithRelationInput[]
    cursor?: CompanyIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyIndustryScalarFieldEnum | CompanyIndustryScalarFieldEnum[]
  }

  /**
   * Industry.freelancers
   */
  export type Industry$freelancersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceIndustry
     */
    select?: FreelanceIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceIndustry
     */
    omit?: FreelanceIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceIndustryInclude<ExtArgs> | null
    where?: FreelanceIndustryWhereInput
    orderBy?: FreelanceIndustryOrderByWithRelationInput | FreelanceIndustryOrderByWithRelationInput[]
    cursor?: FreelanceIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceIndustryScalarFieldEnum | FreelanceIndustryScalarFieldEnum[]
  }

  /**
   * Industry.users
   */
  export type Industry$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIndustry
     */
    select?: UserIndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserIndustry
     */
    omit?: UserIndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIndustryInclude<ExtArgs> | null
    where?: UserIndustryWhereInput
    orderBy?: UserIndustryOrderByWithRelationInput | UserIndustryOrderByWithRelationInput[]
    cursor?: UserIndustryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserIndustryScalarFieldEnum | UserIndustryScalarFieldEnum[]
  }

  /**
   * Industry.Standards
   */
  export type Industry$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    where?: StandardsWhereInput
    orderBy?: StandardsOrderByWithRelationInput | StandardsOrderByWithRelationInput[]
    cursor?: StandardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardsScalarFieldEnum | StandardsScalarFieldEnum[]
  }

  /**
   * Industry.RevenueStream
   */
  export type Industry$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Industry.Tag
   */
  export type Industry$TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Industry.LookingFor
   */
  export type Industry$LookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    where?: LookingForWhereInput
    orderBy?: LookingForOrderByWithRelationInput | LookingForOrderByWithRelationInput[]
    cursor?: LookingForWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LookingForScalarFieldEnum | LookingForScalarFieldEnum[]
  }

  /**
   * Industry without action
   */
  export type IndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    industrySlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    industrySlug: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioTag?: boolean | Tag$PortfolioTagArgs<ExtArgs>
    UserTags?: boolean | Tag$UserTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "industrySlug" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioTag?: boolean | Tag$PortfolioTagArgs<ExtArgs>
    UserTags?: boolean | Tag$UserTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      PortfolioTag: Prisma.$PortfolioTagPayload<ExtArgs>[]
      UserTags: Prisma.$UserTagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      industrySlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PortfolioTag<T extends Tag$PortfolioTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$PortfolioTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserTags<T extends Tag$UserTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$UserTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly industrySlug: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.PortfolioTag
   */
  export type Tag$PortfolioTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    where?: PortfolioTagWhereInput
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    cursor?: PortfolioTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioTagScalarFieldEnum | PortfolioTagScalarFieldEnum[]
  }

  /**
   * Tag.UserTags
   */
  export type Tag$UserTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    cursor?: UserTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model LookingFor
   */

  export type AggregateLookingFor = {
    _count: LookingForCountAggregateOutputType | null
    _min: LookingForMinAggregateOutputType | null
    _max: LookingForMaxAggregateOutputType | null
  }

  export type LookingForMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LookingForMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LookingForCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    industrySlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LookingForMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LookingForMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LookingForCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LookingForAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LookingFor to aggregate.
     */
    where?: LookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LookingFors to fetch.
     */
    orderBy?: LookingForOrderByWithRelationInput | LookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LookingFors
    **/
    _count?: true | LookingForCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LookingForMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LookingForMaxAggregateInputType
  }

  export type GetLookingForAggregateType<T extends LookingForAggregateArgs> = {
        [P in keyof T & keyof AggregateLookingFor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLookingFor[P]>
      : GetScalarType<T[P], AggregateLookingFor[P]>
  }




  export type LookingForGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LookingForWhereInput
    orderBy?: LookingForOrderByWithAggregationInput | LookingForOrderByWithAggregationInput[]
    by: LookingForScalarFieldEnum[] | LookingForScalarFieldEnum
    having?: LookingForScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LookingForCountAggregateInputType | true
    _min?: LookingForMinAggregateInputType
    _max?: LookingForMaxAggregateInputType
  }

  export type LookingForGroupByOutputType = {
    id: string
    name: string
    slug: string
    industrySlug: string
    createdAt: Date
    updatedAt: Date
    _count: LookingForCountAggregateOutputType | null
    _min: LookingForMinAggregateOutputType | null
    _max: LookingForMaxAggregateOutputType | null
  }

  type GetLookingForGroupByPayload<T extends LookingForGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LookingForGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LookingForGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LookingForGroupByOutputType[P]>
            : GetScalarType<T[P], LookingForGroupByOutputType[P]>
        }
      >
    >


  export type LookingForSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioLookingFor?: boolean | LookingFor$PortfolioLookingForArgs<ExtArgs>
    _count?: boolean | LookingForCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lookingFor"]>

  export type LookingForSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lookingFor"]>

  export type LookingForSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lookingFor"]>

  export type LookingForSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LookingForOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "industrySlug" | "createdAt" | "updatedAt", ExtArgs["result"]["lookingFor"]>
  export type LookingForInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioLookingFor?: boolean | LookingFor$PortfolioLookingForArgs<ExtArgs>
    _count?: boolean | LookingForCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LookingForIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type LookingForIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $LookingForPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LookingFor"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      PortfolioLookingFor: Prisma.$PortfolioLookingForPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      industrySlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lookingFor"]>
    composites: {}
  }

  type LookingForGetPayload<S extends boolean | null | undefined | LookingForDefaultArgs> = $Result.GetResult<Prisma.$LookingForPayload, S>

  type LookingForCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LookingForFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LookingForCountAggregateInputType | true
    }

  export interface LookingForDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LookingFor'], meta: { name: 'LookingFor' } }
    /**
     * Find zero or one LookingFor that matches the filter.
     * @param {LookingForFindUniqueArgs} args - Arguments to find a LookingFor
     * @example
     * // Get one LookingFor
     * const lookingFor = await prisma.lookingFor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LookingForFindUniqueArgs>(args: SelectSubset<T, LookingForFindUniqueArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LookingFor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LookingForFindUniqueOrThrowArgs} args - Arguments to find a LookingFor
     * @example
     * // Get one LookingFor
     * const lookingFor = await prisma.lookingFor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LookingForFindUniqueOrThrowArgs>(args: SelectSubset<T, LookingForFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LookingFor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForFindFirstArgs} args - Arguments to find a LookingFor
     * @example
     * // Get one LookingFor
     * const lookingFor = await prisma.lookingFor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LookingForFindFirstArgs>(args?: SelectSubset<T, LookingForFindFirstArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LookingFor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForFindFirstOrThrowArgs} args - Arguments to find a LookingFor
     * @example
     * // Get one LookingFor
     * const lookingFor = await prisma.lookingFor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LookingForFindFirstOrThrowArgs>(args?: SelectSubset<T, LookingForFindFirstOrThrowArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LookingFors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LookingFors
     * const lookingFors = await prisma.lookingFor.findMany()
     * 
     * // Get first 10 LookingFors
     * const lookingFors = await prisma.lookingFor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lookingForWithIdOnly = await prisma.lookingFor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LookingForFindManyArgs>(args?: SelectSubset<T, LookingForFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LookingFor.
     * @param {LookingForCreateArgs} args - Arguments to create a LookingFor.
     * @example
     * // Create one LookingFor
     * const LookingFor = await prisma.lookingFor.create({
     *   data: {
     *     // ... data to create a LookingFor
     *   }
     * })
     * 
     */
    create<T extends LookingForCreateArgs>(args: SelectSubset<T, LookingForCreateArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LookingFors.
     * @param {LookingForCreateManyArgs} args - Arguments to create many LookingFors.
     * @example
     * // Create many LookingFors
     * const lookingFor = await prisma.lookingFor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LookingForCreateManyArgs>(args?: SelectSubset<T, LookingForCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LookingFors and returns the data saved in the database.
     * @param {LookingForCreateManyAndReturnArgs} args - Arguments to create many LookingFors.
     * @example
     * // Create many LookingFors
     * const lookingFor = await prisma.lookingFor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LookingFors and only return the `id`
     * const lookingForWithIdOnly = await prisma.lookingFor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LookingForCreateManyAndReturnArgs>(args?: SelectSubset<T, LookingForCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LookingFor.
     * @param {LookingForDeleteArgs} args - Arguments to delete one LookingFor.
     * @example
     * // Delete one LookingFor
     * const LookingFor = await prisma.lookingFor.delete({
     *   where: {
     *     // ... filter to delete one LookingFor
     *   }
     * })
     * 
     */
    delete<T extends LookingForDeleteArgs>(args: SelectSubset<T, LookingForDeleteArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LookingFor.
     * @param {LookingForUpdateArgs} args - Arguments to update one LookingFor.
     * @example
     * // Update one LookingFor
     * const lookingFor = await prisma.lookingFor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LookingForUpdateArgs>(args: SelectSubset<T, LookingForUpdateArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LookingFors.
     * @param {LookingForDeleteManyArgs} args - Arguments to filter LookingFors to delete.
     * @example
     * // Delete a few LookingFors
     * const { count } = await prisma.lookingFor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LookingForDeleteManyArgs>(args?: SelectSubset<T, LookingForDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LookingFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LookingFors
     * const lookingFor = await prisma.lookingFor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LookingForUpdateManyArgs>(args: SelectSubset<T, LookingForUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LookingFors and returns the data updated in the database.
     * @param {LookingForUpdateManyAndReturnArgs} args - Arguments to update many LookingFors.
     * @example
     * // Update many LookingFors
     * const lookingFor = await prisma.lookingFor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LookingFors and only return the `id`
     * const lookingForWithIdOnly = await prisma.lookingFor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LookingForUpdateManyAndReturnArgs>(args: SelectSubset<T, LookingForUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LookingFor.
     * @param {LookingForUpsertArgs} args - Arguments to update or create a LookingFor.
     * @example
     * // Update or create a LookingFor
     * const lookingFor = await prisma.lookingFor.upsert({
     *   create: {
     *     // ... data to create a LookingFor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LookingFor we want to update
     *   }
     * })
     */
    upsert<T extends LookingForUpsertArgs>(args: SelectSubset<T, LookingForUpsertArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LookingFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForCountArgs} args - Arguments to filter LookingFors to count.
     * @example
     * // Count the number of LookingFors
     * const count = await prisma.lookingFor.count({
     *   where: {
     *     // ... the filter for the LookingFors we want to count
     *   }
     * })
    **/
    count<T extends LookingForCountArgs>(
      args?: Subset<T, LookingForCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LookingForCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LookingFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LookingForAggregateArgs>(args: Subset<T, LookingForAggregateArgs>): Prisma.PrismaPromise<GetLookingForAggregateType<T>>

    /**
     * Group by LookingFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LookingForGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LookingForGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LookingForGroupByArgs['orderBy'] }
        : { orderBy?: LookingForGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LookingForGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLookingForGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LookingFor model
   */
  readonly fields: LookingForFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LookingFor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LookingForClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PortfolioLookingFor<T extends LookingFor$PortfolioLookingForArgs<ExtArgs> = {}>(args?: Subset<T, LookingFor$PortfolioLookingForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LookingFor model
   */
  interface LookingForFieldRefs {
    readonly id: FieldRef<"LookingFor", 'String'>
    readonly name: FieldRef<"LookingFor", 'String'>
    readonly slug: FieldRef<"LookingFor", 'String'>
    readonly industrySlug: FieldRef<"LookingFor", 'String'>
    readonly createdAt: FieldRef<"LookingFor", 'DateTime'>
    readonly updatedAt: FieldRef<"LookingFor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LookingFor findUnique
   */
  export type LookingForFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter, which LookingFor to fetch.
     */
    where: LookingForWhereUniqueInput
  }

  /**
   * LookingFor findUniqueOrThrow
   */
  export type LookingForFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter, which LookingFor to fetch.
     */
    where: LookingForWhereUniqueInput
  }

  /**
   * LookingFor findFirst
   */
  export type LookingForFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter, which LookingFor to fetch.
     */
    where?: LookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LookingFors to fetch.
     */
    orderBy?: LookingForOrderByWithRelationInput | LookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LookingFors.
     */
    cursor?: LookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LookingFors.
     */
    distinct?: LookingForScalarFieldEnum | LookingForScalarFieldEnum[]
  }

  /**
   * LookingFor findFirstOrThrow
   */
  export type LookingForFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter, which LookingFor to fetch.
     */
    where?: LookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LookingFors to fetch.
     */
    orderBy?: LookingForOrderByWithRelationInput | LookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LookingFors.
     */
    cursor?: LookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LookingFors.
     */
    distinct?: LookingForScalarFieldEnum | LookingForScalarFieldEnum[]
  }

  /**
   * LookingFor findMany
   */
  export type LookingForFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter, which LookingFors to fetch.
     */
    where?: LookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LookingFors to fetch.
     */
    orderBy?: LookingForOrderByWithRelationInput | LookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LookingFors.
     */
    cursor?: LookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LookingFors.
     */
    skip?: number
    distinct?: LookingForScalarFieldEnum | LookingForScalarFieldEnum[]
  }

  /**
   * LookingFor create
   */
  export type LookingForCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * The data needed to create a LookingFor.
     */
    data: XOR<LookingForCreateInput, LookingForUncheckedCreateInput>
  }

  /**
   * LookingFor createMany
   */
  export type LookingForCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LookingFors.
     */
    data: LookingForCreateManyInput | LookingForCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LookingFor createManyAndReturn
   */
  export type LookingForCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * The data used to create many LookingFors.
     */
    data: LookingForCreateManyInput | LookingForCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LookingFor update
   */
  export type LookingForUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * The data needed to update a LookingFor.
     */
    data: XOR<LookingForUpdateInput, LookingForUncheckedUpdateInput>
    /**
     * Choose, which LookingFor to update.
     */
    where: LookingForWhereUniqueInput
  }

  /**
   * LookingFor updateMany
   */
  export type LookingForUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LookingFors.
     */
    data: XOR<LookingForUpdateManyMutationInput, LookingForUncheckedUpdateManyInput>
    /**
     * Filter which LookingFors to update
     */
    where?: LookingForWhereInput
    /**
     * Limit how many LookingFors to update.
     */
    limit?: number
  }

  /**
   * LookingFor updateManyAndReturn
   */
  export type LookingForUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * The data used to update LookingFors.
     */
    data: XOR<LookingForUpdateManyMutationInput, LookingForUncheckedUpdateManyInput>
    /**
     * Filter which LookingFors to update
     */
    where?: LookingForWhereInput
    /**
     * Limit how many LookingFors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LookingFor upsert
   */
  export type LookingForUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * The filter to search for the LookingFor to update in case it exists.
     */
    where: LookingForWhereUniqueInput
    /**
     * In case the LookingFor found by the `where` argument doesn't exist, create a new LookingFor with this data.
     */
    create: XOR<LookingForCreateInput, LookingForUncheckedCreateInput>
    /**
     * In case the LookingFor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LookingForUpdateInput, LookingForUncheckedUpdateInput>
  }

  /**
   * LookingFor delete
   */
  export type LookingForDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
    /**
     * Filter which LookingFor to delete.
     */
    where: LookingForWhereUniqueInput
  }

  /**
   * LookingFor deleteMany
   */
  export type LookingForDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LookingFors to delete
     */
    where?: LookingForWhereInput
    /**
     * Limit how many LookingFors to delete.
     */
    limit?: number
  }

  /**
   * LookingFor.PortfolioLookingFor
   */
  export type LookingFor$PortfolioLookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    where?: PortfolioLookingForWhereInput
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    cursor?: PortfolioLookingForWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioLookingForScalarFieldEnum | PortfolioLookingForScalarFieldEnum[]
  }

  /**
   * LookingFor without action
   */
  export type LookingForDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LookingFor
     */
    select?: LookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LookingFor
     */
    omit?: LookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LookingForInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    industrySlug: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    industrySlug: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Category$RevenueStreamArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt" | "industrySlug", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Category$RevenueStreamArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
      industrySlug: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RevenueStream<T extends Category$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Category$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly industrySlug: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.RevenueStream
   */
  export type Category$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Source
   */

  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    industrySlug: number
    _all: number
  }


  export type SourceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithAggregationInput | SourceOrderByWithAggregationInput[]
    by: SourceScalarFieldEnum[] | SourceScalarFieldEnum
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }

  export type SourceGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    industrySlug: string
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Source$RevenueStreamArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
  }

  export type SourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt" | "industrySlug", ExtArgs["result"]["source"]>
  export type SourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Source$RevenueStreamArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type SourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $SourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Source"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
      industrySlug: string
    }, ExtArgs["result"]["source"]>
    composites: {}
  }

  type SourceGetPayload<S extends boolean | null | undefined | SourceDefaultArgs> = $Result.GetResult<Prisma.$SourcePayload, S>

  type SourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Source'], meta: { name: 'Source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceFindUniqueArgs>(args: SelectSubset<T, SourceFindUniqueArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceFindFirstArgs>(args?: SelectSubset<T, SourceFindFirstArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceFindManyArgs>(args?: SelectSubset<T, SourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
     */
    create<T extends SourceCreateArgs>(args: SelectSubset<T, SourceCreateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sources.
     * @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceCreateManyArgs>(args?: SelectSubset<T, SourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourceCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
     */
    delete<T extends SourceDeleteArgs>(args: SelectSubset<T, SourceDeleteArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceUpdateArgs>(args: SelectSubset<T, SourceUpdateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDeleteManyArgs>(args?: SelectSubset<T, SourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceUpdateManyArgs>(args: SelectSubset<T, SourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourceUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
     */
    upsert<T extends SourceUpsertArgs>(args: SelectSubset<T, SourceUpsertArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Source model
   */
  readonly fields: SourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RevenueStream<T extends Source$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Source$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Source model
   */
  interface SourceFieldRefs {
    readonly id: FieldRef<"Source", 'String'>
    readonly name: FieldRef<"Source", 'String'>
    readonly slug: FieldRef<"Source", 'String'>
    readonly createdAt: FieldRef<"Source", 'DateTime'>
    readonly updatedAt: FieldRef<"Source", 'DateTime'>
    readonly industrySlug: FieldRef<"Source", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findMany
   */
  export type SourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source create
   */
  export type SourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }

  /**
   * Source createMany
   */
  export type SourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source createManyAndReturn
   */
  export type SourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Source update
   */
  export type SourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source updateManyAndReturn
   */
  export type SourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Source upsert
   */
  export type SourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }

  /**
   * Source delete
   */
  export type SourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Source.RevenueStream
   */
  export type Source$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Source without action
   */
  export type SourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    industrySlug: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    industrySlug: string
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Channel$RevenueStreamArgs<ExtArgs>
    UserChannels?: boolean | Channel$UserChannelsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
  }

  export type ChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt" | "industrySlug", ExtArgs["result"]["channel"]>
  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Channel$RevenueStreamArgs<ExtArgs>
    UserChannels?: boolean | Channel$UserChannelsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
      UserChannels: Prisma.$UserChannelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
      industrySlug: string
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels and returns the data updated in the database.
     * @param {ChannelUpdateManyAndReturnArgs} args - Arguments to update many Channels.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RevenueStream<T extends Channel$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Channel$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserChannels<T extends Channel$UserChannelsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$UserChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly slug: FieldRef<"Channel", 'String'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
    readonly industrySlug: FieldRef<"Channel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to update.
     */
    limit?: number
  }

  /**
   * Channel updateManyAndReturn
   */
  export type ChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
    /**
     * Limit how many Channels to delete.
     */
    limit?: number
  }

  /**
   * Channel.RevenueStream
   */
  export type Channel$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Channel.UserChannels
   */
  export type Channel$UserChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChannels
     */
    select?: UserChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserChannels
     */
    omit?: UserChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChannelsInclude<ExtArgs> | null
    where?: UserChannelsWhereInput
    orderBy?: UserChannelsOrderByWithRelationInput | UserChannelsOrderByWithRelationInput[]
    cursor?: UserChannelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChannelsScalarFieldEnum | UserChannelsScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Channel
     */
    omit?: ChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Segment
   */

  export type AggregateSegment = {
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  export type SegmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type SegmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    industrySlug: string | null
  }

  export type SegmentCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    industrySlug: number
    _all: number
  }


  export type SegmentMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type SegmentMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
  }

  export type SegmentCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    industrySlug?: true
    _all?: true
  }

  export type SegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segment to aggregate.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Segments
    **/
    _count?: true | SegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentMaxAggregateInputType
  }

  export type GetSegmentAggregateType<T extends SegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegment[P]>
      : GetScalarType<T[P], AggregateSegment[P]>
  }




  export type SegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithAggregationInput | SegmentOrderByWithAggregationInput[]
    by: SegmentScalarFieldEnum[] | SegmentScalarFieldEnum
    having?: SegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentCountAggregateInputType | true
    _min?: SegmentMinAggregateInputType
    _max?: SegmentMaxAggregateInputType
  }

  export type SegmentGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    industrySlug: string
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  type GetSegmentGroupByPayload<T extends SegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentGroupByOutputType[P]>
        }
      >
    >


  export type SegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Segment$RevenueStreamArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industrySlug?: boolean
  }

  export type SegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt" | "industrySlug", ExtArgs["result"]["segment"]>
  export type SegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    RevenueStream?: boolean | Segment$RevenueStreamArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type SegmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $SegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Segment"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      RevenueStream: Prisma.$RevenueStreamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
      industrySlug: string
    }, ExtArgs["result"]["segment"]>
    composites: {}
  }

  type SegmentGetPayload<S extends boolean | null | undefined | SegmentDefaultArgs> = $Result.GetResult<Prisma.$SegmentPayload, S>

  type SegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SegmentCountAggregateInputType | true
    }

  export interface SegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Segment'], meta: { name: 'Segment' } }
    /**
     * Find zero or one Segment that matches the filter.
     * @param {SegmentFindUniqueArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentFindUniqueArgs>(args: SelectSubset<T, SegmentFindUniqueArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Segment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SegmentFindUniqueOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentFindFirstArgs>(args?: SelectSubset<T, SegmentFindFirstArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Segments
     * const segments = await prisma.segment.findMany()
     * 
     * // Get first 10 Segments
     * const segments = await prisma.segment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentWithIdOnly = await prisma.segment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentFindManyArgs>(args?: SelectSubset<T, SegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Segment.
     * @param {SegmentCreateArgs} args - Arguments to create a Segment.
     * @example
     * // Create one Segment
     * const Segment = await prisma.segment.create({
     *   data: {
     *     // ... data to create a Segment
     *   }
     * })
     * 
     */
    create<T extends SegmentCreateArgs>(args: SelectSubset<T, SegmentCreateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Segments.
     * @param {SegmentCreateManyArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentCreateManyArgs>(args?: SelectSubset<T, SegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Segments and returns the data saved in the database.
     * @param {SegmentCreateManyAndReturnArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Segment.
     * @param {SegmentDeleteArgs} args - Arguments to delete one Segment.
     * @example
     * // Delete one Segment
     * const Segment = await prisma.segment.delete({
     *   where: {
     *     // ... filter to delete one Segment
     *   }
     * })
     * 
     */
    delete<T extends SegmentDeleteArgs>(args: SelectSubset<T, SegmentDeleteArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Segment.
     * @param {SegmentUpdateArgs} args - Arguments to update one Segment.
     * @example
     * // Update one Segment
     * const segment = await prisma.segment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentUpdateArgs>(args: SelectSubset<T, SegmentUpdateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Segments.
     * @param {SegmentDeleteManyArgs} args - Arguments to filter Segments to delete.
     * @example
     * // Delete a few Segments
     * const { count } = await prisma.segment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentDeleteManyArgs>(args?: SelectSubset<T, SegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentUpdateManyArgs>(args: SelectSubset<T, SegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments and returns the data updated in the database.
     * @param {SegmentUpdateManyAndReturnArgs} args - Arguments to update many Segments.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Segment.
     * @param {SegmentUpsertArgs} args - Arguments to update or create a Segment.
     * @example
     * // Update or create a Segment
     * const segment = await prisma.segment.upsert({
     *   create: {
     *     // ... data to create a Segment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Segment we want to update
     *   }
     * })
     */
    upsert<T extends SegmentUpsertArgs>(args: SelectSubset<T, SegmentUpsertArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentCountArgs} args - Arguments to filter Segments to count.
     * @example
     * // Count the number of Segments
     * const count = await prisma.segment.count({
     *   where: {
     *     // ... the filter for the Segments we want to count
     *   }
     * })
    **/
    count<T extends SegmentCountArgs>(
      args?: Subset<T, SegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentAggregateArgs>(args: Subset<T, SegmentAggregateArgs>): Prisma.PrismaPromise<GetSegmentAggregateType<T>>

    /**
     * Group by Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentGroupByArgs['orderBy'] }
        : { orderBy?: SegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Segment model
   */
  readonly fields: SegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Segment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RevenueStream<T extends Segment$RevenueStreamArgs<ExtArgs> = {}>(args?: Subset<T, Segment$RevenueStreamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueStreamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Segment model
   */
  interface SegmentFieldRefs {
    readonly id: FieldRef<"Segment", 'String'>
    readonly name: FieldRef<"Segment", 'String'>
    readonly slug: FieldRef<"Segment", 'String'>
    readonly createdAt: FieldRef<"Segment", 'DateTime'>
    readonly updatedAt: FieldRef<"Segment", 'DateTime'>
    readonly industrySlug: FieldRef<"Segment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Segment findUnique
   */
  export type SegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findUniqueOrThrow
   */
  export type SegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findFirst
   */
  export type SegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findFirstOrThrow
   */
  export type SegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findMany
   */
  export type SegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segments to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment create
   */
  export type SegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Segment.
     */
    data: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
  }

  /**
   * Segment createMany
   */
  export type SegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Segment createManyAndReturn
   */
  export type SegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Segment update
   */
  export type SegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Segment.
     */
    data: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
    /**
     * Choose, which Segment to update.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment updateMany
   */
  export type SegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
  }

  /**
   * Segment updateManyAndReturn
   */
  export type SegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Segment upsert
   */
  export type SegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Segment to update in case it exists.
     */
    where: SegmentWhereUniqueInput
    /**
     * In case the Segment found by the `where` argument doesn't exist, create a new Segment with this data.
     */
    create: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
    /**
     * In case the Segment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
  }

  /**
   * Segment delete
   */
  export type SegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter which Segment to delete.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment deleteMany
   */
  export type SegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segments to delete
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to delete.
     */
    limit?: number
  }

  /**
   * Segment.RevenueStream
   */
  export type Segment$RevenueStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueStream
     */
    select?: RevenueStreamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueStream
     */
    omit?: RevenueStreamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueStreamInclude<ExtArgs> | null
    where?: RevenueStreamWhereInput
    orderBy?: RevenueStreamOrderByWithRelationInput | RevenueStreamOrderByWithRelationInput[]
    cursor?: RevenueStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueStreamScalarFieldEnum | RevenueStreamScalarFieldEnum[]
  }

  /**
   * Segment without action
   */
  export type SegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
  }


  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: string | null
    title: string | null
    title_en: string | null
    description: string | null
    description_en: string | null
    cover_image: string | null
    link: string | null
    industryTypeSlug: string | null
    freelanceId: string | null
    companyId: string | null
    companyJuristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: string | null
    title: string | null
    title_en: string | null
    description: string | null
    description_en: string | null
    cover_image: string | null
    link: string | null
    industryTypeSlug: string | null
    freelanceId: string | null
    companyId: string | null
    companyJuristicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    title: number
    title_en: number
    description: number
    description_en: number
    cover_image: number
    link: number
    industryTypeSlug: number
    tags: number
    looking_for: number
    freelanceId: number
    companyId: number
    companyJuristicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioMinAggregateInputType = {
    id?: true
    title?: true
    title_en?: true
    description?: true
    description_en?: true
    cover_image?: true
    link?: true
    industryTypeSlug?: true
    freelanceId?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    title?: true
    title_en?: true
    description?: true
    description_en?: true
    cover_image?: true
    link?: true
    industryTypeSlug?: true
    freelanceId?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    title?: true
    title_en?: true
    description?: true
    description_en?: true
    cover_image?: true
    link?: true
    industryTypeSlug?: true
    tags?: true
    looking_for?: true
    freelanceId?: true
    companyId?: true
    companyJuristicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: string
    title: string
    title_en: string | null
    description: string | null
    description_en: string | null
    cover_image: string | null
    link: string | null
    industryTypeSlug: string
    tags: string[]
    looking_for: string[]
    freelanceId: string | null
    companyId: string | null
    companyJuristicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PortfolioCountAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    title_en?: boolean
    description?: boolean
    description_en?: boolean
    cover_image?: boolean
    link?: boolean
    industryTypeSlug?: boolean
    tags?: boolean
    looking_for?: boolean
    freelanceId?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industryTags?: boolean | Portfolio$industryTagsArgs<ExtArgs>
    industryLookingFor?: boolean | Portfolio$industryLookingForArgs<ExtArgs>
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
    Favorite?: boolean | Portfolio$FavoriteArgs<ExtArgs>
    Image?: boolean | Portfolio$ImageArgs<ExtArgs>
    standards?: boolean | Portfolio$standardsArgs<ExtArgs>
    comments?: boolean | Portfolio$commentsArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    title_en?: boolean
    description?: boolean
    description_en?: boolean
    cover_image?: boolean
    link?: boolean
    industryTypeSlug?: boolean
    tags?: boolean
    looking_for?: boolean
    freelanceId?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    title_en?: boolean
    description?: boolean
    description_en?: boolean
    cover_image?: boolean
    link?: boolean
    industryTypeSlug?: boolean
    tags?: boolean
    looking_for?: boolean
    freelanceId?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectScalar = {
    id?: boolean
    title?: boolean
    title_en?: boolean
    description?: boolean
    description_en?: boolean
    cover_image?: boolean
    link?: boolean
    industryTypeSlug?: boolean
    tags?: boolean
    looking_for?: boolean
    freelanceId?: boolean
    companyId?: boolean
    companyJuristicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "title_en" | "description" | "description_en" | "cover_image" | "link" | "industryTypeSlug" | "tags" | "looking_for" | "freelanceId" | "companyId" | "companyJuristicId" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolio"]>
  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industryTags?: boolean | Portfolio$industryTagsArgs<ExtArgs>
    industryLookingFor?: boolean | Portfolio$industryLookingForArgs<ExtArgs>
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
    Favorite?: boolean | Portfolio$FavoriteArgs<ExtArgs>
    Image?: boolean | Portfolio$ImageArgs<ExtArgs>
    standards?: boolean | Portfolio$standardsArgs<ExtArgs>
    comments?: boolean | Portfolio$commentsArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
  }
  export type PortfolioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelance?: boolean | Portfolio$freelanceArgs<ExtArgs>
    company?: boolean | Portfolio$companyArgs<ExtArgs>
  }

  export type $PortfolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portfolio"
    objects: {
      industryTags: Prisma.$PortfolioTagPayload<ExtArgs>[]
      industryLookingFor: Prisma.$PortfolioLookingForPayload<ExtArgs>[]
      freelance: Prisma.$FreelancePayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
      Favorite: Prisma.$FavoritePayload<ExtArgs>[]
      Image: Prisma.$PortfolioImagePayload<ExtArgs>[]
      standards: Prisma.$PortfolioStandardsPayload<ExtArgs>[]
      comments: Prisma.$PortfolioCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      title_en: string | null
      description: string | null
      description_en: string | null
      cover_image: string | null
      link: string | null
      industryTypeSlug: string
      tags: string[]
      looking_for: string[]
      freelanceId: string | null
      companyId: string | null
      companyJuristicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolio"]>
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> = $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portfolio'], meta: { name: 'Portfolio' } }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioFindManyArgs>(args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
     */
    create<T extends PortfolioCreateArgs>(args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCreateManyArgs>(args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
     */
    delete<T extends PortfolioDeleteArgs>(args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioUpdateArgs>(args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioUpdateManyArgs>(args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios and returns the data updated in the database.
     * @param {PortfolioUpdateManyAndReturnArgs} args - Arguments to update many Portfolios.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portfolio model
   */
  readonly fields: PortfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industryTags<T extends Portfolio$industryTagsArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$industryTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    industryLookingFor<T extends Portfolio$industryLookingForArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$industryLookingForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelance<T extends Portfolio$freelanceArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$freelanceArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends Portfolio$companyArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Favorite<T extends Portfolio$FavoriteArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$FavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Image<T extends Portfolio$ImageArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$ImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standards<T extends Portfolio$standardsArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$standardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Portfolio$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portfolio model
   */
  interface PortfolioFieldRefs {
    readonly id: FieldRef<"Portfolio", 'String'>
    readonly title: FieldRef<"Portfolio", 'String'>
    readonly title_en: FieldRef<"Portfolio", 'String'>
    readonly description: FieldRef<"Portfolio", 'String'>
    readonly description_en: FieldRef<"Portfolio", 'String'>
    readonly cover_image: FieldRef<"Portfolio", 'String'>
    readonly link: FieldRef<"Portfolio", 'String'>
    readonly industryTypeSlug: FieldRef<"Portfolio", 'String'>
    readonly tags: FieldRef<"Portfolio", 'String[]'>
    readonly looking_for: FieldRef<"Portfolio", 'String[]'>
    readonly freelanceId: FieldRef<"Portfolio", 'String'>
    readonly companyId: FieldRef<"Portfolio", 'String'>
    readonly companyJuristicId: FieldRef<"Portfolio", 'String'>
    readonly createdAt: FieldRef<"Portfolio", 'DateTime'>
    readonly updatedAt: FieldRef<"Portfolio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
  }

  /**
   * Portfolio updateManyAndReturn
   */
  export type PortfolioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to delete.
     */
    limit?: number
  }

  /**
   * Portfolio.industryTags
   */
  export type Portfolio$industryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    where?: PortfolioTagWhereInput
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    cursor?: PortfolioTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioTagScalarFieldEnum | PortfolioTagScalarFieldEnum[]
  }

  /**
   * Portfolio.industryLookingFor
   */
  export type Portfolio$industryLookingForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    where?: PortfolioLookingForWhereInput
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    cursor?: PortfolioLookingForWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioLookingForScalarFieldEnum | PortfolioLookingForScalarFieldEnum[]
  }

  /**
   * Portfolio.freelance
   */
  export type Portfolio$freelanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    where?: FreelanceWhereInput
  }

  /**
   * Portfolio.company
   */
  export type Portfolio$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Portfolio.Favorite
   */
  export type Portfolio$FavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Portfolio.Image
   */
  export type Portfolio$ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    where?: PortfolioImageWhereInput
    orderBy?: PortfolioImageOrderByWithRelationInput | PortfolioImageOrderByWithRelationInput[]
    cursor?: PortfolioImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioImageScalarFieldEnum | PortfolioImageScalarFieldEnum[]
  }

  /**
   * Portfolio.standards
   */
  export type Portfolio$standardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    where?: PortfolioStandardsWhereInput
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    cursor?: PortfolioStandardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioStandardsScalarFieldEnum | PortfolioStandardsScalarFieldEnum[]
  }

  /**
   * Portfolio.comments
   */
  export type Portfolio$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    where?: PortfolioCommentWhereInput
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    cursor?: PortfolioCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioTag
   */

  export type AggregatePortfolioTag = {
    _count: PortfolioTagCountAggregateOutputType | null
    _min: PortfolioTagMinAggregateOutputType | null
    _max: PortfolioTagMaxAggregateOutputType | null
  }

  export type PortfolioTagMinAggregateOutputType = {
    portfolioId: string | null
    tagSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioTagMaxAggregateOutputType = {
    portfolioId: string | null
    tagSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioTagCountAggregateOutputType = {
    portfolioId: number
    tagSlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioTagMinAggregateInputType = {
    portfolioId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioTagMaxAggregateInputType = {
    portfolioId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioTagCountAggregateInputType = {
    portfolioId?: true
    tagSlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioTag to aggregate.
     */
    where?: PortfolioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioTags to fetch.
     */
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioTags
    **/
    _count?: true | PortfolioTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioTagMaxAggregateInputType
  }

  export type GetPortfolioTagAggregateType<T extends PortfolioTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioTag[P]>
      : GetScalarType<T[P], AggregatePortfolioTag[P]>
  }




  export type PortfolioTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioTagWhereInput
    orderBy?: PortfolioTagOrderByWithAggregationInput | PortfolioTagOrderByWithAggregationInput[]
    by: PortfolioTagScalarFieldEnum[] | PortfolioTagScalarFieldEnum
    having?: PortfolioTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioTagCountAggregateInputType | true
    _min?: PortfolioTagMinAggregateInputType
    _max?: PortfolioTagMaxAggregateInputType
  }

  export type PortfolioTagGroupByOutputType = {
    portfolioId: string
    tagSlug: string
    createdAt: Date
    updatedAt: Date
    _count: PortfolioTagCountAggregateOutputType | null
    _min: PortfolioTagMinAggregateOutputType | null
    _max: PortfolioTagMaxAggregateOutputType | null
  }

  type GetPortfolioTagGroupByPayload<T extends PortfolioTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioTagGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioTagGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioTag"]>

  export type PortfolioTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioTag"]>

  export type PortfolioTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioTag"]>

  export type PortfolioTagSelectScalar = {
    portfolioId?: boolean
    tagSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"portfolioId" | "tagSlug" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioTag"]>
  export type PortfolioTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PortfolioTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PortfolioTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PortfolioTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioTag"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      portfolioId: string
      tagSlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioTag"]>
    composites: {}
  }

  type PortfolioTagGetPayload<S extends boolean | null | undefined | PortfolioTagDefaultArgs> = $Result.GetResult<Prisma.$PortfolioTagPayload, S>

  type PortfolioTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioTagCountAggregateInputType | true
    }

  export interface PortfolioTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioTag'], meta: { name: 'PortfolioTag' } }
    /**
     * Find zero or one PortfolioTag that matches the filter.
     * @param {PortfolioTagFindUniqueArgs} args - Arguments to find a PortfolioTag
     * @example
     * // Get one PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioTagFindUniqueArgs>(args: SelectSubset<T, PortfolioTagFindUniqueArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioTagFindUniqueOrThrowArgs} args - Arguments to find a PortfolioTag
     * @example
     * // Get one PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagFindFirstArgs} args - Arguments to find a PortfolioTag
     * @example
     * // Get one PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioTagFindFirstArgs>(args?: SelectSubset<T, PortfolioTagFindFirstArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagFindFirstOrThrowArgs} args - Arguments to find a PortfolioTag
     * @example
     * // Get one PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioTags
     * const portfolioTags = await prisma.portfolioTag.findMany()
     * 
     * // Get first 10 PortfolioTags
     * const portfolioTags = await prisma.portfolioTag.findMany({ take: 10 })
     * 
     * // Only select the `portfolioId`
     * const portfolioTagWithPortfolioIdOnly = await prisma.portfolioTag.findMany({ select: { portfolioId: true } })
     * 
     */
    findMany<T extends PortfolioTagFindManyArgs>(args?: SelectSubset<T, PortfolioTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioTag.
     * @param {PortfolioTagCreateArgs} args - Arguments to create a PortfolioTag.
     * @example
     * // Create one PortfolioTag
     * const PortfolioTag = await prisma.portfolioTag.create({
     *   data: {
     *     // ... data to create a PortfolioTag
     *   }
     * })
     * 
     */
    create<T extends PortfolioTagCreateArgs>(args: SelectSubset<T, PortfolioTagCreateArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioTags.
     * @param {PortfolioTagCreateManyArgs} args - Arguments to create many PortfolioTags.
     * @example
     * // Create many PortfolioTags
     * const portfolioTag = await prisma.portfolioTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioTagCreateManyArgs>(args?: SelectSubset<T, PortfolioTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioTags and returns the data saved in the database.
     * @param {PortfolioTagCreateManyAndReturnArgs} args - Arguments to create many PortfolioTags.
     * @example
     * // Create many PortfolioTags
     * const portfolioTag = await prisma.portfolioTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioTags and only return the `portfolioId`
     * const portfolioTagWithPortfolioIdOnly = await prisma.portfolioTag.createManyAndReturn({
     *   select: { portfolioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortfolioTag.
     * @param {PortfolioTagDeleteArgs} args - Arguments to delete one PortfolioTag.
     * @example
     * // Delete one PortfolioTag
     * const PortfolioTag = await prisma.portfolioTag.delete({
     *   where: {
     *     // ... filter to delete one PortfolioTag
     *   }
     * })
     * 
     */
    delete<T extends PortfolioTagDeleteArgs>(args: SelectSubset<T, PortfolioTagDeleteArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioTag.
     * @param {PortfolioTagUpdateArgs} args - Arguments to update one PortfolioTag.
     * @example
     * // Update one PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioTagUpdateArgs>(args: SelectSubset<T, PortfolioTagUpdateArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioTags.
     * @param {PortfolioTagDeleteManyArgs} args - Arguments to filter PortfolioTags to delete.
     * @example
     * // Delete a few PortfolioTags
     * const { count } = await prisma.portfolioTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioTagDeleteManyArgs>(args?: SelectSubset<T, PortfolioTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioTags
     * const portfolioTag = await prisma.portfolioTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioTagUpdateManyArgs>(args: SelectSubset<T, PortfolioTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioTags and returns the data updated in the database.
     * @param {PortfolioTagUpdateManyAndReturnArgs} args - Arguments to update many PortfolioTags.
     * @example
     * // Update many PortfolioTags
     * const portfolioTag = await prisma.portfolioTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortfolioTags and only return the `portfolioId`
     * const portfolioTagWithPortfolioIdOnly = await prisma.portfolioTag.updateManyAndReturn({
     *   select: { portfolioId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortfolioTag.
     * @param {PortfolioTagUpsertArgs} args - Arguments to update or create a PortfolioTag.
     * @example
     * // Update or create a PortfolioTag
     * const portfolioTag = await prisma.portfolioTag.upsert({
     *   create: {
     *     // ... data to create a PortfolioTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioTag we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioTagUpsertArgs>(args: SelectSubset<T, PortfolioTagUpsertArgs<ExtArgs>>): Prisma__PortfolioTagClient<$Result.GetResult<Prisma.$PortfolioTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagCountArgs} args - Arguments to filter PortfolioTags to count.
     * @example
     * // Count the number of PortfolioTags
     * const count = await prisma.portfolioTag.count({
     *   where: {
     *     // ... the filter for the PortfolioTags we want to count
     *   }
     * })
    **/
    count<T extends PortfolioTagCountArgs>(
      args?: Subset<T, PortfolioTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioTagAggregateArgs>(args: Subset<T, PortfolioTagAggregateArgs>): Prisma.PrismaPromise<GetPortfolioTagAggregateType<T>>

    /**
     * Group by PortfolioTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioTagGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioTag model
   */
  readonly fields: PortfolioTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioTag model
   */
  interface PortfolioTagFieldRefs {
    readonly portfolioId: FieldRef<"PortfolioTag", 'String'>
    readonly tagSlug: FieldRef<"PortfolioTag", 'String'>
    readonly createdAt: FieldRef<"PortfolioTag", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioTag findUnique
   */
  export type PortfolioTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTag to fetch.
     */
    where: PortfolioTagWhereUniqueInput
  }

  /**
   * PortfolioTag findUniqueOrThrow
   */
  export type PortfolioTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTag to fetch.
     */
    where: PortfolioTagWhereUniqueInput
  }

  /**
   * PortfolioTag findFirst
   */
  export type PortfolioTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTag to fetch.
     */
    where?: PortfolioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioTags to fetch.
     */
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioTags.
     */
    cursor?: PortfolioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioTags.
     */
    distinct?: PortfolioTagScalarFieldEnum | PortfolioTagScalarFieldEnum[]
  }

  /**
   * PortfolioTag findFirstOrThrow
   */
  export type PortfolioTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTag to fetch.
     */
    where?: PortfolioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioTags to fetch.
     */
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioTags.
     */
    cursor?: PortfolioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioTags.
     */
    distinct?: PortfolioTagScalarFieldEnum | PortfolioTagScalarFieldEnum[]
  }

  /**
   * PortfolioTag findMany
   */
  export type PortfolioTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioTags to fetch.
     */
    where?: PortfolioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioTags to fetch.
     */
    orderBy?: PortfolioTagOrderByWithRelationInput | PortfolioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioTags.
     */
    cursor?: PortfolioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioTags.
     */
    skip?: number
    distinct?: PortfolioTagScalarFieldEnum | PortfolioTagScalarFieldEnum[]
  }

  /**
   * PortfolioTag create
   */
  export type PortfolioTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioTag.
     */
    data: XOR<PortfolioTagCreateInput, PortfolioTagUncheckedCreateInput>
  }

  /**
   * PortfolioTag createMany
   */
  export type PortfolioTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioTags.
     */
    data: PortfolioTagCreateManyInput | PortfolioTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioTag createManyAndReturn
   */
  export type PortfolioTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioTags.
     */
    data: PortfolioTagCreateManyInput | PortfolioTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioTag update
   */
  export type PortfolioTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioTag.
     */
    data: XOR<PortfolioTagUpdateInput, PortfolioTagUncheckedUpdateInput>
    /**
     * Choose, which PortfolioTag to update.
     */
    where: PortfolioTagWhereUniqueInput
  }

  /**
   * PortfolioTag updateMany
   */
  export type PortfolioTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioTags.
     */
    data: XOR<PortfolioTagUpdateManyMutationInput, PortfolioTagUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioTags to update
     */
    where?: PortfolioTagWhereInput
    /**
     * Limit how many PortfolioTags to update.
     */
    limit?: number
  }

  /**
   * PortfolioTag updateManyAndReturn
   */
  export type PortfolioTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioTags.
     */
    data: XOR<PortfolioTagUpdateManyMutationInput, PortfolioTagUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioTags to update
     */
    where?: PortfolioTagWhereInput
    /**
     * Limit how many PortfolioTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioTag upsert
   */
  export type PortfolioTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioTag to update in case it exists.
     */
    where: PortfolioTagWhereUniqueInput
    /**
     * In case the PortfolioTag found by the `where` argument doesn't exist, create a new PortfolioTag with this data.
     */
    create: XOR<PortfolioTagCreateInput, PortfolioTagUncheckedCreateInput>
    /**
     * In case the PortfolioTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioTagUpdateInput, PortfolioTagUncheckedUpdateInput>
  }

  /**
   * PortfolioTag delete
   */
  export type PortfolioTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
    /**
     * Filter which PortfolioTag to delete.
     */
    where: PortfolioTagWhereUniqueInput
  }

  /**
   * PortfolioTag deleteMany
   */
  export type PortfolioTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioTags to delete
     */
    where?: PortfolioTagWhereInput
    /**
     * Limit how many PortfolioTags to delete.
     */
    limit?: number
  }

  /**
   * PortfolioTag without action
   */
  export type PortfolioTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioTag
     */
    select?: PortfolioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioTag
     */
    omit?: PortfolioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioTagInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioLookingFor
   */

  export type AggregatePortfolioLookingFor = {
    _count: PortfolioLookingForCountAggregateOutputType | null
    _min: PortfolioLookingForMinAggregateOutputType | null
    _max: PortfolioLookingForMaxAggregateOutputType | null
  }

  export type PortfolioLookingForMinAggregateOutputType = {
    portfolioId: string | null
    lookingForSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioLookingForMaxAggregateOutputType = {
    portfolioId: string | null
    lookingForSlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioLookingForCountAggregateOutputType = {
    portfolioId: number
    lookingForSlug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioLookingForMinAggregateInputType = {
    portfolioId?: true
    lookingForSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioLookingForMaxAggregateInputType = {
    portfolioId?: true
    lookingForSlug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioLookingForCountAggregateInputType = {
    portfolioId?: true
    lookingForSlug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioLookingForAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioLookingFor to aggregate.
     */
    where?: PortfolioLookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioLookingFors to fetch.
     */
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioLookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioLookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioLookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioLookingFors
    **/
    _count?: true | PortfolioLookingForCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioLookingForMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioLookingForMaxAggregateInputType
  }

  export type GetPortfolioLookingForAggregateType<T extends PortfolioLookingForAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioLookingFor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioLookingFor[P]>
      : GetScalarType<T[P], AggregatePortfolioLookingFor[P]>
  }




  export type PortfolioLookingForGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioLookingForWhereInput
    orderBy?: PortfolioLookingForOrderByWithAggregationInput | PortfolioLookingForOrderByWithAggregationInput[]
    by: PortfolioLookingForScalarFieldEnum[] | PortfolioLookingForScalarFieldEnum
    having?: PortfolioLookingForScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioLookingForCountAggregateInputType | true
    _min?: PortfolioLookingForMinAggregateInputType
    _max?: PortfolioLookingForMaxAggregateInputType
  }

  export type PortfolioLookingForGroupByOutputType = {
    portfolioId: string
    lookingForSlug: string
    createdAt: Date
    updatedAt: Date
    _count: PortfolioLookingForCountAggregateOutputType | null
    _min: PortfolioLookingForMinAggregateOutputType | null
    _max: PortfolioLookingForMaxAggregateOutputType | null
  }

  type GetPortfolioLookingForGroupByPayload<T extends PortfolioLookingForGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioLookingForGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioLookingForGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioLookingForGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioLookingForGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioLookingForSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    lookingForSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioLookingFor"]>

  export type PortfolioLookingForSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    lookingForSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioLookingFor"]>

  export type PortfolioLookingForSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    portfolioId?: boolean
    lookingForSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioLookingFor"]>

  export type PortfolioLookingForSelectScalar = {
    portfolioId?: boolean
    lookingForSlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioLookingForOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"portfolioId" | "lookingForSlug" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioLookingFor"]>
  export type PortfolioLookingForInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }
  export type PortfolioLookingForIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }
  export type PortfolioLookingForIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    lookingFor?: boolean | LookingForDefaultArgs<ExtArgs>
  }

  export type $PortfolioLookingForPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioLookingFor"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      lookingFor: Prisma.$LookingForPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      portfolioId: string
      lookingForSlug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioLookingFor"]>
    composites: {}
  }

  type PortfolioLookingForGetPayload<S extends boolean | null | undefined | PortfolioLookingForDefaultArgs> = $Result.GetResult<Prisma.$PortfolioLookingForPayload, S>

  type PortfolioLookingForCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioLookingForFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioLookingForCountAggregateInputType | true
    }

  export interface PortfolioLookingForDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioLookingFor'], meta: { name: 'PortfolioLookingFor' } }
    /**
     * Find zero or one PortfolioLookingFor that matches the filter.
     * @param {PortfolioLookingForFindUniqueArgs} args - Arguments to find a PortfolioLookingFor
     * @example
     * // Get one PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioLookingForFindUniqueArgs>(args: SelectSubset<T, PortfolioLookingForFindUniqueArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioLookingFor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioLookingForFindUniqueOrThrowArgs} args - Arguments to find a PortfolioLookingFor
     * @example
     * // Get one PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioLookingForFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioLookingForFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioLookingFor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForFindFirstArgs} args - Arguments to find a PortfolioLookingFor
     * @example
     * // Get one PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioLookingForFindFirstArgs>(args?: SelectSubset<T, PortfolioLookingForFindFirstArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioLookingFor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForFindFirstOrThrowArgs} args - Arguments to find a PortfolioLookingFor
     * @example
     * // Get one PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioLookingForFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioLookingForFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioLookingFors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioLookingFors
     * const portfolioLookingFors = await prisma.portfolioLookingFor.findMany()
     * 
     * // Get first 10 PortfolioLookingFors
     * const portfolioLookingFors = await prisma.portfolioLookingFor.findMany({ take: 10 })
     * 
     * // Only select the `portfolioId`
     * const portfolioLookingForWithPortfolioIdOnly = await prisma.portfolioLookingFor.findMany({ select: { portfolioId: true } })
     * 
     */
    findMany<T extends PortfolioLookingForFindManyArgs>(args?: SelectSubset<T, PortfolioLookingForFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioLookingFor.
     * @param {PortfolioLookingForCreateArgs} args - Arguments to create a PortfolioLookingFor.
     * @example
     * // Create one PortfolioLookingFor
     * const PortfolioLookingFor = await prisma.portfolioLookingFor.create({
     *   data: {
     *     // ... data to create a PortfolioLookingFor
     *   }
     * })
     * 
     */
    create<T extends PortfolioLookingForCreateArgs>(args: SelectSubset<T, PortfolioLookingForCreateArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioLookingFors.
     * @param {PortfolioLookingForCreateManyArgs} args - Arguments to create many PortfolioLookingFors.
     * @example
     * // Create many PortfolioLookingFors
     * const portfolioLookingFor = await prisma.portfolioLookingFor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioLookingForCreateManyArgs>(args?: SelectSubset<T, PortfolioLookingForCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioLookingFors and returns the data saved in the database.
     * @param {PortfolioLookingForCreateManyAndReturnArgs} args - Arguments to create many PortfolioLookingFors.
     * @example
     * // Create many PortfolioLookingFors
     * const portfolioLookingFor = await prisma.portfolioLookingFor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioLookingFors and only return the `portfolioId`
     * const portfolioLookingForWithPortfolioIdOnly = await prisma.portfolioLookingFor.createManyAndReturn({
     *   select: { portfolioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioLookingForCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioLookingForCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortfolioLookingFor.
     * @param {PortfolioLookingForDeleteArgs} args - Arguments to delete one PortfolioLookingFor.
     * @example
     * // Delete one PortfolioLookingFor
     * const PortfolioLookingFor = await prisma.portfolioLookingFor.delete({
     *   where: {
     *     // ... filter to delete one PortfolioLookingFor
     *   }
     * })
     * 
     */
    delete<T extends PortfolioLookingForDeleteArgs>(args: SelectSubset<T, PortfolioLookingForDeleteArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioLookingFor.
     * @param {PortfolioLookingForUpdateArgs} args - Arguments to update one PortfolioLookingFor.
     * @example
     * // Update one PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioLookingForUpdateArgs>(args: SelectSubset<T, PortfolioLookingForUpdateArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioLookingFors.
     * @param {PortfolioLookingForDeleteManyArgs} args - Arguments to filter PortfolioLookingFors to delete.
     * @example
     * // Delete a few PortfolioLookingFors
     * const { count } = await prisma.portfolioLookingFor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioLookingForDeleteManyArgs>(args?: SelectSubset<T, PortfolioLookingForDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioLookingFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioLookingFors
     * const portfolioLookingFor = await prisma.portfolioLookingFor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioLookingForUpdateManyArgs>(args: SelectSubset<T, PortfolioLookingForUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioLookingFors and returns the data updated in the database.
     * @param {PortfolioLookingForUpdateManyAndReturnArgs} args - Arguments to update many PortfolioLookingFors.
     * @example
     * // Update many PortfolioLookingFors
     * const portfolioLookingFor = await prisma.portfolioLookingFor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortfolioLookingFors and only return the `portfolioId`
     * const portfolioLookingForWithPortfolioIdOnly = await prisma.portfolioLookingFor.updateManyAndReturn({
     *   select: { portfolioId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioLookingForUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioLookingForUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortfolioLookingFor.
     * @param {PortfolioLookingForUpsertArgs} args - Arguments to update or create a PortfolioLookingFor.
     * @example
     * // Update or create a PortfolioLookingFor
     * const portfolioLookingFor = await prisma.portfolioLookingFor.upsert({
     *   create: {
     *     // ... data to create a PortfolioLookingFor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioLookingFor we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioLookingForUpsertArgs>(args: SelectSubset<T, PortfolioLookingForUpsertArgs<ExtArgs>>): Prisma__PortfolioLookingForClient<$Result.GetResult<Prisma.$PortfolioLookingForPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioLookingFors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForCountArgs} args - Arguments to filter PortfolioLookingFors to count.
     * @example
     * // Count the number of PortfolioLookingFors
     * const count = await prisma.portfolioLookingFor.count({
     *   where: {
     *     // ... the filter for the PortfolioLookingFors we want to count
     *   }
     * })
    **/
    count<T extends PortfolioLookingForCountArgs>(
      args?: Subset<T, PortfolioLookingForCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioLookingForCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioLookingFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioLookingForAggregateArgs>(args: Subset<T, PortfolioLookingForAggregateArgs>): Prisma.PrismaPromise<GetPortfolioLookingForAggregateType<T>>

    /**
     * Group by PortfolioLookingFor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioLookingForGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioLookingForGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioLookingForGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioLookingForGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioLookingForGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioLookingForGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioLookingFor model
   */
  readonly fields: PortfolioLookingForFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioLookingFor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioLookingForClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lookingFor<T extends LookingForDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LookingForDefaultArgs<ExtArgs>>): Prisma__LookingForClient<$Result.GetResult<Prisma.$LookingForPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioLookingFor model
   */
  interface PortfolioLookingForFieldRefs {
    readonly portfolioId: FieldRef<"PortfolioLookingFor", 'String'>
    readonly lookingForSlug: FieldRef<"PortfolioLookingFor", 'String'>
    readonly createdAt: FieldRef<"PortfolioLookingFor", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioLookingFor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioLookingFor findUnique
   */
  export type PortfolioLookingForFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioLookingFor to fetch.
     */
    where: PortfolioLookingForWhereUniqueInput
  }

  /**
   * PortfolioLookingFor findUniqueOrThrow
   */
  export type PortfolioLookingForFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioLookingFor to fetch.
     */
    where: PortfolioLookingForWhereUniqueInput
  }

  /**
   * PortfolioLookingFor findFirst
   */
  export type PortfolioLookingForFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioLookingFor to fetch.
     */
    where?: PortfolioLookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioLookingFors to fetch.
     */
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioLookingFors.
     */
    cursor?: PortfolioLookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioLookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioLookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioLookingFors.
     */
    distinct?: PortfolioLookingForScalarFieldEnum | PortfolioLookingForScalarFieldEnum[]
  }

  /**
   * PortfolioLookingFor findFirstOrThrow
   */
  export type PortfolioLookingForFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioLookingFor to fetch.
     */
    where?: PortfolioLookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioLookingFors to fetch.
     */
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioLookingFors.
     */
    cursor?: PortfolioLookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioLookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioLookingFors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioLookingFors.
     */
    distinct?: PortfolioLookingForScalarFieldEnum | PortfolioLookingForScalarFieldEnum[]
  }

  /**
   * PortfolioLookingFor findMany
   */
  export type PortfolioLookingForFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioLookingFors to fetch.
     */
    where?: PortfolioLookingForWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioLookingFors to fetch.
     */
    orderBy?: PortfolioLookingForOrderByWithRelationInput | PortfolioLookingForOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioLookingFors.
     */
    cursor?: PortfolioLookingForWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioLookingFors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioLookingFors.
     */
    skip?: number
    distinct?: PortfolioLookingForScalarFieldEnum | PortfolioLookingForScalarFieldEnum[]
  }

  /**
   * PortfolioLookingFor create
   */
  export type PortfolioLookingForCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioLookingFor.
     */
    data: XOR<PortfolioLookingForCreateInput, PortfolioLookingForUncheckedCreateInput>
  }

  /**
   * PortfolioLookingFor createMany
   */
  export type PortfolioLookingForCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioLookingFors.
     */
    data: PortfolioLookingForCreateManyInput | PortfolioLookingForCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioLookingFor createManyAndReturn
   */
  export type PortfolioLookingForCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioLookingFors.
     */
    data: PortfolioLookingForCreateManyInput | PortfolioLookingForCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioLookingFor update
   */
  export type PortfolioLookingForUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioLookingFor.
     */
    data: XOR<PortfolioLookingForUpdateInput, PortfolioLookingForUncheckedUpdateInput>
    /**
     * Choose, which PortfolioLookingFor to update.
     */
    where: PortfolioLookingForWhereUniqueInput
  }

  /**
   * PortfolioLookingFor updateMany
   */
  export type PortfolioLookingForUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioLookingFors.
     */
    data: XOR<PortfolioLookingForUpdateManyMutationInput, PortfolioLookingForUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioLookingFors to update
     */
    where?: PortfolioLookingForWhereInput
    /**
     * Limit how many PortfolioLookingFors to update.
     */
    limit?: number
  }

  /**
   * PortfolioLookingFor updateManyAndReturn
   */
  export type PortfolioLookingForUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioLookingFors.
     */
    data: XOR<PortfolioLookingForUpdateManyMutationInput, PortfolioLookingForUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioLookingFors to update
     */
    where?: PortfolioLookingForWhereInput
    /**
     * Limit how many PortfolioLookingFors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioLookingFor upsert
   */
  export type PortfolioLookingForUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioLookingFor to update in case it exists.
     */
    where: PortfolioLookingForWhereUniqueInput
    /**
     * In case the PortfolioLookingFor found by the `where` argument doesn't exist, create a new PortfolioLookingFor with this data.
     */
    create: XOR<PortfolioLookingForCreateInput, PortfolioLookingForUncheckedCreateInput>
    /**
     * In case the PortfolioLookingFor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioLookingForUpdateInput, PortfolioLookingForUncheckedUpdateInput>
  }

  /**
   * PortfolioLookingFor delete
   */
  export type PortfolioLookingForDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
    /**
     * Filter which PortfolioLookingFor to delete.
     */
    where: PortfolioLookingForWhereUniqueInput
  }

  /**
   * PortfolioLookingFor deleteMany
   */
  export type PortfolioLookingForDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioLookingFors to delete
     */
    where?: PortfolioLookingForWhereInput
    /**
     * Limit how many PortfolioLookingFors to delete.
     */
    limit?: number
  }

  /**
   * PortfolioLookingFor without action
   */
  export type PortfolioLookingForDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioLookingFor
     */
    select?: PortfolioLookingForSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioLookingFor
     */
    omit?: PortfolioLookingForOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioLookingForInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioStandards
   */

  export type AggregatePortfolioStandards = {
    _count: PortfolioStandardsCountAggregateOutputType | null
    _min: PortfolioStandardsMinAggregateOutputType | null
    _max: PortfolioStandardsMaxAggregateOutputType | null
  }

  export type PortfolioStandardsMinAggregateOutputType = {
    id: string | null
    portfolioId: string | null
    standardsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioStandardsMaxAggregateOutputType = {
    id: string | null
    portfolioId: string | null
    standardsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioStandardsCountAggregateOutputType = {
    id: number
    portfolioId: number
    standardsId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioStandardsMinAggregateInputType = {
    id?: true
    portfolioId?: true
    standardsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioStandardsMaxAggregateInputType = {
    id?: true
    portfolioId?: true
    standardsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioStandardsCountAggregateInputType = {
    id?: true
    portfolioId?: true
    standardsId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioStandardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioStandards to aggregate.
     */
    where?: PortfolioStandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioStandards to fetch.
     */
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioStandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioStandards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioStandards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioStandards
    **/
    _count?: true | PortfolioStandardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioStandardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioStandardsMaxAggregateInputType
  }

  export type GetPortfolioStandardsAggregateType<T extends PortfolioStandardsAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioStandards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioStandards[P]>
      : GetScalarType<T[P], AggregatePortfolioStandards[P]>
  }




  export type PortfolioStandardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioStandardsWhereInput
    orderBy?: PortfolioStandardsOrderByWithAggregationInput | PortfolioStandardsOrderByWithAggregationInput[]
    by: PortfolioStandardsScalarFieldEnum[] | PortfolioStandardsScalarFieldEnum
    having?: PortfolioStandardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioStandardsCountAggregateInputType | true
    _min?: PortfolioStandardsMinAggregateInputType
    _max?: PortfolioStandardsMaxAggregateInputType
  }

  export type PortfolioStandardsGroupByOutputType = {
    id: string
    portfolioId: string
    standardsId: string
    createdAt: Date
    updatedAt: Date
    _count: PortfolioStandardsCountAggregateOutputType | null
    _min: PortfolioStandardsMinAggregateOutputType | null
    _max: PortfolioStandardsMaxAggregateOutputType | null
  }

  type GetPortfolioStandardsGroupByPayload<T extends PortfolioStandardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioStandardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioStandardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioStandardsGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioStandardsGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioStandardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    standardsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioStandards"]>

  export type PortfolioStandardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    standardsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioStandards"]>

  export type PortfolioStandardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    standardsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioStandards"]>

  export type PortfolioStandardsSelectScalar = {
    id?: boolean
    portfolioId?: boolean
    standardsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioStandardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portfolioId" | "standardsId" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioStandards"]>
  export type PortfolioStandardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }
  export type PortfolioStandardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }
  export type PortfolioStandardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    standards?: boolean | StandardsDefaultArgs<ExtArgs>
  }

  export type $PortfolioStandardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioStandards"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      standards: Prisma.$StandardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portfolioId: string
      standardsId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioStandards"]>
    composites: {}
  }

  type PortfolioStandardsGetPayload<S extends boolean | null | undefined | PortfolioStandardsDefaultArgs> = $Result.GetResult<Prisma.$PortfolioStandardsPayload, S>

  type PortfolioStandardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioStandardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioStandardsCountAggregateInputType | true
    }

  export interface PortfolioStandardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioStandards'], meta: { name: 'PortfolioStandards' } }
    /**
     * Find zero or one PortfolioStandards that matches the filter.
     * @param {PortfolioStandardsFindUniqueArgs} args - Arguments to find a PortfolioStandards
     * @example
     * // Get one PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioStandardsFindUniqueArgs>(args: SelectSubset<T, PortfolioStandardsFindUniqueArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioStandards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioStandardsFindUniqueOrThrowArgs} args - Arguments to find a PortfolioStandards
     * @example
     * // Get one PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioStandardsFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioStandardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioStandards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsFindFirstArgs} args - Arguments to find a PortfolioStandards
     * @example
     * // Get one PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioStandardsFindFirstArgs>(args?: SelectSubset<T, PortfolioStandardsFindFirstArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioStandards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsFindFirstOrThrowArgs} args - Arguments to find a PortfolioStandards
     * @example
     * // Get one PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioStandardsFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioStandardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioStandards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findMany()
     * 
     * // Get first 10 PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioStandardsWithIdOnly = await prisma.portfolioStandards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioStandardsFindManyArgs>(args?: SelectSubset<T, PortfolioStandardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioStandards.
     * @param {PortfolioStandardsCreateArgs} args - Arguments to create a PortfolioStandards.
     * @example
     * // Create one PortfolioStandards
     * const PortfolioStandards = await prisma.portfolioStandards.create({
     *   data: {
     *     // ... data to create a PortfolioStandards
     *   }
     * })
     * 
     */
    create<T extends PortfolioStandardsCreateArgs>(args: SelectSubset<T, PortfolioStandardsCreateArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioStandards.
     * @param {PortfolioStandardsCreateManyArgs} args - Arguments to create many PortfolioStandards.
     * @example
     * // Create many PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioStandardsCreateManyArgs>(args?: SelectSubset<T, PortfolioStandardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioStandards and returns the data saved in the database.
     * @param {PortfolioStandardsCreateManyAndReturnArgs} args - Arguments to create many PortfolioStandards.
     * @example
     * // Create many PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioStandards and only return the `id`
     * const portfolioStandardsWithIdOnly = await prisma.portfolioStandards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioStandardsCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioStandardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortfolioStandards.
     * @param {PortfolioStandardsDeleteArgs} args - Arguments to delete one PortfolioStandards.
     * @example
     * // Delete one PortfolioStandards
     * const PortfolioStandards = await prisma.portfolioStandards.delete({
     *   where: {
     *     // ... filter to delete one PortfolioStandards
     *   }
     * })
     * 
     */
    delete<T extends PortfolioStandardsDeleteArgs>(args: SelectSubset<T, PortfolioStandardsDeleteArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioStandards.
     * @param {PortfolioStandardsUpdateArgs} args - Arguments to update one PortfolioStandards.
     * @example
     * // Update one PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioStandardsUpdateArgs>(args: SelectSubset<T, PortfolioStandardsUpdateArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioStandards.
     * @param {PortfolioStandardsDeleteManyArgs} args - Arguments to filter PortfolioStandards to delete.
     * @example
     * // Delete a few PortfolioStandards
     * const { count } = await prisma.portfolioStandards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioStandardsDeleteManyArgs>(args?: SelectSubset<T, PortfolioStandardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioStandards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioStandardsUpdateManyArgs>(args: SelectSubset<T, PortfolioStandardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioStandards and returns the data updated in the database.
     * @param {PortfolioStandardsUpdateManyAndReturnArgs} args - Arguments to update many PortfolioStandards.
     * @example
     * // Update many PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortfolioStandards and only return the `id`
     * const portfolioStandardsWithIdOnly = await prisma.portfolioStandards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioStandardsUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioStandardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortfolioStandards.
     * @param {PortfolioStandardsUpsertArgs} args - Arguments to update or create a PortfolioStandards.
     * @example
     * // Update or create a PortfolioStandards
     * const portfolioStandards = await prisma.portfolioStandards.upsert({
     *   create: {
     *     // ... data to create a PortfolioStandards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioStandards we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioStandardsUpsertArgs>(args: SelectSubset<T, PortfolioStandardsUpsertArgs<ExtArgs>>): Prisma__PortfolioStandardsClient<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioStandards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsCountArgs} args - Arguments to filter PortfolioStandards to count.
     * @example
     * // Count the number of PortfolioStandards
     * const count = await prisma.portfolioStandards.count({
     *   where: {
     *     // ... the filter for the PortfolioStandards we want to count
     *   }
     * })
    **/
    count<T extends PortfolioStandardsCountArgs>(
      args?: Subset<T, PortfolioStandardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioStandardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioStandards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioStandardsAggregateArgs>(args: Subset<T, PortfolioStandardsAggregateArgs>): Prisma.PrismaPromise<GetPortfolioStandardsAggregateType<T>>

    /**
     * Group by PortfolioStandards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioStandardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioStandardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioStandardsGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioStandardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioStandardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioStandardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioStandards model
   */
  readonly fields: PortfolioStandardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioStandards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioStandardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    standards<T extends StandardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardsDefaultArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioStandards model
   */
  interface PortfolioStandardsFieldRefs {
    readonly id: FieldRef<"PortfolioStandards", 'String'>
    readonly portfolioId: FieldRef<"PortfolioStandards", 'String'>
    readonly standardsId: FieldRef<"PortfolioStandards", 'String'>
    readonly createdAt: FieldRef<"PortfolioStandards", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioStandards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioStandards findUnique
   */
  export type PortfolioStandardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioStandards to fetch.
     */
    where: PortfolioStandardsWhereUniqueInput
  }

  /**
   * PortfolioStandards findUniqueOrThrow
   */
  export type PortfolioStandardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioStandards to fetch.
     */
    where: PortfolioStandardsWhereUniqueInput
  }

  /**
   * PortfolioStandards findFirst
   */
  export type PortfolioStandardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioStandards to fetch.
     */
    where?: PortfolioStandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioStandards to fetch.
     */
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioStandards.
     */
    cursor?: PortfolioStandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioStandards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioStandards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioStandards.
     */
    distinct?: PortfolioStandardsScalarFieldEnum | PortfolioStandardsScalarFieldEnum[]
  }

  /**
   * PortfolioStandards findFirstOrThrow
   */
  export type PortfolioStandardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioStandards to fetch.
     */
    where?: PortfolioStandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioStandards to fetch.
     */
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioStandards.
     */
    cursor?: PortfolioStandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioStandards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioStandards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioStandards.
     */
    distinct?: PortfolioStandardsScalarFieldEnum | PortfolioStandardsScalarFieldEnum[]
  }

  /**
   * PortfolioStandards findMany
   */
  export type PortfolioStandardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioStandards to fetch.
     */
    where?: PortfolioStandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioStandards to fetch.
     */
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioStandards.
     */
    cursor?: PortfolioStandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioStandards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioStandards.
     */
    skip?: number
    distinct?: PortfolioStandardsScalarFieldEnum | PortfolioStandardsScalarFieldEnum[]
  }

  /**
   * PortfolioStandards create
   */
  export type PortfolioStandardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioStandards.
     */
    data: XOR<PortfolioStandardsCreateInput, PortfolioStandardsUncheckedCreateInput>
  }

  /**
   * PortfolioStandards createMany
   */
  export type PortfolioStandardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioStandards.
     */
    data: PortfolioStandardsCreateManyInput | PortfolioStandardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioStandards createManyAndReturn
   */
  export type PortfolioStandardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioStandards.
     */
    data: PortfolioStandardsCreateManyInput | PortfolioStandardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioStandards update
   */
  export type PortfolioStandardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioStandards.
     */
    data: XOR<PortfolioStandardsUpdateInput, PortfolioStandardsUncheckedUpdateInput>
    /**
     * Choose, which PortfolioStandards to update.
     */
    where: PortfolioStandardsWhereUniqueInput
  }

  /**
   * PortfolioStandards updateMany
   */
  export type PortfolioStandardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioStandards.
     */
    data: XOR<PortfolioStandardsUpdateManyMutationInput, PortfolioStandardsUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioStandards to update
     */
    where?: PortfolioStandardsWhereInput
    /**
     * Limit how many PortfolioStandards to update.
     */
    limit?: number
  }

  /**
   * PortfolioStandards updateManyAndReturn
   */
  export type PortfolioStandardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioStandards.
     */
    data: XOR<PortfolioStandardsUpdateManyMutationInput, PortfolioStandardsUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioStandards to update
     */
    where?: PortfolioStandardsWhereInput
    /**
     * Limit how many PortfolioStandards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioStandards upsert
   */
  export type PortfolioStandardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioStandards to update in case it exists.
     */
    where: PortfolioStandardsWhereUniqueInput
    /**
     * In case the PortfolioStandards found by the `where` argument doesn't exist, create a new PortfolioStandards with this data.
     */
    create: XOR<PortfolioStandardsCreateInput, PortfolioStandardsUncheckedCreateInput>
    /**
     * In case the PortfolioStandards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioStandardsUpdateInput, PortfolioStandardsUncheckedUpdateInput>
  }

  /**
   * PortfolioStandards delete
   */
  export type PortfolioStandardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    /**
     * Filter which PortfolioStandards to delete.
     */
    where: PortfolioStandardsWhereUniqueInput
  }

  /**
   * PortfolioStandards deleteMany
   */
  export type PortfolioStandardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioStandards to delete
     */
    where?: PortfolioStandardsWhereInput
    /**
     * Limit how many PortfolioStandards to delete.
     */
    limit?: number
  }

  /**
   * PortfolioStandards without action
   */
  export type PortfolioStandardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioImage
   */

  export type AggregatePortfolioImage = {
    _count: PortfolioImageCountAggregateOutputType | null
    _min: PortfolioImageMinAggregateOutputType | null
    _max: PortfolioImageMaxAggregateOutputType | null
  }

  export type PortfolioImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    description: string | null
    type: $Enums.PortfolioImageType | null
    portfolioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    description: string | null
    type: $Enums.PortfolioImageType | null
    portfolioId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioImageCountAggregateOutputType = {
    id: number
    url: number
    description: number
    type: number
    portfolioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioImageMinAggregateInputType = {
    id?: true
    url?: true
    description?: true
    type?: true
    portfolioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioImageMaxAggregateInputType = {
    id?: true
    url?: true
    description?: true
    type?: true
    portfolioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioImageCountAggregateInputType = {
    id?: true
    url?: true
    description?: true
    type?: true
    portfolioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioImage to aggregate.
     */
    where?: PortfolioImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioImages to fetch.
     */
    orderBy?: PortfolioImageOrderByWithRelationInput | PortfolioImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioImages
    **/
    _count?: true | PortfolioImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioImageMaxAggregateInputType
  }

  export type GetPortfolioImageAggregateType<T extends PortfolioImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioImage[P]>
      : GetScalarType<T[P], AggregatePortfolioImage[P]>
  }




  export type PortfolioImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioImageWhereInput
    orderBy?: PortfolioImageOrderByWithAggregationInput | PortfolioImageOrderByWithAggregationInput[]
    by: PortfolioImageScalarFieldEnum[] | PortfolioImageScalarFieldEnum
    having?: PortfolioImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioImageCountAggregateInputType | true
    _min?: PortfolioImageMinAggregateInputType
    _max?: PortfolioImageMaxAggregateInputType
  }

  export type PortfolioImageGroupByOutputType = {
    id: string
    url: string
    description: string | null
    type: $Enums.PortfolioImageType
    portfolioId: string
    createdAt: Date
    updatedAt: Date
    _count: PortfolioImageCountAggregateOutputType | null
    _min: PortfolioImageMinAggregateOutputType | null
    _max: PortfolioImageMaxAggregateOutputType | null
  }

  type GetPortfolioImageGroupByPayload<T extends PortfolioImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioImageGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioImageGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    type?: boolean
    portfolioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioImage"]>

  export type PortfolioImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    type?: boolean
    portfolioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioImage"]>

  export type PortfolioImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    type?: boolean
    portfolioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioImage"]>

  export type PortfolioImageSelectScalar = {
    id?: boolean
    url?: boolean
    description?: boolean
    type?: boolean
    portfolioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "description" | "type" | "portfolioId" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioImage"]>
  export type PortfolioImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }
  export type PortfolioImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
  }

  export type $PortfolioImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioImage"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      description: string | null
      type: $Enums.PortfolioImageType
      portfolioId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioImage"]>
    composites: {}
  }

  type PortfolioImageGetPayload<S extends boolean | null | undefined | PortfolioImageDefaultArgs> = $Result.GetResult<Prisma.$PortfolioImagePayload, S>

  type PortfolioImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioImageCountAggregateInputType | true
    }

  export interface PortfolioImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioImage'], meta: { name: 'PortfolioImage' } }
    /**
     * Find zero or one PortfolioImage that matches the filter.
     * @param {PortfolioImageFindUniqueArgs} args - Arguments to find a PortfolioImage
     * @example
     * // Get one PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioImageFindUniqueArgs>(args: SelectSubset<T, PortfolioImageFindUniqueArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioImageFindUniqueOrThrowArgs} args - Arguments to find a PortfolioImage
     * @example
     * // Get one PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageFindFirstArgs} args - Arguments to find a PortfolioImage
     * @example
     * // Get one PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioImageFindFirstArgs>(args?: SelectSubset<T, PortfolioImageFindFirstArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageFindFirstOrThrowArgs} args - Arguments to find a PortfolioImage
     * @example
     * // Get one PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioImages
     * const portfolioImages = await prisma.portfolioImage.findMany()
     * 
     * // Get first 10 PortfolioImages
     * const portfolioImages = await prisma.portfolioImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioImageWithIdOnly = await prisma.portfolioImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioImageFindManyArgs>(args?: SelectSubset<T, PortfolioImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioImage.
     * @param {PortfolioImageCreateArgs} args - Arguments to create a PortfolioImage.
     * @example
     * // Create one PortfolioImage
     * const PortfolioImage = await prisma.portfolioImage.create({
     *   data: {
     *     // ... data to create a PortfolioImage
     *   }
     * })
     * 
     */
    create<T extends PortfolioImageCreateArgs>(args: SelectSubset<T, PortfolioImageCreateArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioImages.
     * @param {PortfolioImageCreateManyArgs} args - Arguments to create many PortfolioImages.
     * @example
     * // Create many PortfolioImages
     * const portfolioImage = await prisma.portfolioImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioImageCreateManyArgs>(args?: SelectSubset<T, PortfolioImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioImages and returns the data saved in the database.
     * @param {PortfolioImageCreateManyAndReturnArgs} args - Arguments to create many PortfolioImages.
     * @example
     * // Create many PortfolioImages
     * const portfolioImage = await prisma.portfolioImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioImages and only return the `id`
     * const portfolioImageWithIdOnly = await prisma.portfolioImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortfolioImage.
     * @param {PortfolioImageDeleteArgs} args - Arguments to delete one PortfolioImage.
     * @example
     * // Delete one PortfolioImage
     * const PortfolioImage = await prisma.portfolioImage.delete({
     *   where: {
     *     // ... filter to delete one PortfolioImage
     *   }
     * })
     * 
     */
    delete<T extends PortfolioImageDeleteArgs>(args: SelectSubset<T, PortfolioImageDeleteArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioImage.
     * @param {PortfolioImageUpdateArgs} args - Arguments to update one PortfolioImage.
     * @example
     * // Update one PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioImageUpdateArgs>(args: SelectSubset<T, PortfolioImageUpdateArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioImages.
     * @param {PortfolioImageDeleteManyArgs} args - Arguments to filter PortfolioImages to delete.
     * @example
     * // Delete a few PortfolioImages
     * const { count } = await prisma.portfolioImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioImageDeleteManyArgs>(args?: SelectSubset<T, PortfolioImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioImages
     * const portfolioImage = await prisma.portfolioImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioImageUpdateManyArgs>(args: SelectSubset<T, PortfolioImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioImages and returns the data updated in the database.
     * @param {PortfolioImageUpdateManyAndReturnArgs} args - Arguments to update many PortfolioImages.
     * @example
     * // Update many PortfolioImages
     * const portfolioImage = await prisma.portfolioImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortfolioImages and only return the `id`
     * const portfolioImageWithIdOnly = await prisma.portfolioImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortfolioImage.
     * @param {PortfolioImageUpsertArgs} args - Arguments to update or create a PortfolioImage.
     * @example
     * // Update or create a PortfolioImage
     * const portfolioImage = await prisma.portfolioImage.upsert({
     *   create: {
     *     // ... data to create a PortfolioImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioImage we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioImageUpsertArgs>(args: SelectSubset<T, PortfolioImageUpsertArgs<ExtArgs>>): Prisma__PortfolioImageClient<$Result.GetResult<Prisma.$PortfolioImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageCountArgs} args - Arguments to filter PortfolioImages to count.
     * @example
     * // Count the number of PortfolioImages
     * const count = await prisma.portfolioImage.count({
     *   where: {
     *     // ... the filter for the PortfolioImages we want to count
     *   }
     * })
    **/
    count<T extends PortfolioImageCountArgs>(
      args?: Subset<T, PortfolioImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioImageAggregateArgs>(args: Subset<T, PortfolioImageAggregateArgs>): Prisma.PrismaPromise<GetPortfolioImageAggregateType<T>>

    /**
     * Group by PortfolioImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioImageGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioImage model
   */
  readonly fields: PortfolioImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioImage model
   */
  interface PortfolioImageFieldRefs {
    readonly id: FieldRef<"PortfolioImage", 'String'>
    readonly url: FieldRef<"PortfolioImage", 'String'>
    readonly description: FieldRef<"PortfolioImage", 'String'>
    readonly type: FieldRef<"PortfolioImage", 'PortfolioImageType'>
    readonly portfolioId: FieldRef<"PortfolioImage", 'String'>
    readonly createdAt: FieldRef<"PortfolioImage", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioImage findUnique
   */
  export type PortfolioImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioImage to fetch.
     */
    where: PortfolioImageWhereUniqueInput
  }

  /**
   * PortfolioImage findUniqueOrThrow
   */
  export type PortfolioImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioImage to fetch.
     */
    where: PortfolioImageWhereUniqueInput
  }

  /**
   * PortfolioImage findFirst
   */
  export type PortfolioImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioImage to fetch.
     */
    where?: PortfolioImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioImages to fetch.
     */
    orderBy?: PortfolioImageOrderByWithRelationInput | PortfolioImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioImages.
     */
    cursor?: PortfolioImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioImages.
     */
    distinct?: PortfolioImageScalarFieldEnum | PortfolioImageScalarFieldEnum[]
  }

  /**
   * PortfolioImage findFirstOrThrow
   */
  export type PortfolioImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioImage to fetch.
     */
    where?: PortfolioImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioImages to fetch.
     */
    orderBy?: PortfolioImageOrderByWithRelationInput | PortfolioImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioImages.
     */
    cursor?: PortfolioImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioImages.
     */
    distinct?: PortfolioImageScalarFieldEnum | PortfolioImageScalarFieldEnum[]
  }

  /**
   * PortfolioImage findMany
   */
  export type PortfolioImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioImages to fetch.
     */
    where?: PortfolioImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioImages to fetch.
     */
    orderBy?: PortfolioImageOrderByWithRelationInput | PortfolioImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioImages.
     */
    cursor?: PortfolioImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioImages.
     */
    skip?: number
    distinct?: PortfolioImageScalarFieldEnum | PortfolioImageScalarFieldEnum[]
  }

  /**
   * PortfolioImage create
   */
  export type PortfolioImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioImage.
     */
    data: XOR<PortfolioImageCreateInput, PortfolioImageUncheckedCreateInput>
  }

  /**
   * PortfolioImage createMany
   */
  export type PortfolioImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioImages.
     */
    data: PortfolioImageCreateManyInput | PortfolioImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioImage createManyAndReturn
   */
  export type PortfolioImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioImages.
     */
    data: PortfolioImageCreateManyInput | PortfolioImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioImage update
   */
  export type PortfolioImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioImage.
     */
    data: XOR<PortfolioImageUpdateInput, PortfolioImageUncheckedUpdateInput>
    /**
     * Choose, which PortfolioImage to update.
     */
    where: PortfolioImageWhereUniqueInput
  }

  /**
   * PortfolioImage updateMany
   */
  export type PortfolioImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioImages.
     */
    data: XOR<PortfolioImageUpdateManyMutationInput, PortfolioImageUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioImages to update
     */
    where?: PortfolioImageWhereInput
    /**
     * Limit how many PortfolioImages to update.
     */
    limit?: number
  }

  /**
   * PortfolioImage updateManyAndReturn
   */
  export type PortfolioImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioImages.
     */
    data: XOR<PortfolioImageUpdateManyMutationInput, PortfolioImageUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioImages to update
     */
    where?: PortfolioImageWhereInput
    /**
     * Limit how many PortfolioImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioImage upsert
   */
  export type PortfolioImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioImage to update in case it exists.
     */
    where: PortfolioImageWhereUniqueInput
    /**
     * In case the PortfolioImage found by the `where` argument doesn't exist, create a new PortfolioImage with this data.
     */
    create: XOR<PortfolioImageCreateInput, PortfolioImageUncheckedCreateInput>
    /**
     * In case the PortfolioImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioImageUpdateInput, PortfolioImageUncheckedUpdateInput>
  }

  /**
   * PortfolioImage delete
   */
  export type PortfolioImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
    /**
     * Filter which PortfolioImage to delete.
     */
    where: PortfolioImageWhereUniqueInput
  }

  /**
   * PortfolioImage deleteMany
   */
  export type PortfolioImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioImages to delete
     */
    where?: PortfolioImageWhereInput
    /**
     * Limit how many PortfolioImages to delete.
     */
    limit?: number
  }

  /**
   * PortfolioImage without action
   */
  export type PortfolioImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioImage
     */
    select?: PortfolioImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioImage
     */
    omit?: PortfolioImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioImageInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    portfolioId: string | null
    userId: string | null
    action: $Enums.FavoriteAction | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    portfolioId: string | null
    userId: string | null
    action: $Enums.FavoriteAction | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    portfolioId: number
    userId: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    portfolioId?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    portfolioId?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    portfolioId?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    portfolioId: string
    userId: string
    action: $Enums.FavoriteAction
    createdAt: Date
    updatedAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    userId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    userId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portfolioId?: boolean
    userId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    portfolioId?: boolean
    userId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portfolioId" | "userId" | "action" | "createdAt" | "updatedAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portfolioId: string
      userId: string
      action: $Enums.FavoriteAction
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly portfolioId: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly action: FieldRef<"Favorite", 'FavoriteAction'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
    readonly updatedAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Standards
   */

  export type AggregateStandards = {
    _count: StandardsCountAggregateOutputType | null
    _min: StandardsMinAggregateOutputType | null
    _max: StandardsMaxAggregateOutputType | null
  }

  export type StandardsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.StandardsType | null
    industrySlug: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.StandardsType | null
    industrySlug: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    industrySlug: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    industrySlug?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    industrySlug?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    industrySlug?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standards to aggregate.
     */
    where?: StandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardsOrderByWithRelationInput | StandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Standards
    **/
    _count?: true | StandardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardsMaxAggregateInputType
  }

  export type GetStandardsAggregateType<T extends StandardsAggregateArgs> = {
        [P in keyof T & keyof AggregateStandards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandards[P]>
      : GetScalarType<T[P], AggregateStandards[P]>
  }




  export type StandardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardsWhereInput
    orderBy?: StandardsOrderByWithAggregationInput | StandardsOrderByWithAggregationInput[]
    by: StandardsScalarFieldEnum[] | StandardsScalarFieldEnum
    having?: StandardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardsCountAggregateInputType | true
    _min?: StandardsMinAggregateInputType
    _max?: StandardsMaxAggregateInputType
  }

  export type StandardsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.StandardsType
    industrySlug: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: StandardsCountAggregateOutputType | null
    _min: StandardsMinAggregateOutputType | null
    _max: StandardsMaxAggregateOutputType | null
  }

  type GetStandardsGroupByPayload<T extends StandardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardsGroupByOutputType[P]>
            : GetScalarType<T[P], StandardsGroupByOutputType[P]>
        }
      >
    >


  export type StandardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    industrySlug?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioStandards?: boolean | Standards$PortfolioStandardsArgs<ExtArgs>
    _count?: boolean | StandardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standards"]>

  export type StandardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    industrySlug?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standards"]>

  export type StandardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    industrySlug?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standards"]>

  export type StandardsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    industrySlug?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "industrySlug" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["standards"]>
  export type StandardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    PortfolioStandards?: boolean | Standards$PortfolioStandardsArgs<ExtArgs>
    _count?: boolean | StandardsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type StandardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $StandardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Standards"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      PortfolioStandards: Prisma.$PortfolioStandardsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.StandardsType
      industrySlug: string
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standards"]>
    composites: {}
  }

  type StandardsGetPayload<S extends boolean | null | undefined | StandardsDefaultArgs> = $Result.GetResult<Prisma.$StandardsPayload, S>

  type StandardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardsCountAggregateInputType | true
    }

  export interface StandardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Standards'], meta: { name: 'Standards' } }
    /**
     * Find zero or one Standards that matches the filter.
     * @param {StandardsFindUniqueArgs} args - Arguments to find a Standards
     * @example
     * // Get one Standards
     * const standards = await prisma.standards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardsFindUniqueArgs>(args: SelectSubset<T, StandardsFindUniqueArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Standards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardsFindUniqueOrThrowArgs} args - Arguments to find a Standards
     * @example
     * // Get one Standards
     * const standards = await prisma.standards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardsFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsFindFirstArgs} args - Arguments to find a Standards
     * @example
     * // Get one Standards
     * const standards = await prisma.standards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardsFindFirstArgs>(args?: SelectSubset<T, StandardsFindFirstArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsFindFirstOrThrowArgs} args - Arguments to find a Standards
     * @example
     * // Get one Standards
     * const standards = await prisma.standards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardsFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Standards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Standards
     * const standards = await prisma.standards.findMany()
     * 
     * // Get first 10 Standards
     * const standards = await prisma.standards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardsWithIdOnly = await prisma.standards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardsFindManyArgs>(args?: SelectSubset<T, StandardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Standards.
     * @param {StandardsCreateArgs} args - Arguments to create a Standards.
     * @example
     * // Create one Standards
     * const Standards = await prisma.standards.create({
     *   data: {
     *     // ... data to create a Standards
     *   }
     * })
     * 
     */
    create<T extends StandardsCreateArgs>(args: SelectSubset<T, StandardsCreateArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Standards.
     * @param {StandardsCreateManyArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standards = await prisma.standards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardsCreateManyArgs>(args?: SelectSubset<T, StandardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Standards and returns the data saved in the database.
     * @param {StandardsCreateManyAndReturnArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standards = await prisma.standards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Standards and only return the `id`
     * const standardsWithIdOnly = await prisma.standards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardsCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Standards.
     * @param {StandardsDeleteArgs} args - Arguments to delete one Standards.
     * @example
     * // Delete one Standards
     * const Standards = await prisma.standards.delete({
     *   where: {
     *     // ... filter to delete one Standards
     *   }
     * })
     * 
     */
    delete<T extends StandardsDeleteArgs>(args: SelectSubset<T, StandardsDeleteArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Standards.
     * @param {StandardsUpdateArgs} args - Arguments to update one Standards.
     * @example
     * // Update one Standards
     * const standards = await prisma.standards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardsUpdateArgs>(args: SelectSubset<T, StandardsUpdateArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Standards.
     * @param {StandardsDeleteManyArgs} args - Arguments to filter Standards to delete.
     * @example
     * // Delete a few Standards
     * const { count } = await prisma.standards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardsDeleteManyArgs>(args?: SelectSubset<T, StandardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Standards
     * const standards = await prisma.standards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardsUpdateManyArgs>(args: SelectSubset<T, StandardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards and returns the data updated in the database.
     * @param {StandardsUpdateManyAndReturnArgs} args - Arguments to update many Standards.
     * @example
     * // Update many Standards
     * const standards = await prisma.standards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Standards and only return the `id`
     * const standardsWithIdOnly = await prisma.standards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardsUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Standards.
     * @param {StandardsUpsertArgs} args - Arguments to update or create a Standards.
     * @example
     * // Update or create a Standards
     * const standards = await prisma.standards.upsert({
     *   create: {
     *     // ... data to create a Standards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Standards we want to update
     *   }
     * })
     */
    upsert<T extends StandardsUpsertArgs>(args: SelectSubset<T, StandardsUpsertArgs<ExtArgs>>): Prisma__StandardsClient<$Result.GetResult<Prisma.$StandardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsCountArgs} args - Arguments to filter Standards to count.
     * @example
     * // Count the number of Standards
     * const count = await prisma.standards.count({
     *   where: {
     *     // ... the filter for the Standards we want to count
     *   }
     * })
    **/
    count<T extends StandardsCountArgs>(
      args?: Subset<T, StandardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardsAggregateArgs>(args: Subset<T, StandardsAggregateArgs>): Prisma.PrismaPromise<GetStandardsAggregateType<T>>

    /**
     * Group by Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardsGroupByArgs['orderBy'] }
        : { orderBy?: StandardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Standards model
   */
  readonly fields: StandardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Standards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PortfolioStandards<T extends Standards$PortfolioStandardsArgs<ExtArgs> = {}>(args?: Subset<T, Standards$PortfolioStandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioStandardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Standards model
   */
  interface StandardsFieldRefs {
    readonly id: FieldRef<"Standards", 'String'>
    readonly name: FieldRef<"Standards", 'String'>
    readonly description: FieldRef<"Standards", 'String'>
    readonly type: FieldRef<"Standards", 'StandardsType'>
    readonly industrySlug: FieldRef<"Standards", 'String'>
    readonly image: FieldRef<"Standards", 'String'>
    readonly createdAt: FieldRef<"Standards", 'DateTime'>
    readonly updatedAt: FieldRef<"Standards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Standards findUnique
   */
  export type StandardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where: StandardsWhereUniqueInput
  }

  /**
   * Standards findUniqueOrThrow
   */
  export type StandardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where: StandardsWhereUniqueInput
  }

  /**
   * Standards findFirst
   */
  export type StandardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where?: StandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardsOrderByWithRelationInput | StandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardsScalarFieldEnum | StandardsScalarFieldEnum[]
  }

  /**
   * Standards findFirstOrThrow
   */
  export type StandardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where?: StandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardsOrderByWithRelationInput | StandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardsScalarFieldEnum | StandardsScalarFieldEnum[]
  }

  /**
   * Standards findMany
   */
  export type StandardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where?: StandardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardsOrderByWithRelationInput | StandardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Standards.
     */
    cursor?: StandardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    distinct?: StandardsScalarFieldEnum | StandardsScalarFieldEnum[]
  }

  /**
   * Standards create
   */
  export type StandardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * The data needed to create a Standards.
     */
    data: XOR<StandardsCreateInput, StandardsUncheckedCreateInput>
  }

  /**
   * Standards createMany
   */
  export type StandardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Standards.
     */
    data: StandardsCreateManyInput | StandardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Standards createManyAndReturn
   */
  export type StandardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * The data used to create many Standards.
     */
    data: StandardsCreateManyInput | StandardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standards update
   */
  export type StandardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * The data needed to update a Standards.
     */
    data: XOR<StandardsUpdateInput, StandardsUncheckedUpdateInput>
    /**
     * Choose, which Standards to update.
     */
    where: StandardsWhereUniqueInput
  }

  /**
   * Standards updateMany
   */
  export type StandardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardsUpdateManyMutationInput, StandardsUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardsWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
  }

  /**
   * Standards updateManyAndReturn
   */
  export type StandardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardsUpdateManyMutationInput, StandardsUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardsWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standards upsert
   */
  export type StandardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * The filter to search for the Standards to update in case it exists.
     */
    where: StandardsWhereUniqueInput
    /**
     * In case the Standards found by the `where` argument doesn't exist, create a new Standards with this data.
     */
    create: XOR<StandardsCreateInput, StandardsUncheckedCreateInput>
    /**
     * In case the Standards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardsUpdateInput, StandardsUncheckedUpdateInput>
  }

  /**
   * Standards delete
   */
  export type StandardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
    /**
     * Filter which Standards to delete.
     */
    where: StandardsWhereUniqueInput
  }

  /**
   * Standards deleteMany
   */
  export type StandardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standards to delete
     */
    where?: StandardsWhereInput
    /**
     * Limit how many Standards to delete.
     */
    limit?: number
  }

  /**
   * Standards.PortfolioStandards
   */
  export type Standards$PortfolioStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioStandards
     */
    select?: PortfolioStandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioStandards
     */
    omit?: PortfolioStandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioStandardsInclude<ExtArgs> | null
    where?: PortfolioStandardsWhereInput
    orderBy?: PortfolioStandardsOrderByWithRelationInput | PortfolioStandardsOrderByWithRelationInput[]
    cursor?: PortfolioStandardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioStandardsScalarFieldEnum | PortfolioStandardsScalarFieldEnum[]
  }

  /**
   * Standards without action
   */
  export type StandardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standards
     */
    select?: StandardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standards
     */
    omit?: StandardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardsInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    group: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    freelanceId: string | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    group: string | null
    industrySlug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    freelanceId: string | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    group: number
    industrySlug: number
    createdAt: number
    updatedAt: number
    freelanceId: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    group?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    freelanceId?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    group?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    freelanceId?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    group?: true
    industrySlug?: true
    createdAt?: true
    updatedAt?: true
    freelanceId?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    title: string
    slug: string
    group: string | null
    industrySlug: string
    createdAt: Date
    updatedAt: Date
    freelanceId: string | null
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    group?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelanceId?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
    UserSkills?: boolean | Skill$UserSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    group?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelanceId?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    group?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelanceId?: boolean
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    group?: boolean
    industrySlug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelanceId?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "group" | "industrySlug" | "createdAt" | "updatedAt" | "freelanceId", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
    UserSkills?: boolean | Skill$UserSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
  }
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
    Freelance?: boolean | Skill$FreelanceArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      industry: Prisma.$IndustryPayload<ExtArgs>
      Freelance: Prisma.$FreelancePayload<ExtArgs> | null
      UserSkills: Prisma.$UserSkillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      group: string | null
      industrySlug: string
      createdAt: Date
      updatedAt: Date
      freelanceId: string | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Freelance<T extends Skill$FreelanceArgs<ExtArgs> = {}>(args?: Subset<T, Skill$FreelanceArgs<ExtArgs>>): Prisma__FreelanceClient<$Result.GetResult<Prisma.$FreelancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    UserSkills<T extends Skill$UserSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$UserSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly title: FieldRef<"Skill", 'String'>
    readonly slug: FieldRef<"Skill", 'String'>
    readonly group: FieldRef<"Skill", 'String'>
    readonly industrySlug: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
    readonly freelanceId: FieldRef<"Skill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.Freelance
   */
  export type Skill$FreelanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Freelance
     */
    select?: FreelanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Freelance
     */
    omit?: FreelanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceInclude<ExtArgs> | null
    where?: FreelanceWhereInput
  }

  /**
   * Skill.UserSkills
   */
  export type Skill$UserSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkills
     */
    select?: UserSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkills
     */
    omit?: UserSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillsInclude<ExtArgs> | null
    where?: UserSkillsWhereInput
    orderBy?: UserSkillsOrderByWithRelationInput | UserSkillsOrderByWithRelationInput[]
    cursor?: UserSkillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillsScalarFieldEnum | UserSkillsScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioComment
   */

  export type AggregatePortfolioComment = {
    _count: PortfolioCommentCountAggregateOutputType | null
    _min: PortfolioCommentMinAggregateOutputType | null
    _max: PortfolioCommentMaxAggregateOutputType | null
  }

  export type PortfolioCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    portfolioId: string | null
    userId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    portfolioId: string | null
    userId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioCommentCountAggregateOutputType = {
    id: number
    content: number
    portfolioId: number
    userId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioCommentMinAggregateInputType = {
    id?: true
    content?: true
    portfolioId?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCommentMaxAggregateInputType = {
    id?: true
    content?: true
    portfolioId?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioCommentCountAggregateInputType = {
    id?: true
    content?: true
    portfolioId?: true
    userId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioComment to aggregate.
     */
    where?: PortfolioCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioComments to fetch.
     */
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioComments
    **/
    _count?: true | PortfolioCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioCommentMaxAggregateInputType
  }

  export type GetPortfolioCommentAggregateType<T extends PortfolioCommentAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioComment[P]>
      : GetScalarType<T[P], AggregatePortfolioComment[P]>
  }




  export type PortfolioCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioCommentWhereInput
    orderBy?: PortfolioCommentOrderByWithAggregationInput | PortfolioCommentOrderByWithAggregationInput[]
    by: PortfolioCommentScalarFieldEnum[] | PortfolioCommentScalarFieldEnum
    having?: PortfolioCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCommentCountAggregateInputType | true
    _min?: PortfolioCommentMinAggregateInputType
    _max?: PortfolioCommentMaxAggregateInputType
  }

  export type PortfolioCommentGroupByOutputType = {
    id: string
    content: string
    portfolioId: string
    userId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PortfolioCommentCountAggregateOutputType | null
    _min: PortfolioCommentMinAggregateOutputType | null
    _max: PortfolioCommentMaxAggregateOutputType | null
  }

  type GetPortfolioCommentGroupByPayload<T extends PortfolioCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioCommentGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioCommentGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    portfolioId?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
    replies?: boolean | PortfolioComment$repliesArgs<ExtArgs>
    _count?: boolean | PortfolioCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioComment"]>

  export type PortfolioCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    portfolioId?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioComment"]>

  export type PortfolioCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    portfolioId?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioComment"]>

  export type PortfolioCommentSelectScalar = {
    id?: boolean
    content?: boolean
    portfolioId?: boolean
    userId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "portfolioId" | "userId" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioComment"]>
  export type PortfolioCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
    replies?: boolean | PortfolioComment$repliesArgs<ExtArgs>
    _count?: boolean | PortfolioCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortfolioCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
  }
  export type PortfolioCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | PortfolioDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | PortfolioComment$parentArgs<ExtArgs>
  }

  export type $PortfolioCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioComment"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$PortfolioCommentPayload<ExtArgs> | null
      replies: Prisma.$PortfolioCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      portfolioId: string
      userId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioComment"]>
    composites: {}
  }

  type PortfolioCommentGetPayload<S extends boolean | null | undefined | PortfolioCommentDefaultArgs> = $Result.GetResult<Prisma.$PortfolioCommentPayload, S>

  type PortfolioCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioCommentCountAggregateInputType | true
    }

  export interface PortfolioCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioComment'], meta: { name: 'PortfolioComment' } }
    /**
     * Find zero or one PortfolioComment that matches the filter.
     * @param {PortfolioCommentFindUniqueArgs} args - Arguments to find a PortfolioComment
     * @example
     * // Get one PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioCommentFindUniqueArgs>(args: SelectSubset<T, PortfolioCommentFindUniqueArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioCommentFindUniqueOrThrowArgs} args - Arguments to find a PortfolioComment
     * @example
     * // Get one PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentFindFirstArgs} args - Arguments to find a PortfolioComment
     * @example
     * // Get one PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioCommentFindFirstArgs>(args?: SelectSubset<T, PortfolioCommentFindFirstArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentFindFirstOrThrowArgs} args - Arguments to find a PortfolioComment
     * @example
     * // Get one PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioComments
     * const portfolioComments = await prisma.portfolioComment.findMany()
     * 
     * // Get first 10 PortfolioComments
     * const portfolioComments = await prisma.portfolioComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioCommentWithIdOnly = await prisma.portfolioComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioCommentFindManyArgs>(args?: SelectSubset<T, PortfolioCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioComment.
     * @param {PortfolioCommentCreateArgs} args - Arguments to create a PortfolioComment.
     * @example
     * // Create one PortfolioComment
     * const PortfolioComment = await prisma.portfolioComment.create({
     *   data: {
     *     // ... data to create a PortfolioComment
     *   }
     * })
     * 
     */
    create<T extends PortfolioCommentCreateArgs>(args: SelectSubset<T, PortfolioCommentCreateArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioComments.
     * @param {PortfolioCommentCreateManyArgs} args - Arguments to create many PortfolioComments.
     * @example
     * // Create many PortfolioComments
     * const portfolioComment = await prisma.portfolioComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCommentCreateManyArgs>(args?: SelectSubset<T, PortfolioCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioComments and returns the data saved in the database.
     * @param {PortfolioCommentCreateManyAndReturnArgs} args - Arguments to create many PortfolioComments.
     * @example
     * // Create many PortfolioComments
     * const portfolioComment = await prisma.portfolioComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioComments and only return the `id`
     * const portfolioCommentWithIdOnly = await prisma.portfolioComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortfolioComment.
     * @param {PortfolioCommentDeleteArgs} args - Arguments to delete one PortfolioComment.
     * @example
     * // Delete one PortfolioComment
     * const PortfolioComment = await prisma.portfolioComment.delete({
     *   where: {
     *     // ... filter to delete one PortfolioComment
     *   }
     * })
     * 
     */
    delete<T extends PortfolioCommentDeleteArgs>(args: SelectSubset<T, PortfolioCommentDeleteArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioComment.
     * @param {PortfolioCommentUpdateArgs} args - Arguments to update one PortfolioComment.
     * @example
     * // Update one PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioCommentUpdateArgs>(args: SelectSubset<T, PortfolioCommentUpdateArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioComments.
     * @param {PortfolioCommentDeleteManyArgs} args - Arguments to filter PortfolioComments to delete.
     * @example
     * // Delete a few PortfolioComments
     * const { count } = await prisma.portfolioComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioCommentDeleteManyArgs>(args?: SelectSubset<T, PortfolioCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioComments
     * const portfolioComment = await prisma.portfolioComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioCommentUpdateManyArgs>(args: SelectSubset<T, PortfolioCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioComments and returns the data updated in the database.
     * @param {PortfolioCommentUpdateManyAndReturnArgs} args - Arguments to update many PortfolioComments.
     * @example
     * // Update many PortfolioComments
     * const portfolioComment = await prisma.portfolioComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortfolioComments and only return the `id`
     * const portfolioCommentWithIdOnly = await prisma.portfolioComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortfolioComment.
     * @param {PortfolioCommentUpsertArgs} args - Arguments to update or create a PortfolioComment.
     * @example
     * // Update or create a PortfolioComment
     * const portfolioComment = await prisma.portfolioComment.upsert({
     *   create: {
     *     // ... data to create a PortfolioComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioComment we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioCommentUpsertArgs>(args: SelectSubset<T, PortfolioCommentUpsertArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentCountArgs} args - Arguments to filter PortfolioComments to count.
     * @example
     * // Count the number of PortfolioComments
     * const count = await prisma.portfolioComment.count({
     *   where: {
     *     // ... the filter for the PortfolioComments we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCommentCountArgs>(
      args?: Subset<T, PortfolioCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioCommentAggregateArgs>(args: Subset<T, PortfolioCommentAggregateArgs>): Prisma.PrismaPromise<GetPortfolioCommentAggregateType<T>>

    /**
     * Group by PortfolioComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioCommentGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioComment model
   */
  readonly fields: PortfolioCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends PortfolioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioDefaultArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends PortfolioComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioComment$parentArgs<ExtArgs>>): Prisma__PortfolioCommentClient<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends PortfolioComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, PortfolioComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioComment model
   */
  interface PortfolioCommentFieldRefs {
    readonly id: FieldRef<"PortfolioComment", 'String'>
    readonly content: FieldRef<"PortfolioComment", 'String'>
    readonly portfolioId: FieldRef<"PortfolioComment", 'String'>
    readonly userId: FieldRef<"PortfolioComment", 'String'>
    readonly parentId: FieldRef<"PortfolioComment", 'String'>
    readonly createdAt: FieldRef<"PortfolioComment", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioComment findUnique
   */
  export type PortfolioCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioComment to fetch.
     */
    where: PortfolioCommentWhereUniqueInput
  }

  /**
   * PortfolioComment findUniqueOrThrow
   */
  export type PortfolioCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioComment to fetch.
     */
    where: PortfolioCommentWhereUniqueInput
  }

  /**
   * PortfolioComment findFirst
   */
  export type PortfolioCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioComment to fetch.
     */
    where?: PortfolioCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioComments to fetch.
     */
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioComments.
     */
    cursor?: PortfolioCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioComments.
     */
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * PortfolioComment findFirstOrThrow
   */
  export type PortfolioCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioComment to fetch.
     */
    where?: PortfolioCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioComments to fetch.
     */
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioComments.
     */
    cursor?: PortfolioCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioComments.
     */
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * PortfolioComment findMany
   */
  export type PortfolioCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioComments to fetch.
     */
    where?: PortfolioCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioComments to fetch.
     */
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioComments.
     */
    cursor?: PortfolioCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioComments.
     */
    skip?: number
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * PortfolioComment create
   */
  export type PortfolioCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioComment.
     */
    data: XOR<PortfolioCommentCreateInput, PortfolioCommentUncheckedCreateInput>
  }

  /**
   * PortfolioComment createMany
   */
  export type PortfolioCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioComments.
     */
    data: PortfolioCommentCreateManyInput | PortfolioCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioComment createManyAndReturn
   */
  export type PortfolioCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * The data used to create many PortfolioComments.
     */
    data: PortfolioCommentCreateManyInput | PortfolioCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioComment update
   */
  export type PortfolioCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioComment.
     */
    data: XOR<PortfolioCommentUpdateInput, PortfolioCommentUncheckedUpdateInput>
    /**
     * Choose, which PortfolioComment to update.
     */
    where: PortfolioCommentWhereUniqueInput
  }

  /**
   * PortfolioComment updateMany
   */
  export type PortfolioCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioComments.
     */
    data: XOR<PortfolioCommentUpdateManyMutationInput, PortfolioCommentUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioComments to update
     */
    where?: PortfolioCommentWhereInput
    /**
     * Limit how many PortfolioComments to update.
     */
    limit?: number
  }

  /**
   * PortfolioComment updateManyAndReturn
   */
  export type PortfolioCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * The data used to update PortfolioComments.
     */
    data: XOR<PortfolioCommentUpdateManyMutationInput, PortfolioCommentUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioComments to update
     */
    where?: PortfolioCommentWhereInput
    /**
     * Limit how many PortfolioComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioComment upsert
   */
  export type PortfolioCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioComment to update in case it exists.
     */
    where: PortfolioCommentWhereUniqueInput
    /**
     * In case the PortfolioComment found by the `where` argument doesn't exist, create a new PortfolioComment with this data.
     */
    create: XOR<PortfolioCommentCreateInput, PortfolioCommentUncheckedCreateInput>
    /**
     * In case the PortfolioComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioCommentUpdateInput, PortfolioCommentUncheckedUpdateInput>
  }

  /**
   * PortfolioComment delete
   */
  export type PortfolioCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    /**
     * Filter which PortfolioComment to delete.
     */
    where: PortfolioCommentWhereUniqueInput
  }

  /**
   * PortfolioComment deleteMany
   */
  export type PortfolioCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioComments to delete
     */
    where?: PortfolioCommentWhereInput
    /**
     * Limit how many PortfolioComments to delete.
     */
    limit?: number
  }

  /**
   * PortfolioComment.parent
   */
  export type PortfolioComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    where?: PortfolioCommentWhereInput
  }

  /**
   * PortfolioComment.replies
   */
  export type PortfolioComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
    where?: PortfolioCommentWhereInput
    orderBy?: PortfolioCommentOrderByWithRelationInput | PortfolioCommentOrderByWithRelationInput[]
    cursor?: PortfolioCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioCommentScalarFieldEnum | PortfolioCommentScalarFieldEnum[]
  }

  /**
   * PortfolioComment without action
   */
  export type PortfolioCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioComment
     */
    select?: PortfolioCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioComment
     */
    omit?: PortfolioCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioCommentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullnameTh: 'fullnameTh',
    fullnameEn: 'fullnameEn',
    about: 'about',
    phoneNumber: 'phoneNumber',
    email: 'email',
    website: 'website',
    address: 'address',
    image: 'image',
    industries: 'industries',
    tags: 'tags',
    channels: 'channels',
    specialists: 'specialists',
    userType: 'userType',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTagsScalarFieldEnum: {
    userId: 'userId',
    tagSlug: 'tagSlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTagsScalarFieldEnum = (typeof UserTagsScalarFieldEnum)[keyof typeof UserTagsScalarFieldEnum]


  export const UserChannelsScalarFieldEnum: {
    userId: 'userId',
    channelSlug: 'channelSlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserChannelsScalarFieldEnum = (typeof UserChannelsScalarFieldEnum)[keyof typeof UserChannelsScalarFieldEnum]


  export const UserSkillsScalarFieldEnum: {
    userId: 'userId',
    skillSlug: 'skillSlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSkillsScalarFieldEnum = (typeof UserSkillsScalarFieldEnum)[keyof typeof UserSkillsScalarFieldEnum]


  export const UserIndustryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    industryId: 'industryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserIndustryScalarFieldEnum = (typeof UserIndustryScalarFieldEnum)[keyof typeof UserIndustryScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    issuedAt: 'issuedAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const CompanyRevenueScalarFieldEnum: {
    id: 'id',
    year: 'year',
    total: 'total',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyRevenueScalarFieldEnum = (typeof CompanyRevenueScalarFieldEnum)[keyof typeof CompanyRevenueScalarFieldEnum]


  export const FreelanceRevenueScalarFieldEnum: {
    id: 'id',
    year: 'year',
    total: 'total',
    freelanceId: 'freelanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelanceRevenueScalarFieldEnum = (typeof FreelanceRevenueScalarFieldEnum)[keyof typeof FreelanceRevenueScalarFieldEnum]


  export const RevenueStreamScalarFieldEnum: {
    id: 'id',
    year: 'year',
    industryTypeSlug: 'industryTypeSlug',
    categorySlug: 'categorySlug',
    sourceSlug: 'sourceSlug',
    channelSlug: 'channelSlug',
    segmentSlug: 'segmentSlug',
    percent: 'percent',
    ctrPercent: 'ctrPercent',
    value: 'value',
    companyId: 'companyId',
    companyJuristicId: 'companyJuristicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RevenueStreamScalarFieldEnum = (typeof RevenueStreamScalarFieldEnum)[keyof typeof RevenueStreamScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    juristicId: 'juristicId',
    nameTh: 'nameTh',
    nameEn: 'nameEn',
    description: 'description',
    image: 'image',
    cover_image: 'cover_image',
    address: 'address',
    subDistrict: 'subDistrict',
    district: 'district',
    province: 'province',
    postalCode: 'postalCode',
    registerdCapital: 'registerdCapital',
    employeeCount: 'employeeCount',
    phoneNumber: 'phoneNumber',
    email: 'email',
    website: 'website',
    logo: 'logo',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    industries: 'industries'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyIndustryScalarFieldEnum: {
    companyId: 'companyId',
    industrySlug: 'industrySlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyIndustryScalarFieldEnum = (typeof CompanyIndustryScalarFieldEnum)[keyof typeof CompanyIndustryScalarFieldEnum]


  export const FreelanceScalarFieldEnum: {
    id: 'id',
    firstNameTh: 'firstNameTh',
    lastNameTh: 'lastNameTh',
    firstNameEn: 'firstNameEn',
    lastNameEn: 'lastNameEn',
    image: 'image',
    cover_image: 'cover_image',
    address: 'address',
    subDistrict: 'subDistrict',
    district: 'district',
    province: 'province',
    postalCode: 'postalCode',
    phoneNumber: 'phoneNumber',
    email: 'email',
    juristicId: 'juristicId',
    industryTypes: 'industryTypes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type FreelanceScalarFieldEnum = (typeof FreelanceScalarFieldEnum)[keyof typeof FreelanceScalarFieldEnum]


  export const FreelanceIndustryScalarFieldEnum: {
    freelanceId: 'freelanceId',
    industrySlug: 'industrySlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelanceIndustryScalarFieldEnum = (typeof FreelanceIndustryScalarFieldEnum)[keyof typeof FreelanceIndustryScalarFieldEnum]


  export const IndustryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndustryScalarFieldEnum = (typeof IndustryScalarFieldEnum)[keyof typeof IndustryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    industrySlug: 'industrySlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const LookingForScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    industrySlug: 'industrySlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LookingForScalarFieldEnum = (typeof LookingForScalarFieldEnum)[keyof typeof LookingForScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    industrySlug: 'industrySlug'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    industrySlug: 'industrySlug'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    industrySlug: 'industrySlug'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const SegmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    industrySlug: 'industrySlug'
  };

  export type SegmentScalarFieldEnum = (typeof SegmentScalarFieldEnum)[keyof typeof SegmentScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    id: 'id',
    title: 'title',
    title_en: 'title_en',
    description: 'description',
    description_en: 'description_en',
    cover_image: 'cover_image',
    link: 'link',
    industryTypeSlug: 'industryTypeSlug',
    tags: 'tags',
    looking_for: 'looking_for',
    freelanceId: 'freelanceId',
    companyId: 'companyId',
    companyJuristicId: 'companyJuristicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const PortfolioTagScalarFieldEnum: {
    portfolioId: 'portfolioId',
    tagSlug: 'tagSlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioTagScalarFieldEnum = (typeof PortfolioTagScalarFieldEnum)[keyof typeof PortfolioTagScalarFieldEnum]


  export const PortfolioLookingForScalarFieldEnum: {
    portfolioId: 'portfolioId',
    lookingForSlug: 'lookingForSlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioLookingForScalarFieldEnum = (typeof PortfolioLookingForScalarFieldEnum)[keyof typeof PortfolioLookingForScalarFieldEnum]


  export const PortfolioStandardsScalarFieldEnum: {
    id: 'id',
    portfolioId: 'portfolioId',
    standardsId: 'standardsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioStandardsScalarFieldEnum = (typeof PortfolioStandardsScalarFieldEnum)[keyof typeof PortfolioStandardsScalarFieldEnum]


  export const PortfolioImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    description: 'description',
    type: 'type',
    portfolioId: 'portfolioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioImageScalarFieldEnum = (typeof PortfolioImageScalarFieldEnum)[keyof typeof PortfolioImageScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    portfolioId: 'portfolioId',
    userId: 'userId',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const StandardsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    industrySlug: 'industrySlug',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardsScalarFieldEnum = (typeof StandardsScalarFieldEnum)[keyof typeof StandardsScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    group: 'group',
    industrySlug: 'industrySlug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    freelanceId: 'freelanceId'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const PortfolioCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    portfolioId: 'portfolioId',
    userId: 'userId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioCommentScalarFieldEnum = (typeof PortfolioCommentScalarFieldEnum)[keyof typeof PortfolioCommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PortfolioImageType'
   */
  export type EnumPortfolioImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortfolioImageType'>
    


  /**
   * Reference to a field of type 'PortfolioImageType[]'
   */
  export type ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortfolioImageType[]'>
    


  /**
   * Reference to a field of type 'FavoriteAction'
   */
  export type EnumFavoriteActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FavoriteAction'>
    


  /**
   * Reference to a field of type 'FavoriteAction[]'
   */
  export type ListEnumFavoriteActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FavoriteAction[]'>
    


  /**
   * Reference to a field of type 'StandardsType'
   */
  export type EnumStandardsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardsType'>
    


  /**
   * Reference to a field of type 'StandardsType[]'
   */
  export type ListEnumStandardsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardsType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    fullnameTh?: StringNullableFilter<"User"> | string | null
    fullnameEn?: StringNullableFilter<"User"> | string | null
    about?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    website?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    industries?: StringNullableListFilter<"User">
    tags?: JsonNullableListFilter<"User">
    channels?: JsonNullableListFilter<"User">
    specialists?: JsonNullableListFilter<"User">
    userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    role?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    industriesRelated?: UserIndustryListRelationFilter
    industryTags?: UserTagsListRelationFilter
    industryChannels?: UserChannelsListRelationFilter
    industrySkills?: UserSkillsListRelationFilter
    freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    Favorite?: FavoriteListRelationFilter
    comments?: PortfolioCommentListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullnameTh?: SortOrderInput | SortOrder
    fullnameEn?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    industries?: SortOrder
    tags?: SortOrder
    channels?: SortOrder
    specialists?: SortOrder
    userType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industriesRelated?: UserIndustryOrderByRelationAggregateInput
    industryTags?: UserTagsOrderByRelationAggregateInput
    industryChannels?: UserChannelsOrderByRelationAggregateInput
    industrySkills?: UserSkillsOrderByRelationAggregateInput
    freelance?: FreelanceOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    Favorite?: FavoriteOrderByRelationAggregateInput
    comments?: PortfolioCommentOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullnameTh?: StringNullableFilter<"User"> | string | null
    fullnameEn?: StringNullableFilter<"User"> | string | null
    about?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    industries?: StringNullableListFilter<"User">
    tags?: JsonNullableListFilter<"User">
    channels?: JsonNullableListFilter<"User">
    specialists?: JsonNullableListFilter<"User">
    userType?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    role?: EnumUserTypeNullableFilter<"User"> | $Enums.UserType | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    industriesRelated?: UserIndustryListRelationFilter
    industryTags?: UserTagsListRelationFilter
    industryChannels?: UserChannelsListRelationFilter
    industrySkills?: UserSkillsListRelationFilter
    freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    Favorite?: FavoriteListRelationFilter
    comments?: PortfolioCommentListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullnameTh?: SortOrderInput | SortOrder
    fullnameEn?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    industries?: SortOrder
    tags?: SortOrder
    channels?: SortOrder
    specialists?: SortOrder
    userType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    fullnameTh?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullnameEn?: StringNullableWithAggregatesFilter<"User"> | string | null
    about?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    industries?: StringNullableListFilter<"User">
    tags?: JsonNullableListFilter<"User">
    channels?: JsonNullableListFilter<"User">
    specialists?: JsonNullableListFilter<"User">
    userType?: EnumUserTypeNullableWithAggregatesFilter<"User"> | $Enums.UserType | null
    role?: EnumUserTypeNullableWithAggregatesFilter<"User"> | $Enums.UserType | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserTagsWhereInput = {
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    userId?: UuidFilter<"UserTags"> | string
    tagSlug?: StringFilter<"UserTags"> | string
    createdAt?: DateTimeFilter<"UserTags"> | Date | string
    updatedAt?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type UserTagsOrderByWithRelationInput = {
    userId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type UserTagsWhereUniqueInput = Prisma.AtLeast<{
    userId_tagSlug?: UserTagsUserIdTagSlugCompoundUniqueInput
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    userId?: UuidFilter<"UserTags"> | string
    tagSlug?: StringFilter<"UserTags"> | string
    createdAt?: DateTimeFilter<"UserTags"> | Date | string
    updatedAt?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "userId_tagSlug">

  export type UserTagsOrderByWithAggregationInput = {
    userId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTagsCountOrderByAggregateInput
    _max?: UserTagsMaxOrderByAggregateInput
    _min?: UserTagsMinOrderByAggregateInput
  }

  export type UserTagsScalarWhereWithAggregatesInput = {
    AND?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    OR?: UserTagsScalarWhereWithAggregatesInput[]
    NOT?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserTags"> | string
    tagSlug?: StringWithAggregatesFilter<"UserTags"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTags"> | Date | string
  }

  export type UserChannelsWhereInput = {
    AND?: UserChannelsWhereInput | UserChannelsWhereInput[]
    OR?: UserChannelsWhereInput[]
    NOT?: UserChannelsWhereInput | UserChannelsWhereInput[]
    userId?: UuidFilter<"UserChannels"> | string
    channelSlug?: StringFilter<"UserChannels"> | string
    createdAt?: DateTimeFilter<"UserChannels"> | Date | string
    updatedAt?: DateTimeFilter<"UserChannels"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }

  export type UserChannelsOrderByWithRelationInput = {
    userId?: SortOrder
    channelSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type UserChannelsWhereUniqueInput = Prisma.AtLeast<{
    userId_channelSlug?: UserChannelsUserIdChannelSlugCompoundUniqueInput
    AND?: UserChannelsWhereInput | UserChannelsWhereInput[]
    OR?: UserChannelsWhereInput[]
    NOT?: UserChannelsWhereInput | UserChannelsWhereInput[]
    userId?: UuidFilter<"UserChannels"> | string
    channelSlug?: StringFilter<"UserChannels"> | string
    createdAt?: DateTimeFilter<"UserChannels"> | Date | string
    updatedAt?: DateTimeFilter<"UserChannels"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }, "userId_channelSlug">

  export type UserChannelsOrderByWithAggregationInput = {
    userId?: SortOrder
    channelSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserChannelsCountOrderByAggregateInput
    _max?: UserChannelsMaxOrderByAggregateInput
    _min?: UserChannelsMinOrderByAggregateInput
  }

  export type UserChannelsScalarWhereWithAggregatesInput = {
    AND?: UserChannelsScalarWhereWithAggregatesInput | UserChannelsScalarWhereWithAggregatesInput[]
    OR?: UserChannelsScalarWhereWithAggregatesInput[]
    NOT?: UserChannelsScalarWhereWithAggregatesInput | UserChannelsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserChannels"> | string
    channelSlug?: StringWithAggregatesFilter<"UserChannels"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserChannels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserChannels"> | Date | string
  }

  export type UserSkillsWhereInput = {
    AND?: UserSkillsWhereInput | UserSkillsWhereInput[]
    OR?: UserSkillsWhereInput[]
    NOT?: UserSkillsWhereInput | UserSkillsWhereInput[]
    userId?: UuidFilter<"UserSkills"> | string
    skillSlug?: StringFilter<"UserSkills"> | string
    createdAt?: DateTimeFilter<"UserSkills"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkills"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type UserSkillsOrderByWithRelationInput = {
    userId?: SortOrder
    skillSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type UserSkillsWhereUniqueInput = Prisma.AtLeast<{
    userId_skillSlug?: UserSkillsUserIdSkillSlugCompoundUniqueInput
    AND?: UserSkillsWhereInput | UserSkillsWhereInput[]
    OR?: UserSkillsWhereInput[]
    NOT?: UserSkillsWhereInput | UserSkillsWhereInput[]
    userId?: UuidFilter<"UserSkills"> | string
    skillSlug?: StringFilter<"UserSkills"> | string
    createdAt?: DateTimeFilter<"UserSkills"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkills"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "userId_skillSlug">

  export type UserSkillsOrderByWithAggregationInput = {
    userId?: SortOrder
    skillSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSkillsCountOrderByAggregateInput
    _max?: UserSkillsMaxOrderByAggregateInput
    _min?: UserSkillsMinOrderByAggregateInput
  }

  export type UserSkillsScalarWhereWithAggregatesInput = {
    AND?: UserSkillsScalarWhereWithAggregatesInput | UserSkillsScalarWhereWithAggregatesInput[]
    OR?: UserSkillsScalarWhereWithAggregatesInput[]
    NOT?: UserSkillsScalarWhereWithAggregatesInput | UserSkillsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserSkills"> | string
    skillSlug?: StringWithAggregatesFilter<"UserSkills"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSkills"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSkills"> | Date | string
  }

  export type UserIndustryWhereInput = {
    AND?: UserIndustryWhereInput | UserIndustryWhereInput[]
    OR?: UserIndustryWhereInput[]
    NOT?: UserIndustryWhereInput | UserIndustryWhereInput[]
    id?: UuidFilter<"UserIndustry"> | string
    userId?: UuidFilter<"UserIndustry"> | string
    industryId?: UuidFilter<"UserIndustry"> | string
    createdAt?: DateTimeFilter<"UserIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"UserIndustry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }

  export type UserIndustryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    industryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    industry?: IndustryOrderByWithRelationInput
  }

  export type UserIndustryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_industryId?: UserIndustryUserIdIndustryIdCompoundUniqueInput
    AND?: UserIndustryWhereInput | UserIndustryWhereInput[]
    OR?: UserIndustryWhereInput[]
    NOT?: UserIndustryWhereInput | UserIndustryWhereInput[]
    userId?: UuidFilter<"UserIndustry"> | string
    industryId?: UuidFilter<"UserIndustry"> | string
    createdAt?: DateTimeFilter<"UserIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"UserIndustry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }, "id" | "userId_industryId">

  export type UserIndustryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    industryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserIndustryCountOrderByAggregateInput
    _max?: UserIndustryMaxOrderByAggregateInput
    _min?: UserIndustryMinOrderByAggregateInput
  }

  export type UserIndustryScalarWhereWithAggregatesInput = {
    AND?: UserIndustryScalarWhereWithAggregatesInput | UserIndustryScalarWhereWithAggregatesInput[]
    OR?: UserIndustryScalarWhereWithAggregatesInput[]
    NOT?: UserIndustryScalarWhereWithAggregatesInput | UserIndustryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserIndustry"> | string
    userId?: UuidWithAggregatesFilter<"UserIndustry"> | string
    industryId?: UuidWithAggregatesFilter<"UserIndustry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserIndustry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserIndustry"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: UuidFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: UuidFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    issuedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: UuidFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    issuedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: UuidWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    issuedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type CompanyRevenueWhereInput = {
    AND?: CompanyRevenueWhereInput | CompanyRevenueWhereInput[]
    OR?: CompanyRevenueWhereInput[]
    NOT?: CompanyRevenueWhereInput | CompanyRevenueWhereInput[]
    id?: UuidFilter<"CompanyRevenue"> | string
    year?: IntFilter<"CompanyRevenue"> | number
    total?: FloatFilter<"CompanyRevenue"> | number
    companyId?: UuidFilter<"CompanyRevenue"> | string
    createdAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CompanyRevenueOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyRevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_year?: CompanyRevenueCompanyIdYearCompoundUniqueInput
    AND?: CompanyRevenueWhereInput | CompanyRevenueWhereInput[]
    OR?: CompanyRevenueWhereInput[]
    NOT?: CompanyRevenueWhereInput | CompanyRevenueWhereInput[]
    year?: IntFilter<"CompanyRevenue"> | number
    total?: FloatFilter<"CompanyRevenue"> | number
    companyId?: UuidFilter<"CompanyRevenue"> | string
    createdAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_year">

  export type CompanyRevenueOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyRevenueCountOrderByAggregateInput
    _avg?: CompanyRevenueAvgOrderByAggregateInput
    _max?: CompanyRevenueMaxOrderByAggregateInput
    _min?: CompanyRevenueMinOrderByAggregateInput
    _sum?: CompanyRevenueSumOrderByAggregateInput
  }

  export type CompanyRevenueScalarWhereWithAggregatesInput = {
    AND?: CompanyRevenueScalarWhereWithAggregatesInput | CompanyRevenueScalarWhereWithAggregatesInput[]
    OR?: CompanyRevenueScalarWhereWithAggregatesInput[]
    NOT?: CompanyRevenueScalarWhereWithAggregatesInput | CompanyRevenueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CompanyRevenue"> | string
    year?: IntWithAggregatesFilter<"CompanyRevenue"> | number
    total?: FloatWithAggregatesFilter<"CompanyRevenue"> | number
    companyId?: UuidWithAggregatesFilter<"CompanyRevenue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyRevenue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyRevenue"> | Date | string
  }

  export type FreelanceRevenueWhereInput = {
    AND?: FreelanceRevenueWhereInput | FreelanceRevenueWhereInput[]
    OR?: FreelanceRevenueWhereInput[]
    NOT?: FreelanceRevenueWhereInput | FreelanceRevenueWhereInput[]
    id?: UuidFilter<"FreelanceRevenue"> | string
    year?: IntFilter<"FreelanceRevenue"> | number
    total?: FloatFilter<"FreelanceRevenue"> | number
    freelanceId?: UuidFilter<"FreelanceRevenue"> | string
    createdAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
    Freelance?: XOR<FreelanceScalarRelationFilter, FreelanceWhereInput>
  }

  export type FreelanceRevenueOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    freelanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Freelance?: FreelanceOrderByWithRelationInput
  }

  export type FreelanceRevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    freelanceId_year?: FreelanceRevenueFreelanceIdYearCompoundUniqueInput
    AND?: FreelanceRevenueWhereInput | FreelanceRevenueWhereInput[]
    OR?: FreelanceRevenueWhereInput[]
    NOT?: FreelanceRevenueWhereInput | FreelanceRevenueWhereInput[]
    year?: IntFilter<"FreelanceRevenue"> | number
    total?: FloatFilter<"FreelanceRevenue"> | number
    freelanceId?: UuidFilter<"FreelanceRevenue"> | string
    createdAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
    Freelance?: XOR<FreelanceScalarRelationFilter, FreelanceWhereInput>
  }, "id" | "freelanceId_year">

  export type FreelanceRevenueOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    freelanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelanceRevenueCountOrderByAggregateInput
    _avg?: FreelanceRevenueAvgOrderByAggregateInput
    _max?: FreelanceRevenueMaxOrderByAggregateInput
    _min?: FreelanceRevenueMinOrderByAggregateInput
    _sum?: FreelanceRevenueSumOrderByAggregateInput
  }

  export type FreelanceRevenueScalarWhereWithAggregatesInput = {
    AND?: FreelanceRevenueScalarWhereWithAggregatesInput | FreelanceRevenueScalarWhereWithAggregatesInput[]
    OR?: FreelanceRevenueScalarWhereWithAggregatesInput[]
    NOT?: FreelanceRevenueScalarWhereWithAggregatesInput | FreelanceRevenueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FreelanceRevenue"> | string
    year?: IntWithAggregatesFilter<"FreelanceRevenue"> | number
    total?: FloatWithAggregatesFilter<"FreelanceRevenue"> | number
    freelanceId?: UuidWithAggregatesFilter<"FreelanceRevenue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FreelanceRevenue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelanceRevenue"> | Date | string
  }

  export type RevenueStreamWhereInput = {
    AND?: RevenueStreamWhereInput | RevenueStreamWhereInput[]
    OR?: RevenueStreamWhereInput[]
    NOT?: RevenueStreamWhereInput | RevenueStreamWhereInput[]
    id?: UuidFilter<"RevenueStream"> | string
    year?: IntFilter<"RevenueStream"> | number
    industryTypeSlug?: StringFilter<"RevenueStream"> | string
    categorySlug?: StringFilter<"RevenueStream"> | string
    sourceSlug?: StringFilter<"RevenueStream"> | string
    channelSlug?: StringFilter<"RevenueStream"> | string
    segmentSlug?: StringFilter<"RevenueStream"> | string
    percent?: FloatFilter<"RevenueStream"> | number
    ctrPercent?: FloatFilter<"RevenueStream"> | number
    value?: FloatNullableFilter<"RevenueStream"> | number | null
    companyId?: UuidFilter<"RevenueStream"> | string
    companyJuristicId?: StringFilter<"RevenueStream"> | string
    createdAt?: DateTimeFilter<"RevenueStream"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueStream"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
    segment?: XOR<SegmentScalarRelationFilter, SegmentWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type RevenueStreamOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    industryTypeSlug?: SortOrder
    categorySlug?: SortOrder
    sourceSlug?: SortOrder
    channelSlug?: SortOrder
    segmentSlug?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrderInput | SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    source?: SourceOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
    segment?: SegmentOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type RevenueStreamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_year_industryTypeSlug_categorySlug_sourceSlug_channelSlug_segmentSlug?: RevenueStreamCompanyIdYearIndustryTypeSlugCategorySlugSourceSlugChannelSlugSegmentSlugCompoundUniqueInput
    AND?: RevenueStreamWhereInput | RevenueStreamWhereInput[]
    OR?: RevenueStreamWhereInput[]
    NOT?: RevenueStreamWhereInput | RevenueStreamWhereInput[]
    year?: IntFilter<"RevenueStream"> | number
    industryTypeSlug?: StringFilter<"RevenueStream"> | string
    categorySlug?: StringFilter<"RevenueStream"> | string
    sourceSlug?: StringFilter<"RevenueStream"> | string
    channelSlug?: StringFilter<"RevenueStream"> | string
    segmentSlug?: StringFilter<"RevenueStream"> | string
    percent?: FloatFilter<"RevenueStream"> | number
    ctrPercent?: FloatFilter<"RevenueStream"> | number
    value?: FloatNullableFilter<"RevenueStream"> | number | null
    companyId?: UuidFilter<"RevenueStream"> | string
    companyJuristicId?: StringFilter<"RevenueStream"> | string
    createdAt?: DateTimeFilter<"RevenueStream"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueStream"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
    segment?: XOR<SegmentScalarRelationFilter, SegmentWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_year_industryTypeSlug_categorySlug_sourceSlug_channelSlug_segmentSlug">

  export type RevenueStreamOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    industryTypeSlug?: SortOrder
    categorySlug?: SortOrder
    sourceSlug?: SortOrder
    channelSlug?: SortOrder
    segmentSlug?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrderInput | SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RevenueStreamCountOrderByAggregateInput
    _avg?: RevenueStreamAvgOrderByAggregateInput
    _max?: RevenueStreamMaxOrderByAggregateInput
    _min?: RevenueStreamMinOrderByAggregateInput
    _sum?: RevenueStreamSumOrderByAggregateInput
  }

  export type RevenueStreamScalarWhereWithAggregatesInput = {
    AND?: RevenueStreamScalarWhereWithAggregatesInput | RevenueStreamScalarWhereWithAggregatesInput[]
    OR?: RevenueStreamScalarWhereWithAggregatesInput[]
    NOT?: RevenueStreamScalarWhereWithAggregatesInput | RevenueStreamScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RevenueStream"> | string
    year?: IntWithAggregatesFilter<"RevenueStream"> | number
    industryTypeSlug?: StringWithAggregatesFilter<"RevenueStream"> | string
    categorySlug?: StringWithAggregatesFilter<"RevenueStream"> | string
    sourceSlug?: StringWithAggregatesFilter<"RevenueStream"> | string
    channelSlug?: StringWithAggregatesFilter<"RevenueStream"> | string
    segmentSlug?: StringWithAggregatesFilter<"RevenueStream"> | string
    percent?: FloatWithAggregatesFilter<"RevenueStream"> | number
    ctrPercent?: FloatWithAggregatesFilter<"RevenueStream"> | number
    value?: FloatNullableWithAggregatesFilter<"RevenueStream"> | number | null
    companyId?: UuidWithAggregatesFilter<"RevenueStream"> | string
    companyJuristicId?: StringWithAggregatesFilter<"RevenueStream"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RevenueStream"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RevenueStream"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    juristicId?: StringFilter<"Company"> | string
    nameTh?: StringFilter<"Company"> | string
    nameEn?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    image?: StringNullableFilter<"Company"> | string | null
    cover_image?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    subDistrict?: StringNullableFilter<"Company"> | string | null
    district?: StringNullableFilter<"Company"> | string | null
    province?: StringNullableFilter<"Company"> | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    registerdCapital?: FloatNullableFilter<"Company"> | number | null
    employeeCount?: IntNullableFilter<"Company"> | number | null
    phoneNumber?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    userId?: UuidFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    industries?: StringNullableListFilter<"Company">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    industriesRelated?: CompanyIndustryListRelationFilter
    companyRevenue?: CompanyRevenueListRelationFilter
    RevenueStream?: RevenueStreamListRelationFilter
    Portfolio?: PortfolioListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    juristicId?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    registerdCapital?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industries?: SortOrder
    user?: UserOrderByWithRelationInput
    industriesRelated?: CompanyIndustryOrderByRelationAggregateInput
    companyRevenue?: CompanyRevenueOrderByRelationAggregateInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
    Portfolio?: PortfolioOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    juristicId?: string
    userId?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    nameTh?: StringFilter<"Company"> | string
    nameEn?: StringNullableFilter<"Company"> | string | null
    description?: StringNullableFilter<"Company"> | string | null
    image?: StringNullableFilter<"Company"> | string | null
    cover_image?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    subDistrict?: StringNullableFilter<"Company"> | string | null
    district?: StringNullableFilter<"Company"> | string | null
    province?: StringNullableFilter<"Company"> | string | null
    postalCode?: StringNullableFilter<"Company"> | string | null
    registerdCapital?: FloatNullableFilter<"Company"> | number | null
    employeeCount?: IntNullableFilter<"Company"> | number | null
    phoneNumber?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    logo?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    industries?: StringNullableListFilter<"Company">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    industriesRelated?: CompanyIndustryListRelationFilter
    companyRevenue?: CompanyRevenueListRelationFilter
    RevenueStream?: RevenueStreamListRelationFilter
    Portfolio?: PortfolioListRelationFilter
  }, "id" | "juristicId" | "userId">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    juristicId?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    registerdCapital?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industries?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    juristicId?: StringWithAggregatesFilter<"Company"> | string
    nameTh?: StringWithAggregatesFilter<"Company"> | string
    nameEn?: StringNullableWithAggregatesFilter<"Company"> | string | null
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    image?: StringNullableWithAggregatesFilter<"Company"> | string | null
    cover_image?: StringNullableWithAggregatesFilter<"Company"> | string | null
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    subDistrict?: StringNullableWithAggregatesFilter<"Company"> | string | null
    district?: StringNullableWithAggregatesFilter<"Company"> | string | null
    province?: StringNullableWithAggregatesFilter<"Company"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Company"> | string | null
    registerdCapital?: FloatNullableWithAggregatesFilter<"Company"> | number | null
    employeeCount?: IntNullableWithAggregatesFilter<"Company"> | number | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    userId?: UuidWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    industries?: StringNullableListFilter<"Company">
  }

  export type CompanyIndustryWhereInput = {
    AND?: CompanyIndustryWhereInput | CompanyIndustryWhereInput[]
    OR?: CompanyIndustryWhereInput[]
    NOT?: CompanyIndustryWhereInput | CompanyIndustryWhereInput[]
    companyId?: UuidFilter<"CompanyIndustry"> | string
    industrySlug?: StringFilter<"CompanyIndustry"> | string
    createdAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }

  export type CompanyIndustryOrderByWithRelationInput = {
    companyId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    industry?: IndustryOrderByWithRelationInput
  }

  export type CompanyIndustryWhereUniqueInput = Prisma.AtLeast<{
    companyId_industrySlug?: CompanyIndustryCompanyIdIndustrySlugCompoundUniqueInput
    AND?: CompanyIndustryWhereInput | CompanyIndustryWhereInput[]
    OR?: CompanyIndustryWhereInput[]
    NOT?: CompanyIndustryWhereInput | CompanyIndustryWhereInput[]
    companyId?: UuidFilter<"CompanyIndustry"> | string
    industrySlug?: StringFilter<"CompanyIndustry"> | string
    createdAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }, "companyId_industrySlug">

  export type CompanyIndustryOrderByWithAggregationInput = {
    companyId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyIndustryCountOrderByAggregateInput
    _max?: CompanyIndustryMaxOrderByAggregateInput
    _min?: CompanyIndustryMinOrderByAggregateInput
  }

  export type CompanyIndustryScalarWhereWithAggregatesInput = {
    AND?: CompanyIndustryScalarWhereWithAggregatesInput | CompanyIndustryScalarWhereWithAggregatesInput[]
    OR?: CompanyIndustryScalarWhereWithAggregatesInput[]
    NOT?: CompanyIndustryScalarWhereWithAggregatesInput | CompanyIndustryScalarWhereWithAggregatesInput[]
    companyId?: UuidWithAggregatesFilter<"CompanyIndustry"> | string
    industrySlug?: StringWithAggregatesFilter<"CompanyIndustry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyIndustry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyIndustry"> | Date | string
  }

  export type FreelanceWhereInput = {
    AND?: FreelanceWhereInput | FreelanceWhereInput[]
    OR?: FreelanceWhereInput[]
    NOT?: FreelanceWhereInput | FreelanceWhereInput[]
    id?: UuidFilter<"Freelance"> | string
    firstNameTh?: StringFilter<"Freelance"> | string
    lastNameTh?: StringFilter<"Freelance"> | string
    firstNameEn?: StringNullableFilter<"Freelance"> | string | null
    lastNameEn?: StringNullableFilter<"Freelance"> | string | null
    image?: StringNullableFilter<"Freelance"> | string | null
    cover_image?: StringNullableFilter<"Freelance"> | string | null
    address?: StringNullableFilter<"Freelance"> | string | null
    subDistrict?: StringNullableFilter<"Freelance"> | string | null
    district?: StringNullableFilter<"Freelance"> | string | null
    province?: StringNullableFilter<"Freelance"> | string | null
    postalCode?: StringNullableFilter<"Freelance"> | string | null
    phoneNumber?: StringNullableFilter<"Freelance"> | string | null
    email?: StringNullableFilter<"Freelance"> | string | null
    juristicId?: StringNullableFilter<"Freelance"> | string | null
    industryTypes?: StringNullableListFilter<"Freelance">
    createdAt?: DateTimeFilter<"Freelance"> | Date | string
    updatedAt?: DateTimeFilter<"Freelance"> | Date | string
    userId?: UuidFilter<"Freelance"> | string
    industriesRelated?: FreelanceIndustryListRelationFilter
    skills?: SkillListRelationFilter
    freelanceRevenue?: FreelanceRevenueListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Portfolio?: PortfolioListRelationFilter
  }

  export type FreelanceOrderByWithRelationInput = {
    id?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    firstNameEn?: SortOrderInput | SortOrder
    lastNameEn?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    juristicId?: SortOrderInput | SortOrder
    industryTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    industriesRelated?: FreelanceIndustryOrderByRelationAggregateInput
    skills?: SkillOrderByRelationAggregateInput
    freelanceRevenue?: FreelanceRevenueOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    Portfolio?: PortfolioOrderByRelationAggregateInput
  }

  export type FreelanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    juristicId?: string
    userId?: string
    AND?: FreelanceWhereInput | FreelanceWhereInput[]
    OR?: FreelanceWhereInput[]
    NOT?: FreelanceWhereInput | FreelanceWhereInput[]
    firstNameTh?: StringFilter<"Freelance"> | string
    lastNameTh?: StringFilter<"Freelance"> | string
    firstNameEn?: StringNullableFilter<"Freelance"> | string | null
    lastNameEn?: StringNullableFilter<"Freelance"> | string | null
    image?: StringNullableFilter<"Freelance"> | string | null
    cover_image?: StringNullableFilter<"Freelance"> | string | null
    address?: StringNullableFilter<"Freelance"> | string | null
    subDistrict?: StringNullableFilter<"Freelance"> | string | null
    district?: StringNullableFilter<"Freelance"> | string | null
    province?: StringNullableFilter<"Freelance"> | string | null
    postalCode?: StringNullableFilter<"Freelance"> | string | null
    phoneNumber?: StringNullableFilter<"Freelance"> | string | null
    industryTypes?: StringNullableListFilter<"Freelance">
    createdAt?: DateTimeFilter<"Freelance"> | Date | string
    updatedAt?: DateTimeFilter<"Freelance"> | Date | string
    industriesRelated?: FreelanceIndustryListRelationFilter
    skills?: SkillListRelationFilter
    freelanceRevenue?: FreelanceRevenueListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Portfolio?: PortfolioListRelationFilter
  }, "id" | "email" | "juristicId" | "userId">

  export type FreelanceOrderByWithAggregationInput = {
    id?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    firstNameEn?: SortOrderInput | SortOrder
    lastNameEn?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subDistrict?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    juristicId?: SortOrderInput | SortOrder
    industryTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: FreelanceCountOrderByAggregateInput
    _max?: FreelanceMaxOrderByAggregateInput
    _min?: FreelanceMinOrderByAggregateInput
  }

  export type FreelanceScalarWhereWithAggregatesInput = {
    AND?: FreelanceScalarWhereWithAggregatesInput | FreelanceScalarWhereWithAggregatesInput[]
    OR?: FreelanceScalarWhereWithAggregatesInput[]
    NOT?: FreelanceScalarWhereWithAggregatesInput | FreelanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Freelance"> | string
    firstNameTh?: StringWithAggregatesFilter<"Freelance"> | string
    lastNameTh?: StringWithAggregatesFilter<"Freelance"> | string
    firstNameEn?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    lastNameEn?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    image?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    cover_image?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    address?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    subDistrict?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    district?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    province?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    email?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    juristicId?: StringNullableWithAggregatesFilter<"Freelance"> | string | null
    industryTypes?: StringNullableListFilter<"Freelance">
    createdAt?: DateTimeWithAggregatesFilter<"Freelance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Freelance"> | Date | string
    userId?: UuidWithAggregatesFilter<"Freelance"> | string
  }

  export type FreelanceIndustryWhereInput = {
    AND?: FreelanceIndustryWhereInput | FreelanceIndustryWhereInput[]
    OR?: FreelanceIndustryWhereInput[]
    NOT?: FreelanceIndustryWhereInput | FreelanceIndustryWhereInput[]
    freelanceId?: UuidFilter<"FreelanceIndustry"> | string
    industrySlug?: StringFilter<"FreelanceIndustry"> | string
    createdAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
    freelance?: XOR<FreelanceScalarRelationFilter, FreelanceWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }

  export type FreelanceIndustryOrderByWithRelationInput = {
    freelanceId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelance?: FreelanceOrderByWithRelationInput
    industry?: IndustryOrderByWithRelationInput
  }

  export type FreelanceIndustryWhereUniqueInput = Prisma.AtLeast<{
    freelanceId_industrySlug?: FreelanceIndustryFreelanceIdIndustrySlugCompoundUniqueInput
    AND?: FreelanceIndustryWhereInput | FreelanceIndustryWhereInput[]
    OR?: FreelanceIndustryWhereInput[]
    NOT?: FreelanceIndustryWhereInput | FreelanceIndustryWhereInput[]
    freelanceId?: UuidFilter<"FreelanceIndustry"> | string
    industrySlug?: StringFilter<"FreelanceIndustry"> | string
    createdAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
    freelance?: XOR<FreelanceScalarRelationFilter, FreelanceWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }, "freelanceId_industrySlug">

  export type FreelanceIndustryOrderByWithAggregationInput = {
    freelanceId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelanceIndustryCountOrderByAggregateInput
    _max?: FreelanceIndustryMaxOrderByAggregateInput
    _min?: FreelanceIndustryMinOrderByAggregateInput
  }

  export type FreelanceIndustryScalarWhereWithAggregatesInput = {
    AND?: FreelanceIndustryScalarWhereWithAggregatesInput | FreelanceIndustryScalarWhereWithAggregatesInput[]
    OR?: FreelanceIndustryScalarWhereWithAggregatesInput[]
    NOT?: FreelanceIndustryScalarWhereWithAggregatesInput | FreelanceIndustryScalarWhereWithAggregatesInput[]
    freelanceId?: UuidWithAggregatesFilter<"FreelanceIndustry"> | string
    industrySlug?: StringWithAggregatesFilter<"FreelanceIndustry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FreelanceIndustry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelanceIndustry"> | Date | string
  }

  export type IndustryWhereInput = {
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    id?: UuidFilter<"Industry"> | string
    name?: StringFilter<"Industry"> | string
    slug?: StringFilter<"Industry"> | string
    createdAt?: DateTimeFilter<"Industry"> | Date | string
    updatedAt?: DateTimeFilter<"Industry"> | Date | string
    Skill?: SkillListRelationFilter
    Source?: SourceListRelationFilter
    Channel?: ChannelListRelationFilter
    Segment?: SegmentListRelationFilter
    Category?: CategoryListRelationFilter
    companies?: CompanyIndustryListRelationFilter
    freelancers?: FreelanceIndustryListRelationFilter
    users?: UserIndustryListRelationFilter
    Standards?: StandardsListRelationFilter
    RevenueStream?: RevenueStreamListRelationFilter
    Tag?: TagListRelationFilter
    LookingFor?: LookingForListRelationFilter
  }

  export type IndustryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Skill?: SkillOrderByRelationAggregateInput
    Source?: SourceOrderByRelationAggregateInput
    Channel?: ChannelOrderByRelationAggregateInput
    Segment?: SegmentOrderByRelationAggregateInput
    Category?: CategoryOrderByRelationAggregateInput
    companies?: CompanyIndustryOrderByRelationAggregateInput
    freelancers?: FreelanceIndustryOrderByRelationAggregateInput
    users?: UserIndustryOrderByRelationAggregateInput
    Standards?: StandardsOrderByRelationAggregateInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
    Tag?: TagOrderByRelationAggregateInput
    LookingFor?: LookingForOrderByRelationAggregateInput
  }

  export type IndustryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    name?: StringFilter<"Industry"> | string
    createdAt?: DateTimeFilter<"Industry"> | Date | string
    updatedAt?: DateTimeFilter<"Industry"> | Date | string
    Skill?: SkillListRelationFilter
    Source?: SourceListRelationFilter
    Channel?: ChannelListRelationFilter
    Segment?: SegmentListRelationFilter
    Category?: CategoryListRelationFilter
    companies?: CompanyIndustryListRelationFilter
    freelancers?: FreelanceIndustryListRelationFilter
    users?: UserIndustryListRelationFilter
    Standards?: StandardsListRelationFilter
    RevenueStream?: RevenueStreamListRelationFilter
    Tag?: TagListRelationFilter
    LookingFor?: LookingForListRelationFilter
  }, "id" | "slug">

  export type IndustryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndustryCountOrderByAggregateInput
    _max?: IndustryMaxOrderByAggregateInput
    _min?: IndustryMinOrderByAggregateInput
  }

  export type IndustryScalarWhereWithAggregatesInput = {
    AND?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    OR?: IndustryScalarWhereWithAggregatesInput[]
    NOT?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Industry"> | string
    name?: StringWithAggregatesFilter<"Industry"> | string
    slug?: StringWithAggregatesFilter<"Industry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Industry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Industry"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    industrySlug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioTag?: PortfolioTagListRelationFilter
    UserTags?: UserTagsListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    PortfolioTag?: PortfolioTagOrderByRelationAggregateInput
    UserTags?: UserTagsOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    industrySlug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioTag?: PortfolioTagListRelationFilter
    UserTags?: UserTagsListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    industrySlug?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type LookingForWhereInput = {
    AND?: LookingForWhereInput | LookingForWhereInput[]
    OR?: LookingForWhereInput[]
    NOT?: LookingForWhereInput | LookingForWhereInput[]
    id?: UuidFilter<"LookingFor"> | string
    name?: StringFilter<"LookingFor"> | string
    slug?: StringFilter<"LookingFor"> | string
    industrySlug?: StringFilter<"LookingFor"> | string
    createdAt?: DateTimeFilter<"LookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"LookingFor"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioLookingFor?: PortfolioLookingForListRelationFilter
  }

  export type LookingForOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    PortfolioLookingFor?: PortfolioLookingForOrderByRelationAggregateInput
  }

  export type LookingForWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LookingForWhereInput | LookingForWhereInput[]
    OR?: LookingForWhereInput[]
    NOT?: LookingForWhereInput | LookingForWhereInput[]
    name?: StringFilter<"LookingFor"> | string
    industrySlug?: StringFilter<"LookingFor"> | string
    createdAt?: DateTimeFilter<"LookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"LookingFor"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioLookingFor?: PortfolioLookingForListRelationFilter
  }, "id" | "slug">

  export type LookingForOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LookingForCountOrderByAggregateInput
    _max?: LookingForMaxOrderByAggregateInput
    _min?: LookingForMinOrderByAggregateInput
  }

  export type LookingForScalarWhereWithAggregatesInput = {
    AND?: LookingForScalarWhereWithAggregatesInput | LookingForScalarWhereWithAggregatesInput[]
    OR?: LookingForScalarWhereWithAggregatesInput[]
    NOT?: LookingForScalarWhereWithAggregatesInput | LookingForScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LookingFor"> | string
    name?: StringWithAggregatesFilter<"LookingFor"> | string
    slug?: StringWithAggregatesFilter<"LookingFor"> | string
    industrySlug?: StringWithAggregatesFilter<"LookingFor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LookingFor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LookingFor"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: UuidFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    industrySlug?: StringFilter<"Category"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_industrySlug?: CategorySlugIndustrySlugCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    industrySlug?: StringFilter<"Category"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }, "id" | "slug" | "slug_industrySlug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    industrySlug?: StringWithAggregatesFilter<"Category"> | string
  }

  export type SourceWhereInput = {
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    id?: UuidFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    slug?: StringFilter<"Source"> | string
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
    industrySlug?: StringFilter<"Source"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_industrySlug?: SourceSlugIndustrySlugCompoundUniqueInput
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    name?: StringFilter<"Source"> | string
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
    industrySlug?: StringFilter<"Source"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }, "id" | "slug" | "slug_industrySlug">

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    OR?: SourceScalarWhereWithAggregatesInput[]
    NOT?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Source"> | string
    name?: StringWithAggregatesFilter<"Source"> | string
    slug?: StringWithAggregatesFilter<"Source"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Source"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Source"> | Date | string
    industrySlug?: StringWithAggregatesFilter<"Source"> | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: UuidFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    slug?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    industrySlug?: StringFilter<"Channel"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
    UserChannels?: UserChannelsListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
    UserChannels?: UserChannelsOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_industrySlug?: ChannelSlugIndustrySlugCompoundUniqueInput
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    industrySlug?: StringFilter<"Channel"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
    UserChannels?: UserChannelsListRelationFilter
  }, "id" | "slug" | "slug_industrySlug">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    slug?: StringWithAggregatesFilter<"Channel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    industrySlug?: StringWithAggregatesFilter<"Channel"> | string
  }

  export type SegmentWhereInput = {
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    id?: UuidFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    slug?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    industrySlug?: StringFilter<"Segment"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }

  export type SegmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    RevenueStream?: RevenueStreamOrderByRelationAggregateInput
  }

  export type SegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_industrySlug?: SegmentSlugIndustrySlugCompoundUniqueInput
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    name?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    industrySlug?: StringFilter<"Segment"> | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    RevenueStream?: RevenueStreamListRelationFilter
  }, "id" | "slug" | "slug_industrySlug">

  export type SegmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
    _count?: SegmentCountOrderByAggregateInput
    _max?: SegmentMaxOrderByAggregateInput
    _min?: SegmentMinOrderByAggregateInput
  }

  export type SegmentScalarWhereWithAggregatesInput = {
    AND?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    OR?: SegmentScalarWhereWithAggregatesInput[]
    NOT?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Segment"> | string
    name?: StringWithAggregatesFilter<"Segment"> | string
    slug?: StringWithAggregatesFilter<"Segment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    industrySlug?: StringWithAggregatesFilter<"Segment"> | string
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: UuidFilter<"Portfolio"> | string
    title?: StringFilter<"Portfolio"> | string
    title_en?: StringNullableFilter<"Portfolio"> | string | null
    description?: StringNullableFilter<"Portfolio"> | string | null
    description_en?: StringNullableFilter<"Portfolio"> | string | null
    cover_image?: StringNullableFilter<"Portfolio"> | string | null
    link?: StringNullableFilter<"Portfolio"> | string | null
    industryTypeSlug?: StringFilter<"Portfolio"> | string
    tags?: StringNullableListFilter<"Portfolio">
    looking_for?: StringNullableListFilter<"Portfolio">
    freelanceId?: UuidNullableFilter<"Portfolio"> | string | null
    companyId?: UuidNullableFilter<"Portfolio"> | string | null
    companyJuristicId?: StringNullableFilter<"Portfolio"> | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    industryTags?: PortfolioTagListRelationFilter
    industryLookingFor?: PortfolioLookingForListRelationFilter
    freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    Favorite?: FavoriteListRelationFilter
    Image?: PortfolioImageListRelationFilter
    standards?: PortfolioStandardsListRelationFilter
    comments?: PortfolioCommentListRelationFilter
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    title_en?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    description_en?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    industryTypeSlug?: SortOrder
    tags?: SortOrder
    looking_for?: SortOrder
    freelanceId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyJuristicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industryTags?: PortfolioTagOrderByRelationAggregateInput
    industryLookingFor?: PortfolioLookingForOrderByRelationAggregateInput
    freelance?: FreelanceOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    Favorite?: FavoriteOrderByRelationAggregateInput
    Image?: PortfolioImageOrderByRelationAggregateInput
    standards?: PortfolioStandardsOrderByRelationAggregateInput
    comments?: PortfolioCommentOrderByRelationAggregateInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    title?: StringFilter<"Portfolio"> | string
    title_en?: StringNullableFilter<"Portfolio"> | string | null
    description?: StringNullableFilter<"Portfolio"> | string | null
    description_en?: StringNullableFilter<"Portfolio"> | string | null
    cover_image?: StringNullableFilter<"Portfolio"> | string | null
    link?: StringNullableFilter<"Portfolio"> | string | null
    industryTypeSlug?: StringFilter<"Portfolio"> | string
    tags?: StringNullableListFilter<"Portfolio">
    looking_for?: StringNullableListFilter<"Portfolio">
    freelanceId?: UuidNullableFilter<"Portfolio"> | string | null
    companyId?: UuidNullableFilter<"Portfolio"> | string | null
    companyJuristicId?: StringNullableFilter<"Portfolio"> | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    industryTags?: PortfolioTagListRelationFilter
    industryLookingFor?: PortfolioLookingForListRelationFilter
    freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    Favorite?: FavoriteListRelationFilter
    Image?: PortfolioImageListRelationFilter
    standards?: PortfolioStandardsListRelationFilter
    comments?: PortfolioCommentListRelationFilter
  }, "id">

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    title_en?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    description_en?: SortOrderInput | SortOrder
    cover_image?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    industryTypeSlug?: SortOrder
    tags?: SortOrder
    looking_for?: SortOrder
    freelanceId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyJuristicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Portfolio"> | string
    title?: StringWithAggregatesFilter<"Portfolio"> | string
    title_en?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    description?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    description_en?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    cover_image?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    link?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    industryTypeSlug?: StringWithAggregatesFilter<"Portfolio"> | string
    tags?: StringNullableListFilter<"Portfolio">
    looking_for?: StringNullableListFilter<"Portfolio">
    freelanceId?: UuidNullableWithAggregatesFilter<"Portfolio"> | string | null
    companyId?: UuidNullableWithAggregatesFilter<"Portfolio"> | string | null
    companyJuristicId?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
  }

  export type PortfolioTagWhereInput = {
    AND?: PortfolioTagWhereInput | PortfolioTagWhereInput[]
    OR?: PortfolioTagWhereInput[]
    NOT?: PortfolioTagWhereInput | PortfolioTagWhereInput[]
    portfolioId?: UuidFilter<"PortfolioTag"> | string
    tagSlug?: StringFilter<"PortfolioTag"> | string
    createdAt?: DateTimeFilter<"PortfolioTag"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioTag"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PortfolioTagOrderByWithRelationInput = {
    portfolioId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PortfolioTagWhereUniqueInput = Prisma.AtLeast<{
    portfolioId_tagSlug?: PortfolioTagPortfolioIdTagSlugCompoundUniqueInput
    AND?: PortfolioTagWhereInput | PortfolioTagWhereInput[]
    OR?: PortfolioTagWhereInput[]
    NOT?: PortfolioTagWhereInput | PortfolioTagWhereInput[]
    portfolioId?: UuidFilter<"PortfolioTag"> | string
    tagSlug?: StringFilter<"PortfolioTag"> | string
    createdAt?: DateTimeFilter<"PortfolioTag"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioTag"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "portfolioId_tagSlug">

  export type PortfolioTagOrderByWithAggregationInput = {
    portfolioId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioTagCountOrderByAggregateInput
    _max?: PortfolioTagMaxOrderByAggregateInput
    _min?: PortfolioTagMinOrderByAggregateInput
  }

  export type PortfolioTagScalarWhereWithAggregatesInput = {
    AND?: PortfolioTagScalarWhereWithAggregatesInput | PortfolioTagScalarWhereWithAggregatesInput[]
    OR?: PortfolioTagScalarWhereWithAggregatesInput[]
    NOT?: PortfolioTagScalarWhereWithAggregatesInput | PortfolioTagScalarWhereWithAggregatesInput[]
    portfolioId?: UuidWithAggregatesFilter<"PortfolioTag"> | string
    tagSlug?: StringWithAggregatesFilter<"PortfolioTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioTag"> | Date | string
  }

  export type PortfolioLookingForWhereInput = {
    AND?: PortfolioLookingForWhereInput | PortfolioLookingForWhereInput[]
    OR?: PortfolioLookingForWhereInput[]
    NOT?: PortfolioLookingForWhereInput | PortfolioLookingForWhereInput[]
    portfolioId?: UuidFilter<"PortfolioLookingFor"> | string
    lookingForSlug?: StringFilter<"PortfolioLookingFor"> | string
    createdAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    lookingFor?: XOR<LookingForScalarRelationFilter, LookingForWhereInput>
  }

  export type PortfolioLookingForOrderByWithRelationInput = {
    portfolioId?: SortOrder
    lookingForSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    lookingFor?: LookingForOrderByWithRelationInput
  }

  export type PortfolioLookingForWhereUniqueInput = Prisma.AtLeast<{
    portfolioId_lookingForSlug?: PortfolioLookingForPortfolioIdLookingForSlugCompoundUniqueInput
    AND?: PortfolioLookingForWhereInput | PortfolioLookingForWhereInput[]
    OR?: PortfolioLookingForWhereInput[]
    NOT?: PortfolioLookingForWhereInput | PortfolioLookingForWhereInput[]
    portfolioId?: UuidFilter<"PortfolioLookingFor"> | string
    lookingForSlug?: StringFilter<"PortfolioLookingFor"> | string
    createdAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    lookingFor?: XOR<LookingForScalarRelationFilter, LookingForWhereInput>
  }, "portfolioId_lookingForSlug">

  export type PortfolioLookingForOrderByWithAggregationInput = {
    portfolioId?: SortOrder
    lookingForSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioLookingForCountOrderByAggregateInput
    _max?: PortfolioLookingForMaxOrderByAggregateInput
    _min?: PortfolioLookingForMinOrderByAggregateInput
  }

  export type PortfolioLookingForScalarWhereWithAggregatesInput = {
    AND?: PortfolioLookingForScalarWhereWithAggregatesInput | PortfolioLookingForScalarWhereWithAggregatesInput[]
    OR?: PortfolioLookingForScalarWhereWithAggregatesInput[]
    NOT?: PortfolioLookingForScalarWhereWithAggregatesInput | PortfolioLookingForScalarWhereWithAggregatesInput[]
    portfolioId?: UuidWithAggregatesFilter<"PortfolioLookingFor"> | string
    lookingForSlug?: StringWithAggregatesFilter<"PortfolioLookingFor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioLookingFor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioLookingFor"> | Date | string
  }

  export type PortfolioStandardsWhereInput = {
    AND?: PortfolioStandardsWhereInput | PortfolioStandardsWhereInput[]
    OR?: PortfolioStandardsWhereInput[]
    NOT?: PortfolioStandardsWhereInput | PortfolioStandardsWhereInput[]
    id?: UuidFilter<"PortfolioStandards"> | string
    portfolioId?: UuidFilter<"PortfolioStandards"> | string
    standardsId?: UuidFilter<"PortfolioStandards"> | string
    createdAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    standards?: XOR<StandardsScalarRelationFilter, StandardsWhereInput>
  }

  export type PortfolioStandardsOrderByWithRelationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    standardsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    standards?: StandardsOrderByWithRelationInput
  }

  export type PortfolioStandardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portfolioId_standardsId?: PortfolioStandardsPortfolioIdStandardsIdCompoundUniqueInput
    AND?: PortfolioStandardsWhereInput | PortfolioStandardsWhereInput[]
    OR?: PortfolioStandardsWhereInput[]
    NOT?: PortfolioStandardsWhereInput | PortfolioStandardsWhereInput[]
    portfolioId?: UuidFilter<"PortfolioStandards"> | string
    standardsId?: UuidFilter<"PortfolioStandards"> | string
    createdAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    standards?: XOR<StandardsScalarRelationFilter, StandardsWhereInput>
  }, "id" | "portfolioId_standardsId">

  export type PortfolioStandardsOrderByWithAggregationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    standardsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioStandardsCountOrderByAggregateInput
    _max?: PortfolioStandardsMaxOrderByAggregateInput
    _min?: PortfolioStandardsMinOrderByAggregateInput
  }

  export type PortfolioStandardsScalarWhereWithAggregatesInput = {
    AND?: PortfolioStandardsScalarWhereWithAggregatesInput | PortfolioStandardsScalarWhereWithAggregatesInput[]
    OR?: PortfolioStandardsScalarWhereWithAggregatesInput[]
    NOT?: PortfolioStandardsScalarWhereWithAggregatesInput | PortfolioStandardsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PortfolioStandards"> | string
    portfolioId?: UuidWithAggregatesFilter<"PortfolioStandards"> | string
    standardsId?: UuidWithAggregatesFilter<"PortfolioStandards"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioStandards"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioStandards"> | Date | string
  }

  export type PortfolioImageWhereInput = {
    AND?: PortfolioImageWhereInput | PortfolioImageWhereInput[]
    OR?: PortfolioImageWhereInput[]
    NOT?: PortfolioImageWhereInput | PortfolioImageWhereInput[]
    id?: UuidFilter<"PortfolioImage"> | string
    url?: StringFilter<"PortfolioImage"> | string
    description?: StringNullableFilter<"PortfolioImage"> | string | null
    type?: EnumPortfolioImageTypeFilter<"PortfolioImage"> | $Enums.PortfolioImageType
    portfolioId?: UuidFilter<"PortfolioImage"> | string
    createdAt?: DateTimeFilter<"PortfolioImage"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioImage"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
  }

  export type PortfolioImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    portfolioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
  }

  export type PortfolioImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioImageWhereInput | PortfolioImageWhereInput[]
    OR?: PortfolioImageWhereInput[]
    NOT?: PortfolioImageWhereInput | PortfolioImageWhereInput[]
    url?: StringFilter<"PortfolioImage"> | string
    description?: StringNullableFilter<"PortfolioImage"> | string | null
    type?: EnumPortfolioImageTypeFilter<"PortfolioImage"> | $Enums.PortfolioImageType
    portfolioId?: UuidFilter<"PortfolioImage"> | string
    createdAt?: DateTimeFilter<"PortfolioImage"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioImage"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
  }, "id">

  export type PortfolioImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    portfolioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioImageCountOrderByAggregateInput
    _max?: PortfolioImageMaxOrderByAggregateInput
    _min?: PortfolioImageMinOrderByAggregateInput
  }

  export type PortfolioImageScalarWhereWithAggregatesInput = {
    AND?: PortfolioImageScalarWhereWithAggregatesInput | PortfolioImageScalarWhereWithAggregatesInput[]
    OR?: PortfolioImageScalarWhereWithAggregatesInput[]
    NOT?: PortfolioImageScalarWhereWithAggregatesInput | PortfolioImageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PortfolioImage"> | string
    url?: StringWithAggregatesFilter<"PortfolioImage"> | string
    description?: StringNullableWithAggregatesFilter<"PortfolioImage"> | string | null
    type?: EnumPortfolioImageTypeWithAggregatesFilter<"PortfolioImage"> | $Enums.PortfolioImageType
    portfolioId?: UuidWithAggregatesFilter<"PortfolioImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioImage"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    portfolioId?: UuidFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    action?: EnumFavoriteActionFilter<"Favorite"> | $Enums.FavoriteAction
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    updatedAt?: DateTimeFilter<"Favorite"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_portfolioId?: FavoriteUserIdPortfolioIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    portfolioId?: UuidFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    action?: EnumFavoriteActionFilter<"Favorite"> | $Enums.FavoriteAction
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    updatedAt?: DateTimeFilter<"Favorite"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_portfolioId">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Favorite"> | string
    portfolioId?: UuidWithAggregatesFilter<"Favorite"> | string
    userId?: UuidWithAggregatesFilter<"Favorite"> | string
    action?: EnumFavoriteActionWithAggregatesFilter<"Favorite"> | $Enums.FavoriteAction
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type StandardsWhereInput = {
    AND?: StandardsWhereInput | StandardsWhereInput[]
    OR?: StandardsWhereInput[]
    NOT?: StandardsWhereInput | StandardsWhereInput[]
    id?: UuidFilter<"Standards"> | string
    name?: StringFilter<"Standards"> | string
    description?: StringNullableFilter<"Standards"> | string | null
    type?: EnumStandardsTypeFilter<"Standards"> | $Enums.StandardsType
    industrySlug?: StringFilter<"Standards"> | string
    image?: StringNullableFilter<"Standards"> | string | null
    createdAt?: DateTimeFilter<"Standards"> | Date | string
    updatedAt?: DateTimeFilter<"Standards"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioStandards?: PortfolioStandardsListRelationFilter
  }

  export type StandardsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    industrySlug?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industry?: IndustryOrderByWithRelationInput
    PortfolioStandards?: PortfolioStandardsOrderByRelationAggregateInput
  }

  export type StandardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StandardsWhereInput | StandardsWhereInput[]
    OR?: StandardsWhereInput[]
    NOT?: StandardsWhereInput | StandardsWhereInput[]
    name?: StringFilter<"Standards"> | string
    description?: StringNullableFilter<"Standards"> | string | null
    type?: EnumStandardsTypeFilter<"Standards"> | $Enums.StandardsType
    industrySlug?: StringFilter<"Standards"> | string
    image?: StringNullableFilter<"Standards"> | string | null
    createdAt?: DateTimeFilter<"Standards"> | Date | string
    updatedAt?: DateTimeFilter<"Standards"> | Date | string
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    PortfolioStandards?: PortfolioStandardsListRelationFilter
  }, "id">

  export type StandardsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    industrySlug?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardsCountOrderByAggregateInput
    _max?: StandardsMaxOrderByAggregateInput
    _min?: StandardsMinOrderByAggregateInput
  }

  export type StandardsScalarWhereWithAggregatesInput = {
    AND?: StandardsScalarWhereWithAggregatesInput | StandardsScalarWhereWithAggregatesInput[]
    OR?: StandardsScalarWhereWithAggregatesInput[]
    NOT?: StandardsScalarWhereWithAggregatesInput | StandardsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Standards"> | string
    name?: StringWithAggregatesFilter<"Standards"> | string
    description?: StringNullableWithAggregatesFilter<"Standards"> | string | null
    type?: EnumStandardsTypeWithAggregatesFilter<"Standards"> | $Enums.StandardsType
    industrySlug?: StringWithAggregatesFilter<"Standards"> | string
    image?: StringNullableWithAggregatesFilter<"Standards"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Standards"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Standards"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: UuidFilter<"Skill"> | string
    title?: StringFilter<"Skill"> | string
    slug?: StringFilter<"Skill"> | string
    group?: StringNullableFilter<"Skill"> | string | null
    industrySlug?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    freelanceId?: UuidNullableFilter<"Skill"> | string | null
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    Freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    UserSkills?: UserSkillsListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    group?: SortOrderInput | SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelanceId?: SortOrderInput | SortOrder
    industry?: IndustryOrderByWithRelationInput
    Freelance?: FreelanceOrderByWithRelationInput
    UserSkills?: UserSkillsOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_industrySlug?: SkillSlugIndustrySlugCompoundUniqueInput
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    title?: StringFilter<"Skill"> | string
    group?: StringNullableFilter<"Skill"> | string | null
    industrySlug?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    freelanceId?: UuidNullableFilter<"Skill"> | string | null
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
    Freelance?: XOR<FreelanceNullableScalarRelationFilter, FreelanceWhereInput> | null
    UserSkills?: UserSkillsListRelationFilter
  }, "id" | "slug" | "slug_industrySlug">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    group?: SortOrderInput | SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelanceId?: SortOrderInput | SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Skill"> | string
    title?: StringWithAggregatesFilter<"Skill"> | string
    slug?: StringWithAggregatesFilter<"Skill"> | string
    group?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    industrySlug?: StringWithAggregatesFilter<"Skill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    freelanceId?: UuidNullableWithAggregatesFilter<"Skill"> | string | null
  }

  export type PortfolioCommentWhereInput = {
    AND?: PortfolioCommentWhereInput | PortfolioCommentWhereInput[]
    OR?: PortfolioCommentWhereInput[]
    NOT?: PortfolioCommentWhereInput | PortfolioCommentWhereInput[]
    id?: UuidFilter<"PortfolioComment"> | string
    content?: StringFilter<"PortfolioComment"> | string
    portfolioId?: UuidFilter<"PortfolioComment"> | string
    userId?: UuidFilter<"PortfolioComment"> | string
    parentId?: UuidNullableFilter<"PortfolioComment"> | string | null
    createdAt?: DateTimeFilter<"PortfolioComment"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioComment"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<PortfolioCommentNullableScalarRelationFilter, PortfolioCommentWhereInput> | null
    replies?: PortfolioCommentListRelationFilter
  }

  export type PortfolioCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: PortfolioCommentOrderByWithRelationInput
    replies?: PortfolioCommentOrderByRelationAggregateInput
  }

  export type PortfolioCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioCommentWhereInput | PortfolioCommentWhereInput[]
    OR?: PortfolioCommentWhereInput[]
    NOT?: PortfolioCommentWhereInput | PortfolioCommentWhereInput[]
    content?: StringFilter<"PortfolioComment"> | string
    portfolioId?: UuidFilter<"PortfolioComment"> | string
    userId?: UuidFilter<"PortfolioComment"> | string
    parentId?: UuidNullableFilter<"PortfolioComment"> | string | null
    createdAt?: DateTimeFilter<"PortfolioComment"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioComment"> | Date | string
    portfolio?: XOR<PortfolioScalarRelationFilter, PortfolioWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<PortfolioCommentNullableScalarRelationFilter, PortfolioCommentWhereInput> | null
    replies?: PortfolioCommentListRelationFilter
  }, "id">

  export type PortfolioCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioCommentCountOrderByAggregateInput
    _max?: PortfolioCommentMaxOrderByAggregateInput
    _min?: PortfolioCommentMinOrderByAggregateInput
  }

  export type PortfolioCommentScalarWhereWithAggregatesInput = {
    AND?: PortfolioCommentScalarWhereWithAggregatesInput | PortfolioCommentScalarWhereWithAggregatesInput[]
    OR?: PortfolioCommentScalarWhereWithAggregatesInput[]
    NOT?: PortfolioCommentScalarWhereWithAggregatesInput | PortfolioCommentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PortfolioComment"> | string
    content?: StringWithAggregatesFilter<"PortfolioComment"> | string
    portfolioId?: UuidWithAggregatesFilter<"PortfolioComment"> | string
    userId?: UuidWithAggregatesFilter<"PortfolioComment"> | string
    parentId?: UuidNullableWithAggregatesFilter<"PortfolioComment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioComment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustryTagsInput
    tag: TagCreateNestedOneWithoutUserTagsInput
  }

  export type UserTagsUncheckedCreateInput = {
    userId: string
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustryTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutUserTagsNestedInput
  }

  export type UserTagsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsCreateManyInput = {
    userId: string
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustryChannelsInput
    channel: ChannelCreateNestedOneWithoutUserChannelsInput
  }

  export type UserChannelsUncheckedCreateInput = {
    userId: string
    channelSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustryChannelsNestedInput
    channel?: ChannelUpdateOneRequiredWithoutUserChannelsNestedInput
  }

  export type UserChannelsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsCreateManyInput = {
    userId: string
    channelSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustrySkillsInput
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillsUncheckedCreateInput = {
    userId: string
    skillSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustrySkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skillSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsCreateManyInput = {
    userId: string
    skillSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    skillSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustriesRelatedInput
    industry: IndustryCreateNestedOneWithoutUsersInput
  }

  export type UserIndustryUncheckedCreateInput = {
    id?: string
    userId: string
    industryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIndustryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustriesRelatedNestedInput
    industry?: IndustryUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserIndustryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    industryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryCreateManyInput = {
    id?: string
    userId: string
    industryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIndustryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    industryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyRevenueCreateInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCompanyRevenueInput
  }

  export type CompanyRevenueUncheckedCreateInput = {
    id?: string
    year: number
    total: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRevenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCompanyRevenueNestedInput
  }

  export type CompanyRevenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRevenueCreateManyInput = {
    id?: string
    year: number
    total: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRevenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRevenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueCreateInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Freelance: FreelanceCreateNestedOneWithoutFreelanceRevenueInput
  }

  export type FreelanceRevenueUncheckedCreateInput = {
    id?: string
    year: number
    total: number
    freelanceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceRevenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Freelance?: FreelanceUpdateOneRequiredWithoutFreelanceRevenueNestedInput
  }

  export type FreelanceRevenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    freelanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueCreateManyInput = {
    id?: string
    year: number
    total: number
    freelanceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceRevenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    freelanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateInput = {
    id?: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateManyInput = {
    id?: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    user: UserCreateNestedOneWithoutCompanyInput
    industriesRelated?: CompanyIndustryCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    user?: UserUpdateOneRequiredWithoutCompanyNestedInput
    industriesRelated?: CompanyIndustryUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
  }

  export type CompanyIndustryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutIndustriesRelatedInput
    industry: IndustryCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyIndustryUncheckedCreateInput = {
    companyId: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutIndustriesRelatedNestedInput
    industry?: IndustryUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyIndustryUncheckedUpdateInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyIndustryCreateManyInput = {
    companyId: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyIndustryUncheckedUpdateManyInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceCreateInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryCreateNestedManyWithoutFreelanceInput
    skills?: SkillCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueCreateNestedManyWithoutFreelanceInput
    user: UserCreateNestedOneWithoutFreelanceInput
    Portfolio?: PortfolioCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    industriesRelated?: FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput
    skills?: SkillUncheckedCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUpdateManyWithoutFreelanceNestedInput
    user?: UserUpdateOneRequiredWithoutFreelanceNestedInput
    Portfolio?: PortfolioUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    industriesRelated?: FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUncheckedUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceCreateManyInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type FreelanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FreelanceIndustryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    freelance: FreelanceCreateNestedOneWithoutIndustriesRelatedInput
    industry: IndustryCreateNestedOneWithoutFreelancersInput
  }

  export type FreelanceIndustryUncheckedCreateInput = {
    freelanceId: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelance?: FreelanceUpdateOneRequiredWithoutIndustriesRelatedNestedInput
    industry?: IndustryUpdateOneRequiredWithoutFreelancersNestedInput
  }

  export type FreelanceIndustryUncheckedUpdateInput = {
    freelanceId?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryCreateManyInput = {
    freelanceId: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryUncheckedUpdateManyInput = {
    freelanceId?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndustryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutTagInput
    PortfolioTag?: PortfolioTagCreateNestedManyWithoutTagInput
    UserTags?: UserTagsCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioTag?: PortfolioTagUncheckedCreateNestedManyWithoutTagInput
    UserTags?: UserTagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutTagNestedInput
    PortfolioTag?: PortfolioTagUpdateManyWithoutTagNestedInput
    UserTags?: UserTagsUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioTag?: PortfolioTagUncheckedUpdateManyWithoutTagNestedInput
    UserTags?: UserTagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LookingForCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutLookingForInput
    PortfolioLookingFor?: PortfolioLookingForCreateNestedManyWithoutLookingForInput
  }

  export type LookingForUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutLookingForInput
  }

  export type LookingForUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutLookingForNestedInput
    PortfolioLookingFor?: PortfolioLookingForUpdateManyWithoutLookingForNestedInput
  }

  export type LookingForUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutLookingForNestedInput
  }

  export type LookingForCreateManyInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LookingForUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LookingForUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutCategoryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutCategoryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type SourceCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSourceInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutSourceInput
  }

  export type SourceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutSourceInput
  }

  export type SourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSourceNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type SourceCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type SourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutChannelInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutChannelInput
    UserChannels?: UserChannelsCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutChannelInput
    UserChannels?: UserChannelsUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutChannelNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutChannelNestedInput
    UserChannels?: UserChannelsUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutChannelNestedInput
    UserChannels?: UserChannelsUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type SegmentCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSegmentInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutSegmentInput
  }

  export type SegmentUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSegmentNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type SegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type PortfolioCreateInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateManyInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutIndustryTagsInput
    tag: TagCreateNestedOneWithoutPortfolioTagInput
  }

  export type PortfolioTagUncheckedCreateInput = {
    portfolioId: string
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutIndustryTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPortfolioTagNestedInput
  }

  export type PortfolioTagUncheckedUpdateInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagCreateManyInput = {
    portfolioId: string
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagUncheckedUpdateManyInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutIndustryLookingForInput
    lookingFor: LookingForCreateNestedOneWithoutPortfolioLookingForInput
  }

  export type PortfolioLookingForUncheckedCreateInput = {
    portfolioId: string
    lookingForSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutIndustryLookingForNestedInput
    lookingFor?: LookingForUpdateOneRequiredWithoutPortfolioLookingForNestedInput
  }

  export type PortfolioLookingForUncheckedUpdateInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    lookingForSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForCreateManyInput = {
    portfolioId: string
    lookingForSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForUncheckedUpdateManyInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    lookingForSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutStandardsInput
    standards: StandardsCreateNestedOneWithoutPortfolioStandardsInput
  }

  export type PortfolioStandardsUncheckedCreateInput = {
    id?: string
    portfolioId: string
    standardsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutStandardsNestedInput
    standards?: StandardsUpdateOneRequiredWithoutPortfolioStandardsNestedInput
  }

  export type PortfolioStandardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    standardsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsCreateManyInput = {
    id?: string
    portfolioId: string
    standardsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    standardsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageCreateInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutImageInput
  }

  export type PortfolioImageUncheckedCreateInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutImageNestedInput
  }

  export type PortfolioImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageCreateManyInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutFavoriteInput
    user: UserCreateNestedOneWithoutFavoriteInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    portfolioId: string
    userId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutFavoriteNestedInput
    user?: UserUpdateOneRequiredWithoutFavoriteNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    portfolioId: string
    userId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardsCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutStandardsInput
    PortfolioStandards?: PortfolioStandardsCreateNestedManyWithoutStandardsInput
  }

  export type StandardsUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    industrySlug: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioStandards?: PortfolioStandardsUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutStandardsNestedInput
    PortfolioStandards?: PortfolioStandardsUpdateManyWithoutStandardsNestedInput
  }

  export type StandardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    industrySlug?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioStandards?: PortfolioStandardsUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardsCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    industrySlug: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    industrySlug?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSkillInput
    Freelance?: FreelanceCreateNestedOneWithoutSkillsInput
    UserSkills?: UserSkillsCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelanceId?: string | null
    UserSkills?: UserSkillsUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSkillNestedInput
    Freelance?: FreelanceUpdateOneWithoutSkillsNestedInput
    UserSkills?: UserSkillsUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSkills?: UserSkillsUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelanceId?: string | null
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: PortfolioCommentCreateNestedOneWithoutRepliesInput
    replies?: PortfolioCommentCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentUncheckedCreateInput = {
    id?: string
    content: string
    portfolioId: string
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: PortfolioCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: PortfolioCommentUpdateOneWithoutRepliesNestedInput
    replies?: PortfolioCommentUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: PortfolioCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentCreateManyInput = {
    id?: string
    content: string
    portfolioId: string
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableFilter<$PrismaModel> | $Enums.UserType | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserIndustryListRelationFilter = {
    every?: UserIndustryWhereInput
    some?: UserIndustryWhereInput
    none?: UserIndustryWhereInput
  }

  export type UserTagsListRelationFilter = {
    every?: UserTagsWhereInput
    some?: UserTagsWhereInput
    none?: UserTagsWhereInput
  }

  export type UserChannelsListRelationFilter = {
    every?: UserChannelsWhereInput
    some?: UserChannelsWhereInput
    none?: UserChannelsWhereInput
  }

  export type UserSkillsListRelationFilter = {
    every?: UserSkillsWhereInput
    some?: UserSkillsWhereInput
    none?: UserSkillsWhereInput
  }

  export type FreelanceNullableScalarRelationFilter = {
    is?: FreelanceWhereInput | null
    isNot?: FreelanceWhereInput | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type PortfolioCommentListRelationFilter = {
    every?: PortfolioCommentWhereInput
    some?: PortfolioCommentWhereInput
    none?: PortfolioCommentWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserIndustryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserChannelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSkillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullnameTh?: SortOrder
    fullnameEn?: SortOrder
    about?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    image?: SortOrder
    industries?: SortOrder
    tags?: SortOrder
    channels?: SortOrder
    specialists?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullnameTh?: SortOrder
    fullnameEn?: SortOrder
    about?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    image?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullnameTh?: SortOrder
    fullnameEn?: SortOrder
    about?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    image?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type UserTagsUserIdTagSlugCompoundUniqueInput = {
    userId: string
    tagSlug: string
  }

  export type UserTagsCountOrderByAggregateInput = {
    userId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagsMaxOrderByAggregateInput = {
    userId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagsMinOrderByAggregateInput = {
    userId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelScalarRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type UserChannelsUserIdChannelSlugCompoundUniqueInput = {
    userId: string
    channelSlug: string
  }

  export type UserChannelsCountOrderByAggregateInput = {
    userId?: SortOrder
    channelSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserChannelsMaxOrderByAggregateInput = {
    userId?: SortOrder
    channelSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserChannelsMinOrderByAggregateInput = {
    userId?: SortOrder
    channelSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type UserSkillsUserIdSkillSlugCompoundUniqueInput = {
    userId: string
    skillSlug: string
  }

  export type UserSkillsCountOrderByAggregateInput = {
    userId?: SortOrder
    skillSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSkillsMaxOrderByAggregateInput = {
    userId?: SortOrder
    skillSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSkillsMinOrderByAggregateInput = {
    userId?: SortOrder
    skillSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryScalarRelationFilter = {
    is?: IndustryWhereInput
    isNot?: IndustryWhereInput
  }

  export type UserIndustryUserIdIndustryIdCompoundUniqueInput = {
    userId: string
    industryId: string
  }

  export type UserIndustryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    industryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIndustryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    industryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIndustryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    industryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    issuedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    issuedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    issuedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyRevenueCompanyIdYearCompoundUniqueInput = {
    companyId: string
    year: number
  }

  export type CompanyRevenueCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyRevenueAvgOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type CompanyRevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyRevenueMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyRevenueSumOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FreelanceScalarRelationFilter = {
    is?: FreelanceWhereInput
    isNot?: FreelanceWhereInput
  }

  export type FreelanceRevenueFreelanceIdYearCompoundUniqueInput = {
    freelanceId: string
    year: number
  }

  export type FreelanceRevenueCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    freelanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceRevenueAvgOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type FreelanceRevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    freelanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceRevenueMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    total?: SortOrder
    freelanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceRevenueSumOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SourceScalarRelationFilter = {
    is?: SourceWhereInput
    isNot?: SourceWhereInput
  }

  export type SegmentScalarRelationFilter = {
    is?: SegmentWhereInput
    isNot?: SegmentWhereInput
  }

  export type RevenueStreamCompanyIdYearIndustryTypeSlugCategorySlugSourceSlugChannelSlugSegmentSlugCompoundUniqueInput = {
    companyId: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
  }

  export type RevenueStreamCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    industryTypeSlug?: SortOrder
    categorySlug?: SortOrder
    sourceSlug?: SortOrder
    channelSlug?: SortOrder
    segmentSlug?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueStreamAvgOrderByAggregateInput = {
    year?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrder
  }

  export type RevenueStreamMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    industryTypeSlug?: SortOrder
    categorySlug?: SortOrder
    sourceSlug?: SortOrder
    channelSlug?: SortOrder
    segmentSlug?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueStreamMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    industryTypeSlug?: SortOrder
    categorySlug?: SortOrder
    sourceSlug?: SortOrder
    channelSlug?: SortOrder
    segmentSlug?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueStreamSumOrderByAggregateInput = {
    year?: SortOrder
    percent?: SortOrder
    ctrPercent?: SortOrder
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CompanyIndustryListRelationFilter = {
    every?: CompanyIndustryWhereInput
    some?: CompanyIndustryWhereInput
    none?: CompanyIndustryWhereInput
  }

  export type CompanyRevenueListRelationFilter = {
    every?: CompanyRevenueWhereInput
    some?: CompanyRevenueWhereInput
    none?: CompanyRevenueWhereInput
  }

  export type RevenueStreamListRelationFilter = {
    every?: RevenueStreamWhereInput
    some?: RevenueStreamWhereInput
    none?: RevenueStreamWhereInput
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type CompanyIndustryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyRevenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevenueStreamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    juristicId?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    registerdCapital?: SortOrder
    employeeCount?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industries?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    registerdCapital?: SortOrder
    employeeCount?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    juristicId?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    registerdCapital?: SortOrder
    employeeCount?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    juristicId?: SortOrder
    nameTh?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    registerdCapital?: SortOrder
    employeeCount?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    registerdCapital?: SortOrder
    employeeCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CompanyIndustryCompanyIdIndustrySlugCompoundUniqueInput = {
    companyId: string
    industrySlug: string
  }

  export type CompanyIndustryCountOrderByAggregateInput = {
    companyId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyIndustryMaxOrderByAggregateInput = {
    companyId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyIndustryMinOrderByAggregateInput = {
    companyId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceIndustryListRelationFilter = {
    every?: FreelanceIndustryWhereInput
    some?: FreelanceIndustryWhereInput
    none?: FreelanceIndustryWhereInput
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type FreelanceRevenueListRelationFilter = {
    every?: FreelanceRevenueWhereInput
    some?: FreelanceRevenueWhereInput
    none?: FreelanceRevenueWhereInput
  }

  export type FreelanceIndustryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelanceRevenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelanceCountOrderByAggregateInput = {
    id?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    firstNameEn?: SortOrder
    lastNameEn?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    juristicId?: SortOrder
    industryTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type FreelanceMaxOrderByAggregateInput = {
    id?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    firstNameEn?: SortOrder
    lastNameEn?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    juristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type FreelanceMinOrderByAggregateInput = {
    id?: SortOrder
    firstNameTh?: SortOrder
    lastNameTh?: SortOrder
    firstNameEn?: SortOrder
    lastNameEn?: SortOrder
    image?: SortOrder
    cover_image?: SortOrder
    address?: SortOrder
    subDistrict?: SortOrder
    district?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    juristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type FreelanceIndustryFreelanceIdIndustrySlugCompoundUniqueInput = {
    freelanceId: string
    industrySlug: string
  }

  export type FreelanceIndustryCountOrderByAggregateInput = {
    freelanceId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceIndustryMaxOrderByAggregateInput = {
    freelanceId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceIndustryMinOrderByAggregateInput = {
    freelanceId?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceListRelationFilter = {
    every?: SourceWhereInput
    some?: SourceWhereInput
    none?: SourceWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type SegmentListRelationFilter = {
    every?: SegmentWhereInput
    some?: SegmentWhereInput
    none?: SegmentWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type StandardsListRelationFilter = {
    every?: StandardsWhereInput
    some?: StandardsWhereInput
    none?: StandardsWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type LookingForListRelationFilter = {
    every?: LookingForWhereInput
    some?: LookingForWhereInput
    none?: LookingForWhereInput
  }

  export type SourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LookingForOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndustryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioTagListRelationFilter = {
    every?: PortfolioTagWhereInput
    some?: PortfolioTagWhereInput
    none?: PortfolioTagWhereInput
  }

  export type PortfolioTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioLookingForListRelationFilter = {
    every?: PortfolioLookingForWhereInput
    some?: PortfolioLookingForWhereInput
    none?: PortfolioLookingForWhereInput
  }

  export type PortfolioLookingForOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LookingForCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LookingForMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LookingForMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySlugIndustrySlugCompoundUniqueInput = {
    slug: string
    industrySlug: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SourceSlugIndustrySlugCompoundUniqueInput = {
    slug: string
    industrySlug: string
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type ChannelSlugIndustrySlugCompoundUniqueInput = {
    slug: string
    industrySlug: string
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SegmentSlugIndustrySlugCompoundUniqueInput = {
    slug: string
    industrySlug: string
  }

  export type SegmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type SegmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    industrySlug?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type PortfolioImageListRelationFilter = {
    every?: PortfolioImageWhereInput
    some?: PortfolioImageWhereInput
    none?: PortfolioImageWhereInput
  }

  export type PortfolioStandardsListRelationFilter = {
    every?: PortfolioStandardsWhereInput
    some?: PortfolioStandardsWhereInput
    none?: PortfolioStandardsWhereInput
  }

  export type PortfolioImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioStandardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    title_en?: SortOrder
    description?: SortOrder
    description_en?: SortOrder
    cover_image?: SortOrder
    link?: SortOrder
    industryTypeSlug?: SortOrder
    tags?: SortOrder
    looking_for?: SortOrder
    freelanceId?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    title_en?: SortOrder
    description?: SortOrder
    description_en?: SortOrder
    cover_image?: SortOrder
    link?: SortOrder
    industryTypeSlug?: SortOrder
    freelanceId?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    title_en?: SortOrder
    description?: SortOrder
    description_en?: SortOrder
    cover_image?: SortOrder
    link?: SortOrder
    industryTypeSlug?: SortOrder
    freelanceId?: SortOrder
    companyId?: SortOrder
    companyJuristicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PortfolioScalarRelationFilter = {
    is?: PortfolioWhereInput
    isNot?: PortfolioWhereInput
  }

  export type PortfolioTagPortfolioIdTagSlugCompoundUniqueInput = {
    portfolioId: string
    tagSlug: string
  }

  export type PortfolioTagCountOrderByAggregateInput = {
    portfolioId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioTagMaxOrderByAggregateInput = {
    portfolioId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioTagMinOrderByAggregateInput = {
    portfolioId?: SortOrder
    tagSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LookingForScalarRelationFilter = {
    is?: LookingForWhereInput
    isNot?: LookingForWhereInput
  }

  export type PortfolioLookingForPortfolioIdLookingForSlugCompoundUniqueInput = {
    portfolioId: string
    lookingForSlug: string
  }

  export type PortfolioLookingForCountOrderByAggregateInput = {
    portfolioId?: SortOrder
    lookingForSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioLookingForMaxOrderByAggregateInput = {
    portfolioId?: SortOrder
    lookingForSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioLookingForMinOrderByAggregateInput = {
    portfolioId?: SortOrder
    lookingForSlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardsScalarRelationFilter = {
    is?: StandardsWhereInput
    isNot?: StandardsWhereInput
  }

  export type PortfolioStandardsPortfolioIdStandardsIdCompoundUniqueInput = {
    portfolioId: string
    standardsId: string
  }

  export type PortfolioStandardsCountOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    standardsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioStandardsMaxOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    standardsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioStandardsMinOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    standardsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPortfolioImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PortfolioImageType | EnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPortfolioImageTypeFilter<$PrismaModel> | $Enums.PortfolioImageType
  }

  export type PortfolioImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    type?: SortOrder
    portfolioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    type?: SortOrder
    portfolioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    type?: SortOrder
    portfolioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPortfolioImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortfolioImageType | EnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPortfolioImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PortfolioImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortfolioImageTypeFilter<$PrismaModel>
    _max?: NestedEnumPortfolioImageTypeFilter<$PrismaModel>
  }

  export type EnumFavoriteActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FavoriteAction | EnumFavoriteActionFieldRefInput<$PrismaModel>
    in?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFavoriteActionFilter<$PrismaModel> | $Enums.FavoriteAction
  }

  export type FavoriteUserIdPortfolioIdCompoundUniqueInput = {
    userId: string
    portfolioId: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFavoriteActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FavoriteAction | EnumFavoriteActionFieldRefInput<$PrismaModel>
    in?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFavoriteActionWithAggregatesFilter<$PrismaModel> | $Enums.FavoriteAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFavoriteActionFilter<$PrismaModel>
    _max?: NestedEnumFavoriteActionFilter<$PrismaModel>
  }

  export type EnumStandardsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardsType | EnumStandardsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardsTypeFilter<$PrismaModel> | $Enums.StandardsType
  }

  export type StandardsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    industrySlug?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    industrySlug?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    industrySlug?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStandardsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardsType | EnumStandardsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardsTypeWithAggregatesFilter<$PrismaModel> | $Enums.StandardsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardsTypeFilter<$PrismaModel>
    _max?: NestedEnumStandardsTypeFilter<$PrismaModel>
  }

  export type SkillSlugIndustrySlugCompoundUniqueInput = {
    slug: string
    industrySlug: string
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    group?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelanceId?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    group?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelanceId?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    group?: SortOrder
    industrySlug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelanceId?: SortOrder
  }

  export type PortfolioCommentNullableScalarRelationFilter = {
    is?: PortfolioCommentWhereInput | null
    isNot?: PortfolioCommentWhereInput | null
  }

  export type PortfolioCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    portfolioId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateindustriesInput = {
    set: string[]
  }

  export type UserCreatetagsInput = {
    set: InputJsonValue[]
  }

  export type UserCreatechannelsInput = {
    set: InputJsonValue[]
  }

  export type UserCreatespecialistsInput = {
    set: InputJsonValue[]
  }

  export type UserIndustryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput> | UserIndustryCreateWithoutUserInput[] | UserIndustryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutUserInput | UserIndustryCreateOrConnectWithoutUserInput[]
    createMany?: UserIndustryCreateManyUserInputEnvelope
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
  }

  export type UserTagsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type UserChannelsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput> | UserChannelsCreateWithoutUserInput[] | UserChannelsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutUserInput | UserChannelsCreateOrConnectWithoutUserInput[]
    createMany?: UserChannelsCreateManyUserInputEnvelope
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
  }

  export type UserSkillsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput> | UserSkillsCreateWithoutUserInput[] | UserSkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUserInput | UserSkillsCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillsCreateManyUserInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type FreelanceCreateNestedOneWithoutUserInput = {
    create?: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutUserInput
    connect?: FreelanceWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    connect?: CompanyWhereUniqueInput
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PortfolioCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput> | PortfolioCommentCreateWithoutUserInput[] | PortfolioCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutUserInput | PortfolioCommentCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioCommentCreateManyUserInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserIndustryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput> | UserIndustryCreateWithoutUserInput[] | UserIndustryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutUserInput | UserIndustryCreateOrConnectWithoutUserInput[]
    createMany?: UserIndustryCreateManyUserInputEnvelope
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
  }

  export type UserTagsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type UserChannelsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput> | UserChannelsCreateWithoutUserInput[] | UserChannelsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutUserInput | UserChannelsCreateOrConnectWithoutUserInput[]
    createMany?: UserChannelsCreateManyUserInputEnvelope
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
  }

  export type UserSkillsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput> | UserSkillsCreateWithoutUserInput[] | UserSkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUserInput | UserSkillsCreateOrConnectWithoutUserInput[]
    createMany?: UserSkillsCreateManyUserInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type FreelanceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutUserInput
    connect?: FreelanceWhereUniqueInput
  }

  export type CompanyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    connect?: CompanyWhereUniqueInput
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PortfolioCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput> | PortfolioCommentCreateWithoutUserInput[] | PortfolioCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutUserInput | PortfolioCommentCreateOrConnectWithoutUserInput[]
    createMany?: PortfolioCommentCreateManyUserInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateindustriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatetagsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type UserUpdatechannelsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type UserUpdatespecialistsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableEnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserIndustryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput> | UserIndustryCreateWithoutUserInput[] | UserIndustryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutUserInput | UserIndustryCreateOrConnectWithoutUserInput[]
    upsert?: UserIndustryUpsertWithWhereUniqueWithoutUserInput | UserIndustryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserIndustryCreateManyUserInputEnvelope
    set?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    disconnect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    delete?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    update?: UserIndustryUpdateWithWhereUniqueWithoutUserInput | UserIndustryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserIndustryUpdateManyWithWhereWithoutUserInput | UserIndustryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
  }

  export type UserTagsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type UserChannelsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput> | UserChannelsCreateWithoutUserInput[] | UserChannelsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutUserInput | UserChannelsCreateOrConnectWithoutUserInput[]
    upsert?: UserChannelsUpsertWithWhereUniqueWithoutUserInput | UserChannelsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChannelsCreateManyUserInputEnvelope
    set?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    disconnect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    delete?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    update?: UserChannelsUpdateWithWhereUniqueWithoutUserInput | UserChannelsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChannelsUpdateManyWithWhereWithoutUserInput | UserChannelsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
  }

  export type UserSkillsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput> | UserSkillsCreateWithoutUserInput[] | UserSkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUserInput | UserSkillsCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutUserInput | UserSkillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillsCreateManyUserInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutUserInput | UserSkillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutUserInput | UserSkillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type FreelanceUpdateOneWithoutUserNestedInput = {
    create?: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutUserInput
    upsert?: FreelanceUpsertWithoutUserInput
    disconnect?: FreelanceWhereInput | boolean
    delete?: FreelanceWhereInput | boolean
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutUserInput, FreelanceUpdateWithoutUserInput>, FreelanceUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUpdateOneWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    upsert?: CompanyUpsertWithoutUserInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserInput, CompanyUpdateWithoutUserInput>, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PortfolioCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput> | PortfolioCommentCreateWithoutUserInput[] | PortfolioCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutUserInput | PortfolioCommentCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutUserInput | PortfolioCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioCommentCreateManyUserInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutUserInput | PortfolioCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutUserInput | PortfolioCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserIndustryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput> | UserIndustryCreateWithoutUserInput[] | UserIndustryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutUserInput | UserIndustryCreateOrConnectWithoutUserInput[]
    upsert?: UserIndustryUpsertWithWhereUniqueWithoutUserInput | UserIndustryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserIndustryCreateManyUserInputEnvelope
    set?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    disconnect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    delete?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    update?: UserIndustryUpdateWithWhereUniqueWithoutUserInput | UserIndustryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserIndustryUpdateManyWithWhereWithoutUserInput | UserIndustryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
  }

  export type UserTagsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type UserChannelsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput> | UserChannelsCreateWithoutUserInput[] | UserChannelsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutUserInput | UserChannelsCreateOrConnectWithoutUserInput[]
    upsert?: UserChannelsUpsertWithWhereUniqueWithoutUserInput | UserChannelsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChannelsCreateManyUserInputEnvelope
    set?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    disconnect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    delete?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    update?: UserChannelsUpdateWithWhereUniqueWithoutUserInput | UserChannelsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChannelsUpdateManyWithWhereWithoutUserInput | UserChannelsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
  }

  export type UserSkillsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput> | UserSkillsCreateWithoutUserInput[] | UserSkillsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutUserInput | UserSkillsCreateOrConnectWithoutUserInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutUserInput | UserSkillsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSkillsCreateManyUserInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutUserInput | UserSkillsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutUserInput | UserSkillsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type FreelanceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutUserInput
    upsert?: FreelanceUpsertWithoutUserInput
    disconnect?: FreelanceWhereInput | boolean
    delete?: FreelanceWhereInput | boolean
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutUserInput, FreelanceUpdateWithoutUserInput>, FreelanceUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    upsert?: CompanyUpsertWithoutUserInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserInput, CompanyUpdateWithoutUserInput>, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput> | PortfolioCommentCreateWithoutUserInput[] | PortfolioCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutUserInput | PortfolioCommentCreateOrConnectWithoutUserInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutUserInput | PortfolioCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PortfolioCommentCreateManyUserInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutUserInput | PortfolioCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutUserInput | PortfolioCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIndustryTagsInput = {
    create?: XOR<UserCreateWithoutIndustryTagsInput, UserUncheckedCreateWithoutIndustryTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustryTagsInput
    connect?: UserWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutUserTagsInput = {
    create?: XOR<TagCreateWithoutUserTagsInput, TagUncheckedCreateWithoutUserTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutUserTagsInput
    connect?: TagWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIndustryTagsNestedInput = {
    create?: XOR<UserCreateWithoutIndustryTagsInput, UserUncheckedCreateWithoutIndustryTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustryTagsInput
    upsert?: UserUpsertWithoutIndustryTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndustryTagsInput, UserUpdateWithoutIndustryTagsInput>, UserUncheckedUpdateWithoutIndustryTagsInput>
  }

  export type TagUpdateOneRequiredWithoutUserTagsNestedInput = {
    create?: XOR<TagCreateWithoutUserTagsInput, TagUncheckedCreateWithoutUserTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutUserTagsInput
    upsert?: TagUpsertWithoutUserTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutUserTagsInput, TagUpdateWithoutUserTagsInput>, TagUncheckedUpdateWithoutUserTagsInput>
  }

  export type UserCreateNestedOneWithoutIndustryChannelsInput = {
    create?: XOR<UserCreateWithoutIndustryChannelsInput, UserUncheckedCreateWithoutIndustryChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustryChannelsInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutUserChannelsInput = {
    create?: XOR<ChannelCreateWithoutUserChannelsInput, ChannelUncheckedCreateWithoutUserChannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUserChannelsInput
    connect?: ChannelWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIndustryChannelsNestedInput = {
    create?: XOR<UserCreateWithoutIndustryChannelsInput, UserUncheckedCreateWithoutIndustryChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustryChannelsInput
    upsert?: UserUpsertWithoutIndustryChannelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndustryChannelsInput, UserUpdateWithoutIndustryChannelsInput>, UserUncheckedUpdateWithoutIndustryChannelsInput>
  }

  export type ChannelUpdateOneRequiredWithoutUserChannelsNestedInput = {
    create?: XOR<ChannelCreateWithoutUserChannelsInput, ChannelUncheckedCreateWithoutUserChannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutUserChannelsInput
    upsert?: ChannelUpsertWithoutUserChannelsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutUserChannelsInput, ChannelUpdateWithoutUserChannelsInput>, ChannelUncheckedUpdateWithoutUserChannelsInput>
  }

  export type UserCreateNestedOneWithoutIndustrySkillsInput = {
    create?: XOR<UserCreateWithoutIndustrySkillsInput, UserUncheckedCreateWithoutIndustrySkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustrySkillsInput
    connect?: UserWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutUserSkillsInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIndustrySkillsNestedInput = {
    create?: XOR<UserCreateWithoutIndustrySkillsInput, UserUncheckedCreateWithoutIndustrySkillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustrySkillsInput
    upsert?: UserUpsertWithoutIndustrySkillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndustrySkillsInput, UserUpdateWithoutIndustrySkillsInput>, UserUncheckedUpdateWithoutIndustrySkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutUserSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutUserSkillsInput
    upsert?: SkillUpsertWithoutUserSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutUserSkillsInput, SkillUpdateWithoutUserSkillsInput>, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type UserCreateNestedOneWithoutIndustriesRelatedInput = {
    create?: XOR<UserCreateWithoutIndustriesRelatedInput, UserUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustriesRelatedInput
    connect?: UserWhereUniqueInput
  }

  export type IndustryCreateNestedOneWithoutUsersInput = {
    create?: XOR<IndustryCreateWithoutUsersInput, IndustryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutUsersInput
    connect?: IndustryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIndustriesRelatedNestedInput = {
    create?: XOR<UserCreateWithoutIndustriesRelatedInput, UserUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndustriesRelatedInput
    upsert?: UserUpsertWithoutIndustriesRelatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndustriesRelatedInput, UserUpdateWithoutIndustriesRelatedInput>, UserUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type IndustryUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<IndustryCreateWithoutUsersInput, IndustryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutUsersInput
    upsert?: IndustryUpsertWithoutUsersInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutUsersInput, IndustryUpdateWithoutUsersInput>, IndustryUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type CompanyCreateNestedOneWithoutCompanyRevenueInput = {
    create?: XOR<CompanyCreateWithoutCompanyRevenueInput, CompanyUncheckedCreateWithoutCompanyRevenueInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyRevenueInput
    connect?: CompanyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutCompanyRevenueNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyRevenueInput, CompanyUncheckedCreateWithoutCompanyRevenueInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyRevenueInput
    upsert?: CompanyUpsertWithoutCompanyRevenueInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyRevenueInput, CompanyUpdateWithoutCompanyRevenueInput>, CompanyUncheckedUpdateWithoutCompanyRevenueInput>
  }

  export type FreelanceCreateNestedOneWithoutFreelanceRevenueInput = {
    create?: XOR<FreelanceCreateWithoutFreelanceRevenueInput, FreelanceUncheckedCreateWithoutFreelanceRevenueInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutFreelanceRevenueInput
    connect?: FreelanceWhereUniqueInput
  }

  export type FreelanceUpdateOneRequiredWithoutFreelanceRevenueNestedInput = {
    create?: XOR<FreelanceCreateWithoutFreelanceRevenueInput, FreelanceUncheckedCreateWithoutFreelanceRevenueInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutFreelanceRevenueInput
    upsert?: FreelanceUpsertWithoutFreelanceRevenueInput
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutFreelanceRevenueInput, FreelanceUpdateWithoutFreelanceRevenueInput>, FreelanceUncheckedUpdateWithoutFreelanceRevenueInput>
  }

  export type IndustryCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<IndustryCreateWithoutRevenueStreamInput, IndustryUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutRevenueStreamInput
    connect?: IndustryWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<CategoryCreateWithoutRevenueStreamInput, CategoryUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRevenueStreamInput
    connect?: CategoryWhereUniqueInput
  }

  export type SourceCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<SourceCreateWithoutRevenueStreamInput, SourceUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: SourceCreateOrConnectWithoutRevenueStreamInput
    connect?: SourceWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<ChannelCreateWithoutRevenueStreamInput, ChannelUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutRevenueStreamInput
    connect?: ChannelWhereUniqueInput
  }

  export type SegmentCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<SegmentCreateWithoutRevenueStreamInput, SegmentUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: SegmentCreateOrConnectWithoutRevenueStreamInput
    connect?: SegmentWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutRevenueStreamInput = {
    create?: XOR<CompanyCreateWithoutRevenueStreamInput, CompanyUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRevenueStreamInput
    connect?: CompanyWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<IndustryCreateWithoutRevenueStreamInput, IndustryUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutRevenueStreamInput
    upsert?: IndustryUpsertWithoutRevenueStreamInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutRevenueStreamInput, IndustryUpdateWithoutRevenueStreamInput>, IndustryUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<CategoryCreateWithoutRevenueStreamInput, CategoryUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutRevenueStreamInput
    upsert?: CategoryUpsertWithoutRevenueStreamInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutRevenueStreamInput, CategoryUpdateWithoutRevenueStreamInput>, CategoryUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type SourceUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<SourceCreateWithoutRevenueStreamInput, SourceUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: SourceCreateOrConnectWithoutRevenueStreamInput
    upsert?: SourceUpsertWithoutRevenueStreamInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutRevenueStreamInput, SourceUpdateWithoutRevenueStreamInput>, SourceUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<ChannelCreateWithoutRevenueStreamInput, ChannelUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutRevenueStreamInput
    upsert?: ChannelUpsertWithoutRevenueStreamInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutRevenueStreamInput, ChannelUpdateWithoutRevenueStreamInput>, ChannelUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<SegmentCreateWithoutRevenueStreamInput, SegmentUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: SegmentCreateOrConnectWithoutRevenueStreamInput
    upsert?: SegmentUpsertWithoutRevenueStreamInput
    connect?: SegmentWhereUniqueInput
    update?: XOR<XOR<SegmentUpdateToOneWithWhereWithoutRevenueStreamInput, SegmentUpdateWithoutRevenueStreamInput>, SegmentUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput = {
    create?: XOR<CompanyCreateWithoutRevenueStreamInput, CompanyUncheckedCreateWithoutRevenueStreamInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRevenueStreamInput
    upsert?: CompanyUpsertWithoutRevenueStreamInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRevenueStreamInput, CompanyUpdateWithoutRevenueStreamInput>, CompanyUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type CompanyCreateindustriesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyIndustryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput> | CompanyIndustryCreateWithoutCompanyInput[] | CompanyIndustryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutCompanyInput | CompanyIndustryCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyIndustryCreateManyCompanyInputEnvelope
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
  }

  export type CompanyRevenueCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput> | CompanyRevenueCreateWithoutCompanyInput[] | CompanyRevenueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRevenueCreateOrConnectWithoutCompanyInput | CompanyRevenueCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyRevenueCreateManyCompanyInputEnvelope
    connect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
  }

  export type RevenueStreamCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput> | RevenueStreamCreateWithoutCompanyInput[] | RevenueStreamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCompanyInput | RevenueStreamCreateOrConnectWithoutCompanyInput[]
    createMany?: RevenueStreamCreateManyCompanyInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type PortfolioCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput> | PortfolioCreateWithoutCompanyInput[] | PortfolioUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutCompanyInput | PortfolioCreateOrConnectWithoutCompanyInput[]
    createMany?: PortfolioCreateManyCompanyInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput> | CompanyIndustryCreateWithoutCompanyInput[] | CompanyIndustryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutCompanyInput | CompanyIndustryCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyIndustryCreateManyCompanyInputEnvelope
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
  }

  export type CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput> | CompanyRevenueCreateWithoutCompanyInput[] | CompanyRevenueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRevenueCreateOrConnectWithoutCompanyInput | CompanyRevenueCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyRevenueCreateManyCompanyInputEnvelope
    connect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput> | RevenueStreamCreateWithoutCompanyInput[] | RevenueStreamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCompanyInput | RevenueStreamCreateOrConnectWithoutCompanyInput[]
    createMany?: RevenueStreamCreateManyCompanyInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput> | PortfolioCreateWithoutCompanyInput[] | PortfolioUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutCompanyInput | PortfolioCreateOrConnectWithoutCompanyInput[]
    createMany?: PortfolioCreateManyCompanyInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateindustriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput
    upsert?: UserUpsertWithoutCompanyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompanyInput, UserUpdateWithoutCompanyInput>, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyIndustryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput> | CompanyIndustryCreateWithoutCompanyInput[] | CompanyIndustryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutCompanyInput | CompanyIndustryCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyIndustryUpsertWithWhereUniqueWithoutCompanyInput | CompanyIndustryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyIndustryCreateManyCompanyInputEnvelope
    set?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    disconnect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    delete?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    update?: CompanyIndustryUpdateWithWhereUniqueWithoutCompanyInput | CompanyIndustryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyIndustryUpdateManyWithWhereWithoutCompanyInput | CompanyIndustryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
  }

  export type CompanyRevenueUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput> | CompanyRevenueCreateWithoutCompanyInput[] | CompanyRevenueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRevenueCreateOrConnectWithoutCompanyInput | CompanyRevenueCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyRevenueUpsertWithWhereUniqueWithoutCompanyInput | CompanyRevenueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyRevenueCreateManyCompanyInputEnvelope
    set?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    disconnect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    delete?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    connect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    update?: CompanyRevenueUpdateWithWhereUniqueWithoutCompanyInput | CompanyRevenueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyRevenueUpdateManyWithWhereWithoutCompanyInput | CompanyRevenueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyRevenueScalarWhereInput | CompanyRevenueScalarWhereInput[]
  }

  export type RevenueStreamUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput> | RevenueStreamCreateWithoutCompanyInput[] | RevenueStreamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCompanyInput | RevenueStreamCreateOrConnectWithoutCompanyInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutCompanyInput | RevenueStreamUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RevenueStreamCreateManyCompanyInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutCompanyInput | RevenueStreamUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutCompanyInput | RevenueStreamUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type PortfolioUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput> | PortfolioCreateWithoutCompanyInput[] | PortfolioUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutCompanyInput | PortfolioCreateOrConnectWithoutCompanyInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutCompanyInput | PortfolioUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PortfolioCreateManyCompanyInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutCompanyInput | PortfolioUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutCompanyInput | PortfolioUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput> | CompanyIndustryCreateWithoutCompanyInput[] | CompanyIndustryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutCompanyInput | CompanyIndustryCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyIndustryUpsertWithWhereUniqueWithoutCompanyInput | CompanyIndustryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyIndustryCreateManyCompanyInputEnvelope
    set?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    disconnect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    delete?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    update?: CompanyIndustryUpdateWithWhereUniqueWithoutCompanyInput | CompanyIndustryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyIndustryUpdateManyWithWhereWithoutCompanyInput | CompanyIndustryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
  }

  export type CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput> | CompanyRevenueCreateWithoutCompanyInput[] | CompanyRevenueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyRevenueCreateOrConnectWithoutCompanyInput | CompanyRevenueCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyRevenueUpsertWithWhereUniqueWithoutCompanyInput | CompanyRevenueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyRevenueCreateManyCompanyInputEnvelope
    set?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    disconnect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    delete?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    connect?: CompanyRevenueWhereUniqueInput | CompanyRevenueWhereUniqueInput[]
    update?: CompanyRevenueUpdateWithWhereUniqueWithoutCompanyInput | CompanyRevenueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyRevenueUpdateManyWithWhereWithoutCompanyInput | CompanyRevenueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyRevenueScalarWhereInput | CompanyRevenueScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput> | RevenueStreamCreateWithoutCompanyInput[] | RevenueStreamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCompanyInput | RevenueStreamCreateOrConnectWithoutCompanyInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutCompanyInput | RevenueStreamUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RevenueStreamCreateManyCompanyInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutCompanyInput | RevenueStreamUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutCompanyInput | RevenueStreamUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput> | PortfolioCreateWithoutCompanyInput[] | PortfolioUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutCompanyInput | PortfolioCreateOrConnectWithoutCompanyInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutCompanyInput | PortfolioUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PortfolioCreateManyCompanyInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutCompanyInput | PortfolioUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutCompanyInput | PortfolioUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutIndustriesRelatedInput = {
    create?: XOR<CompanyCreateWithoutIndustriesRelatedInput, CompanyUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutIndustriesRelatedInput
    connect?: CompanyWhereUniqueInput
  }

  export type IndustryCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<IndustryCreateWithoutCompaniesInput, IndustryUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutCompaniesInput
    connect?: IndustryWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutIndustriesRelatedNestedInput = {
    create?: XOR<CompanyCreateWithoutIndustriesRelatedInput, CompanyUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutIndustriesRelatedInput
    upsert?: CompanyUpsertWithoutIndustriesRelatedInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutIndustriesRelatedInput, CompanyUpdateWithoutIndustriesRelatedInput>, CompanyUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type IndustryUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<IndustryCreateWithoutCompaniesInput, IndustryUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutCompaniesInput
    upsert?: IndustryUpsertWithoutCompaniesInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutCompaniesInput, IndustryUpdateWithoutCompaniesInput>, IndustryUncheckedUpdateWithoutCompaniesInput>
  }

  export type FreelanceCreateindustryTypesInput = {
    set: string[]
  }

  export type FreelanceIndustryCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput> | FreelanceIndustryCreateWithoutFreelanceInput[] | FreelanceIndustryUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutFreelanceInput | FreelanceIndustryCreateOrConnectWithoutFreelanceInput[]
    createMany?: FreelanceIndustryCreateManyFreelanceInputEnvelope
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput> | SkillCreateWithoutFreelanceInput[] | SkillUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutFreelanceInput | SkillCreateOrConnectWithoutFreelanceInput[]
    createMany?: SkillCreateManyFreelanceInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type FreelanceRevenueCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput> | FreelanceRevenueCreateWithoutFreelanceInput[] | FreelanceRevenueUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceRevenueCreateOrConnectWithoutFreelanceInput | FreelanceRevenueCreateOrConnectWithoutFreelanceInput[]
    createMany?: FreelanceRevenueCreateManyFreelanceInputEnvelope
    connect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutFreelanceInput = {
    create?: XOR<UserCreateWithoutFreelanceInput, UserUncheckedCreateWithoutFreelanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelanceInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput> | PortfolioCreateWithoutFreelanceInput[] | PortfolioUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutFreelanceInput | PortfolioCreateOrConnectWithoutFreelanceInput[]
    createMany?: PortfolioCreateManyFreelanceInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput> | FreelanceIndustryCreateWithoutFreelanceInput[] | FreelanceIndustryUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutFreelanceInput | FreelanceIndustryCreateOrConnectWithoutFreelanceInput[]
    createMany?: FreelanceIndustryCreateManyFreelanceInputEnvelope
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput> | SkillCreateWithoutFreelanceInput[] | SkillUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutFreelanceInput | SkillCreateOrConnectWithoutFreelanceInput[]
    createMany?: SkillCreateManyFreelanceInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput> | FreelanceRevenueCreateWithoutFreelanceInput[] | FreelanceRevenueUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceRevenueCreateOrConnectWithoutFreelanceInput | FreelanceRevenueCreateOrConnectWithoutFreelanceInput[]
    createMany?: FreelanceRevenueCreateManyFreelanceInputEnvelope
    connect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutFreelanceInput = {
    create?: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput> | PortfolioCreateWithoutFreelanceInput[] | PortfolioUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutFreelanceInput | PortfolioCreateOrConnectWithoutFreelanceInput[]
    createMany?: PortfolioCreateManyFreelanceInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type FreelanceUpdateindustryTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FreelanceIndustryUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput> | FreelanceIndustryCreateWithoutFreelanceInput[] | FreelanceIndustryUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutFreelanceInput | FreelanceIndustryCreateOrConnectWithoutFreelanceInput[]
    upsert?: FreelanceIndustryUpsertWithWhereUniqueWithoutFreelanceInput | FreelanceIndustryUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: FreelanceIndustryCreateManyFreelanceInputEnvelope
    set?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    disconnect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    delete?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    update?: FreelanceIndustryUpdateWithWhereUniqueWithoutFreelanceInput | FreelanceIndustryUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: FreelanceIndustryUpdateManyWithWhereWithoutFreelanceInput | FreelanceIndustryUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput> | SkillCreateWithoutFreelanceInput[] | SkillUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutFreelanceInput | SkillCreateOrConnectWithoutFreelanceInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutFreelanceInput | SkillUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: SkillCreateManyFreelanceInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutFreelanceInput | SkillUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutFreelanceInput | SkillUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type FreelanceRevenueUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput> | FreelanceRevenueCreateWithoutFreelanceInput[] | FreelanceRevenueUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceRevenueCreateOrConnectWithoutFreelanceInput | FreelanceRevenueCreateOrConnectWithoutFreelanceInput[]
    upsert?: FreelanceRevenueUpsertWithWhereUniqueWithoutFreelanceInput | FreelanceRevenueUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: FreelanceRevenueCreateManyFreelanceInputEnvelope
    set?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    disconnect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    delete?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    connect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    update?: FreelanceRevenueUpdateWithWhereUniqueWithoutFreelanceInput | FreelanceRevenueUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: FreelanceRevenueUpdateManyWithWhereWithoutFreelanceInput | FreelanceRevenueUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: FreelanceRevenueScalarWhereInput | FreelanceRevenueScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutFreelanceNestedInput = {
    create?: XOR<UserCreateWithoutFreelanceInput, UserUncheckedCreateWithoutFreelanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelanceInput
    upsert?: UserUpsertWithoutFreelanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFreelanceInput, UserUpdateWithoutFreelanceInput>, UserUncheckedUpdateWithoutFreelanceInput>
  }

  export type PortfolioUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput> | PortfolioCreateWithoutFreelanceInput[] | PortfolioUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutFreelanceInput | PortfolioCreateOrConnectWithoutFreelanceInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutFreelanceInput | PortfolioUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: PortfolioCreateManyFreelanceInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutFreelanceInput | PortfolioUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutFreelanceInput | PortfolioUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput> | FreelanceIndustryCreateWithoutFreelanceInput[] | FreelanceIndustryUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutFreelanceInput | FreelanceIndustryCreateOrConnectWithoutFreelanceInput[]
    upsert?: FreelanceIndustryUpsertWithWhereUniqueWithoutFreelanceInput | FreelanceIndustryUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: FreelanceIndustryCreateManyFreelanceInputEnvelope
    set?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    disconnect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    delete?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    update?: FreelanceIndustryUpdateWithWhereUniqueWithoutFreelanceInput | FreelanceIndustryUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: FreelanceIndustryUpdateManyWithWhereWithoutFreelanceInput | FreelanceIndustryUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput> | SkillCreateWithoutFreelanceInput[] | SkillUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutFreelanceInput | SkillCreateOrConnectWithoutFreelanceInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutFreelanceInput | SkillUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: SkillCreateManyFreelanceInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutFreelanceInput | SkillUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutFreelanceInput | SkillUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput> | FreelanceRevenueCreateWithoutFreelanceInput[] | FreelanceRevenueUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: FreelanceRevenueCreateOrConnectWithoutFreelanceInput | FreelanceRevenueCreateOrConnectWithoutFreelanceInput[]
    upsert?: FreelanceRevenueUpsertWithWhereUniqueWithoutFreelanceInput | FreelanceRevenueUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: FreelanceRevenueCreateManyFreelanceInputEnvelope
    set?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    disconnect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    delete?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    connect?: FreelanceRevenueWhereUniqueInput | FreelanceRevenueWhereUniqueInput[]
    update?: FreelanceRevenueUpdateWithWhereUniqueWithoutFreelanceInput | FreelanceRevenueUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: FreelanceRevenueUpdateManyWithWhereWithoutFreelanceInput | FreelanceRevenueUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: FreelanceRevenueScalarWhereInput | FreelanceRevenueScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput = {
    create?: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput> | PortfolioCreateWithoutFreelanceInput[] | PortfolioUncheckedCreateWithoutFreelanceInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutFreelanceInput | PortfolioCreateOrConnectWithoutFreelanceInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutFreelanceInput | PortfolioUpsertWithWhereUniqueWithoutFreelanceInput[]
    createMany?: PortfolioCreateManyFreelanceInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutFreelanceInput | PortfolioUpdateWithWhereUniqueWithoutFreelanceInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutFreelanceInput | PortfolioUpdateManyWithWhereWithoutFreelanceInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type FreelanceCreateNestedOneWithoutIndustriesRelatedInput = {
    create?: XOR<FreelanceCreateWithoutIndustriesRelatedInput, FreelanceUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutIndustriesRelatedInput
    connect?: FreelanceWhereUniqueInput
  }

  export type IndustryCreateNestedOneWithoutFreelancersInput = {
    create?: XOR<IndustryCreateWithoutFreelancersInput, IndustryUncheckedCreateWithoutFreelancersInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutFreelancersInput
    connect?: IndustryWhereUniqueInput
  }

  export type FreelanceUpdateOneRequiredWithoutIndustriesRelatedNestedInput = {
    create?: XOR<FreelanceCreateWithoutIndustriesRelatedInput, FreelanceUncheckedCreateWithoutIndustriesRelatedInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutIndustriesRelatedInput
    upsert?: FreelanceUpsertWithoutIndustriesRelatedInput
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutIndustriesRelatedInput, FreelanceUpdateWithoutIndustriesRelatedInput>, FreelanceUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type IndustryUpdateOneRequiredWithoutFreelancersNestedInput = {
    create?: XOR<IndustryCreateWithoutFreelancersInput, IndustryUncheckedCreateWithoutFreelancersInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutFreelancersInput
    upsert?: IndustryUpsertWithoutFreelancersInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutFreelancersInput, IndustryUpdateWithoutFreelancersInput>, IndustryUncheckedUpdateWithoutFreelancersInput>
  }

  export type SkillCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput> | SkillCreateWithoutIndustryInput[] | SkillUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutIndustryInput | SkillCreateOrConnectWithoutIndustryInput[]
    createMany?: SkillCreateManyIndustryInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SourceCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput> | SourceCreateWithoutIndustryInput[] | SourceUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutIndustryInput | SourceCreateOrConnectWithoutIndustryInput[]
    createMany?: SourceCreateManyIndustryInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutIndustryInput = {
    create?: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput> | ChannelCreateWithoutIndustryInput[] | ChannelUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutIndustryInput | ChannelCreateOrConnectWithoutIndustryInput[]
    createMany?: ChannelCreateManyIndustryInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type SegmentCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput> | SegmentCreateWithoutIndustryInput[] | SegmentUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutIndustryInput | SegmentCreateOrConnectWithoutIndustryInput[]
    createMany?: SegmentCreateManyIndustryInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutIndustryInput = {
    create?: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput> | CategoryCreateWithoutIndustryInput[] | CategoryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutIndustryInput | CategoryCreateOrConnectWithoutIndustryInput[]
    createMany?: CategoryCreateManyIndustryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CompanyIndustryCreateNestedManyWithoutIndustryInput = {
    create?: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput> | CompanyIndustryCreateWithoutIndustryInput[] | CompanyIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutIndustryInput | CompanyIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: CompanyIndustryCreateManyIndustryInputEnvelope
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
  }

  export type FreelanceIndustryCreateNestedManyWithoutIndustryInput = {
    create?: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput> | FreelanceIndustryCreateWithoutIndustryInput[] | FreelanceIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutIndustryInput | FreelanceIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: FreelanceIndustryCreateManyIndustryInputEnvelope
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
  }

  export type UserIndustryCreateNestedManyWithoutIndustryInput = {
    create?: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput> | UserIndustryCreateWithoutIndustryInput[] | UserIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutIndustryInput | UserIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: UserIndustryCreateManyIndustryInputEnvelope
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
  }

  export type StandardsCreateNestedManyWithoutIndustryInput = {
    create?: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput> | StandardsCreateWithoutIndustryInput[] | StandardsUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: StandardsCreateOrConnectWithoutIndustryInput | StandardsCreateOrConnectWithoutIndustryInput[]
    createMany?: StandardsCreateManyIndustryInputEnvelope
    connect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
  }

  export type RevenueStreamCreateNestedManyWithoutIndustryInput = {
    create?: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput> | RevenueStreamCreateWithoutIndustryInput[] | RevenueStreamUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutIndustryInput | RevenueStreamCreateOrConnectWithoutIndustryInput[]
    createMany?: RevenueStreamCreateManyIndustryInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutIndustryInput = {
    create?: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput> | TagCreateWithoutIndustryInput[] | TagUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIndustryInput | TagCreateOrConnectWithoutIndustryInput[]
    createMany?: TagCreateManyIndustryInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type LookingForCreateNestedManyWithoutIndustryInput = {
    create?: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput> | LookingForCreateWithoutIndustryInput[] | LookingForUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: LookingForCreateOrConnectWithoutIndustryInput | LookingForCreateOrConnectWithoutIndustryInput[]
    createMany?: LookingForCreateManyIndustryInputEnvelope
    connect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput> | SkillCreateWithoutIndustryInput[] | SkillUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutIndustryInput | SkillCreateOrConnectWithoutIndustryInput[]
    createMany?: SkillCreateManyIndustryInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SourceUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput> | SourceCreateWithoutIndustryInput[] | SourceUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutIndustryInput | SourceCreateOrConnectWithoutIndustryInput[]
    createMany?: SourceCreateManyIndustryInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput> | ChannelCreateWithoutIndustryInput[] | ChannelUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutIndustryInput | ChannelCreateOrConnectWithoutIndustryInput[]
    createMany?: ChannelCreateManyIndustryInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type SegmentUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput> | SegmentCreateWithoutIndustryInput[] | SegmentUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutIndustryInput | SegmentCreateOrConnectWithoutIndustryInput[]
    createMany?: SegmentCreateManyIndustryInputEnvelope
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput> | CategoryCreateWithoutIndustryInput[] | CategoryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutIndustryInput | CategoryCreateOrConnectWithoutIndustryInput[]
    createMany?: CategoryCreateManyIndustryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput> | CompanyIndustryCreateWithoutIndustryInput[] | CompanyIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutIndustryInput | CompanyIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: CompanyIndustryCreateManyIndustryInputEnvelope
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
  }

  export type FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput> | FreelanceIndustryCreateWithoutIndustryInput[] | FreelanceIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutIndustryInput | FreelanceIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: FreelanceIndustryCreateManyIndustryInputEnvelope
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
  }

  export type UserIndustryUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput> | UserIndustryCreateWithoutIndustryInput[] | UserIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutIndustryInput | UserIndustryCreateOrConnectWithoutIndustryInput[]
    createMany?: UserIndustryCreateManyIndustryInputEnvelope
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
  }

  export type StandardsUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput> | StandardsCreateWithoutIndustryInput[] | StandardsUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: StandardsCreateOrConnectWithoutIndustryInput | StandardsCreateOrConnectWithoutIndustryInput[]
    createMany?: StandardsCreateManyIndustryInputEnvelope
    connect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput> | RevenueStreamCreateWithoutIndustryInput[] | RevenueStreamUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutIndustryInput | RevenueStreamCreateOrConnectWithoutIndustryInput[]
    createMany?: RevenueStreamCreateManyIndustryInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput> | TagCreateWithoutIndustryInput[] | TagUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIndustryInput | TagCreateOrConnectWithoutIndustryInput[]
    createMany?: TagCreateManyIndustryInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type LookingForUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput> | LookingForCreateWithoutIndustryInput[] | LookingForUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: LookingForCreateOrConnectWithoutIndustryInput | LookingForCreateOrConnectWithoutIndustryInput[]
    createMany?: LookingForCreateManyIndustryInputEnvelope
    connect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
  }

  export type SkillUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput> | SkillCreateWithoutIndustryInput[] | SkillUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutIndustryInput | SkillCreateOrConnectWithoutIndustryInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutIndustryInput | SkillUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SkillCreateManyIndustryInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutIndustryInput | SkillUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutIndustryInput | SkillUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SourceUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput> | SourceCreateWithoutIndustryInput[] | SourceUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutIndustryInput | SourceCreateOrConnectWithoutIndustryInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutIndustryInput | SourceUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SourceCreateManyIndustryInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutIndustryInput | SourceUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutIndustryInput | SourceUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput> | ChannelCreateWithoutIndustryInput[] | ChannelUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutIndustryInput | ChannelCreateOrConnectWithoutIndustryInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutIndustryInput | ChannelUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: ChannelCreateManyIndustryInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutIndustryInput | ChannelUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutIndustryInput | ChannelUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type SegmentUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput> | SegmentCreateWithoutIndustryInput[] | SegmentUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutIndustryInput | SegmentCreateOrConnectWithoutIndustryInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutIndustryInput | SegmentUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SegmentCreateManyIndustryInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutIndustryInput | SegmentUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutIndustryInput | SegmentUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput> | CategoryCreateWithoutIndustryInput[] | CategoryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutIndustryInput | CategoryCreateOrConnectWithoutIndustryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutIndustryInput | CategoryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: CategoryCreateManyIndustryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutIndustryInput | CategoryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutIndustryInput | CategoryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CompanyIndustryUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput> | CompanyIndustryCreateWithoutIndustryInput[] | CompanyIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutIndustryInput | CompanyIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: CompanyIndustryUpsertWithWhereUniqueWithoutIndustryInput | CompanyIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: CompanyIndustryCreateManyIndustryInputEnvelope
    set?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    disconnect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    delete?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    update?: CompanyIndustryUpdateWithWhereUniqueWithoutIndustryInput | CompanyIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: CompanyIndustryUpdateManyWithWhereWithoutIndustryInput | CompanyIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
  }

  export type FreelanceIndustryUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput> | FreelanceIndustryCreateWithoutIndustryInput[] | FreelanceIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutIndustryInput | FreelanceIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: FreelanceIndustryUpsertWithWhereUniqueWithoutIndustryInput | FreelanceIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: FreelanceIndustryCreateManyIndustryInputEnvelope
    set?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    disconnect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    delete?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    update?: FreelanceIndustryUpdateWithWhereUniqueWithoutIndustryInput | FreelanceIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: FreelanceIndustryUpdateManyWithWhereWithoutIndustryInput | FreelanceIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
  }

  export type UserIndustryUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput> | UserIndustryCreateWithoutIndustryInput[] | UserIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutIndustryInput | UserIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: UserIndustryUpsertWithWhereUniqueWithoutIndustryInput | UserIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: UserIndustryCreateManyIndustryInputEnvelope
    set?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    disconnect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    delete?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    update?: UserIndustryUpdateWithWhereUniqueWithoutIndustryInput | UserIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: UserIndustryUpdateManyWithWhereWithoutIndustryInput | UserIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
  }

  export type StandardsUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput> | StandardsCreateWithoutIndustryInput[] | StandardsUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: StandardsCreateOrConnectWithoutIndustryInput | StandardsCreateOrConnectWithoutIndustryInput[]
    upsert?: StandardsUpsertWithWhereUniqueWithoutIndustryInput | StandardsUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: StandardsCreateManyIndustryInputEnvelope
    set?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    disconnect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    delete?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    connect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    update?: StandardsUpdateWithWhereUniqueWithoutIndustryInput | StandardsUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: StandardsUpdateManyWithWhereWithoutIndustryInput | StandardsUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: StandardsScalarWhereInput | StandardsScalarWhereInput[]
  }

  export type RevenueStreamUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput> | RevenueStreamCreateWithoutIndustryInput[] | RevenueStreamUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutIndustryInput | RevenueStreamCreateOrConnectWithoutIndustryInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutIndustryInput | RevenueStreamUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: RevenueStreamCreateManyIndustryInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutIndustryInput | RevenueStreamUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutIndustryInput | RevenueStreamUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type TagUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput> | TagCreateWithoutIndustryInput[] | TagUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIndustryInput | TagCreateOrConnectWithoutIndustryInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutIndustryInput | TagUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: TagCreateManyIndustryInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutIndustryInput | TagUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: TagUpdateManyWithWhereWithoutIndustryInput | TagUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type LookingForUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput> | LookingForCreateWithoutIndustryInput[] | LookingForUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: LookingForCreateOrConnectWithoutIndustryInput | LookingForCreateOrConnectWithoutIndustryInput[]
    upsert?: LookingForUpsertWithWhereUniqueWithoutIndustryInput | LookingForUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: LookingForCreateManyIndustryInputEnvelope
    set?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    disconnect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    delete?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    connect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    update?: LookingForUpdateWithWhereUniqueWithoutIndustryInput | LookingForUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: LookingForUpdateManyWithWhereWithoutIndustryInput | LookingForUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: LookingForScalarWhereInput | LookingForScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput> | SkillCreateWithoutIndustryInput[] | SkillUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutIndustryInput | SkillCreateOrConnectWithoutIndustryInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutIndustryInput | SkillUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SkillCreateManyIndustryInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutIndustryInput | SkillUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutIndustryInput | SkillUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SourceUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput> | SourceCreateWithoutIndustryInput[] | SourceUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutIndustryInput | SourceCreateOrConnectWithoutIndustryInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutIndustryInput | SourceUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SourceCreateManyIndustryInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutIndustryInput | SourceUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutIndustryInput | SourceUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput> | ChannelCreateWithoutIndustryInput[] | ChannelUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutIndustryInput | ChannelCreateOrConnectWithoutIndustryInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutIndustryInput | ChannelUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: ChannelCreateManyIndustryInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutIndustryInput | ChannelUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutIndustryInput | ChannelUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type SegmentUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput> | SegmentCreateWithoutIndustryInput[] | SegmentUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SegmentCreateOrConnectWithoutIndustryInput | SegmentCreateOrConnectWithoutIndustryInput[]
    upsert?: SegmentUpsertWithWhereUniqueWithoutIndustryInput | SegmentUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SegmentCreateManyIndustryInputEnvelope
    set?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    disconnect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    delete?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    connect?: SegmentWhereUniqueInput | SegmentWhereUniqueInput[]
    update?: SegmentUpdateWithWhereUniqueWithoutIndustryInput | SegmentUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SegmentUpdateManyWithWhereWithoutIndustryInput | SegmentUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput> | CategoryCreateWithoutIndustryInput[] | CategoryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutIndustryInput | CategoryCreateOrConnectWithoutIndustryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutIndustryInput | CategoryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: CategoryCreateManyIndustryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutIndustryInput | CategoryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutIndustryInput | CategoryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput> | CompanyIndustryCreateWithoutIndustryInput[] | CompanyIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: CompanyIndustryCreateOrConnectWithoutIndustryInput | CompanyIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: CompanyIndustryUpsertWithWhereUniqueWithoutIndustryInput | CompanyIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: CompanyIndustryCreateManyIndustryInputEnvelope
    set?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    disconnect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    delete?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    connect?: CompanyIndustryWhereUniqueInput | CompanyIndustryWhereUniqueInput[]
    update?: CompanyIndustryUpdateWithWhereUniqueWithoutIndustryInput | CompanyIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: CompanyIndustryUpdateManyWithWhereWithoutIndustryInput | CompanyIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
  }

  export type FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput> | FreelanceIndustryCreateWithoutIndustryInput[] | FreelanceIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: FreelanceIndustryCreateOrConnectWithoutIndustryInput | FreelanceIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: FreelanceIndustryUpsertWithWhereUniqueWithoutIndustryInput | FreelanceIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: FreelanceIndustryCreateManyIndustryInputEnvelope
    set?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    disconnect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    delete?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    connect?: FreelanceIndustryWhereUniqueInput | FreelanceIndustryWhereUniqueInput[]
    update?: FreelanceIndustryUpdateWithWhereUniqueWithoutIndustryInput | FreelanceIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: FreelanceIndustryUpdateManyWithWhereWithoutIndustryInput | FreelanceIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
  }

  export type UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput> | UserIndustryCreateWithoutIndustryInput[] | UserIndustryUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: UserIndustryCreateOrConnectWithoutIndustryInput | UserIndustryCreateOrConnectWithoutIndustryInput[]
    upsert?: UserIndustryUpsertWithWhereUniqueWithoutIndustryInput | UserIndustryUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: UserIndustryCreateManyIndustryInputEnvelope
    set?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    disconnect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    delete?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    connect?: UserIndustryWhereUniqueInput | UserIndustryWhereUniqueInput[]
    update?: UserIndustryUpdateWithWhereUniqueWithoutIndustryInput | UserIndustryUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: UserIndustryUpdateManyWithWhereWithoutIndustryInput | UserIndustryUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
  }

  export type StandardsUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput> | StandardsCreateWithoutIndustryInput[] | StandardsUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: StandardsCreateOrConnectWithoutIndustryInput | StandardsCreateOrConnectWithoutIndustryInput[]
    upsert?: StandardsUpsertWithWhereUniqueWithoutIndustryInput | StandardsUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: StandardsCreateManyIndustryInputEnvelope
    set?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    disconnect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    delete?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    connect?: StandardsWhereUniqueInput | StandardsWhereUniqueInput[]
    update?: StandardsUpdateWithWhereUniqueWithoutIndustryInput | StandardsUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: StandardsUpdateManyWithWhereWithoutIndustryInput | StandardsUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: StandardsScalarWhereInput | StandardsScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput> | RevenueStreamCreateWithoutIndustryInput[] | RevenueStreamUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutIndustryInput | RevenueStreamCreateOrConnectWithoutIndustryInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutIndustryInput | RevenueStreamUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: RevenueStreamCreateManyIndustryInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutIndustryInput | RevenueStreamUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutIndustryInput | RevenueStreamUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput> | TagCreateWithoutIndustryInput[] | TagUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: TagCreateOrConnectWithoutIndustryInput | TagCreateOrConnectWithoutIndustryInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutIndustryInput | TagUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: TagCreateManyIndustryInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutIndustryInput | TagUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: TagUpdateManyWithWhereWithoutIndustryInput | TagUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type LookingForUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput> | LookingForCreateWithoutIndustryInput[] | LookingForUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: LookingForCreateOrConnectWithoutIndustryInput | LookingForCreateOrConnectWithoutIndustryInput[]
    upsert?: LookingForUpsertWithWhereUniqueWithoutIndustryInput | LookingForUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: LookingForCreateManyIndustryInputEnvelope
    set?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    disconnect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    delete?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    connect?: LookingForWhereUniqueInput | LookingForWhereUniqueInput[]
    update?: LookingForUpdateWithWhereUniqueWithoutIndustryInput | LookingForUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: LookingForUpdateManyWithWhereWithoutIndustryInput | LookingForUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: LookingForScalarWhereInput | LookingForScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutTagInput = {
    create?: XOR<IndustryCreateWithoutTagInput, IndustryUncheckedCreateWithoutTagInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutTagInput
    connect?: IndustryWhereUniqueInput
  }

  export type PortfolioTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput> | PortfolioTagCreateWithoutTagInput[] | PortfolioTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutTagInput | PortfolioTagCreateOrConnectWithoutTagInput[]
    createMany?: PortfolioTagCreateManyTagInputEnvelope
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
  }

  export type UserTagsCreateNestedManyWithoutTagInput = {
    create?: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput> | UserTagsCreateWithoutTagInput[] | UserTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutTagInput | UserTagsCreateOrConnectWithoutTagInput[]
    createMany?: UserTagsCreateManyTagInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type PortfolioTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput> | PortfolioTagCreateWithoutTagInput[] | PortfolioTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutTagInput | PortfolioTagCreateOrConnectWithoutTagInput[]
    createMany?: PortfolioTagCreateManyTagInputEnvelope
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
  }

  export type UserTagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput> | UserTagsCreateWithoutTagInput[] | UserTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutTagInput | UserTagsCreateOrConnectWithoutTagInput[]
    createMany?: UserTagsCreateManyTagInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutTagNestedInput = {
    create?: XOR<IndustryCreateWithoutTagInput, IndustryUncheckedCreateWithoutTagInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutTagInput
    upsert?: IndustryUpsertWithoutTagInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutTagInput, IndustryUpdateWithoutTagInput>, IndustryUncheckedUpdateWithoutTagInput>
  }

  export type PortfolioTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput> | PortfolioTagCreateWithoutTagInput[] | PortfolioTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutTagInput | PortfolioTagCreateOrConnectWithoutTagInput[]
    upsert?: PortfolioTagUpsertWithWhereUniqueWithoutTagInput | PortfolioTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PortfolioTagCreateManyTagInputEnvelope
    set?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    disconnect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    delete?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    update?: PortfolioTagUpdateWithWhereUniqueWithoutTagInput | PortfolioTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PortfolioTagUpdateManyWithWhereWithoutTagInput | PortfolioTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
  }

  export type UserTagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput> | UserTagsCreateWithoutTagInput[] | UserTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutTagInput | UserTagsCreateOrConnectWithoutTagInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutTagInput | UserTagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: UserTagsCreateManyTagInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutTagInput | UserTagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutTagInput | UserTagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type PortfolioTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput> | PortfolioTagCreateWithoutTagInput[] | PortfolioTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutTagInput | PortfolioTagCreateOrConnectWithoutTagInput[]
    upsert?: PortfolioTagUpsertWithWhereUniqueWithoutTagInput | PortfolioTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PortfolioTagCreateManyTagInputEnvelope
    set?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    disconnect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    delete?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    update?: PortfolioTagUpdateWithWhereUniqueWithoutTagInput | PortfolioTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PortfolioTagUpdateManyWithWhereWithoutTagInput | PortfolioTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
  }

  export type UserTagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput> | UserTagsCreateWithoutTagInput[] | UserTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutTagInput | UserTagsCreateOrConnectWithoutTagInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutTagInput | UserTagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: UserTagsCreateManyTagInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutTagInput | UserTagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutTagInput | UserTagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutLookingForInput = {
    create?: XOR<IndustryCreateWithoutLookingForInput, IndustryUncheckedCreateWithoutLookingForInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutLookingForInput
    connect?: IndustryWhereUniqueInput
  }

  export type PortfolioLookingForCreateNestedManyWithoutLookingForInput = {
    create?: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput> | PortfolioLookingForCreateWithoutLookingForInput[] | PortfolioLookingForUncheckedCreateWithoutLookingForInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutLookingForInput | PortfolioLookingForCreateOrConnectWithoutLookingForInput[]
    createMany?: PortfolioLookingForCreateManyLookingForInputEnvelope
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
  }

  export type PortfolioLookingForUncheckedCreateNestedManyWithoutLookingForInput = {
    create?: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput> | PortfolioLookingForCreateWithoutLookingForInput[] | PortfolioLookingForUncheckedCreateWithoutLookingForInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutLookingForInput | PortfolioLookingForCreateOrConnectWithoutLookingForInput[]
    createMany?: PortfolioLookingForCreateManyLookingForInputEnvelope
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutLookingForNestedInput = {
    create?: XOR<IndustryCreateWithoutLookingForInput, IndustryUncheckedCreateWithoutLookingForInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutLookingForInput
    upsert?: IndustryUpsertWithoutLookingForInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutLookingForInput, IndustryUpdateWithoutLookingForInput>, IndustryUncheckedUpdateWithoutLookingForInput>
  }

  export type PortfolioLookingForUpdateManyWithoutLookingForNestedInput = {
    create?: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput> | PortfolioLookingForCreateWithoutLookingForInput[] | PortfolioLookingForUncheckedCreateWithoutLookingForInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutLookingForInput | PortfolioLookingForCreateOrConnectWithoutLookingForInput[]
    upsert?: PortfolioLookingForUpsertWithWhereUniqueWithoutLookingForInput | PortfolioLookingForUpsertWithWhereUniqueWithoutLookingForInput[]
    createMany?: PortfolioLookingForCreateManyLookingForInputEnvelope
    set?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    disconnect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    delete?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    update?: PortfolioLookingForUpdateWithWhereUniqueWithoutLookingForInput | PortfolioLookingForUpdateWithWhereUniqueWithoutLookingForInput[]
    updateMany?: PortfolioLookingForUpdateManyWithWhereWithoutLookingForInput | PortfolioLookingForUpdateManyWithWhereWithoutLookingForInput[]
    deleteMany?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
  }

  export type PortfolioLookingForUncheckedUpdateManyWithoutLookingForNestedInput = {
    create?: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput> | PortfolioLookingForCreateWithoutLookingForInput[] | PortfolioLookingForUncheckedCreateWithoutLookingForInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutLookingForInput | PortfolioLookingForCreateOrConnectWithoutLookingForInput[]
    upsert?: PortfolioLookingForUpsertWithWhereUniqueWithoutLookingForInput | PortfolioLookingForUpsertWithWhereUniqueWithoutLookingForInput[]
    createMany?: PortfolioLookingForCreateManyLookingForInputEnvelope
    set?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    disconnect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    delete?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    update?: PortfolioLookingForUpdateWithWhereUniqueWithoutLookingForInput | PortfolioLookingForUpdateWithWhereUniqueWithoutLookingForInput[]
    updateMany?: PortfolioLookingForUpdateManyWithWhereWithoutLookingForInput | PortfolioLookingForUpdateManyWithWhereWithoutLookingForInput[]
    deleteMany?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutCategoryInput = {
    create?: XOR<IndustryCreateWithoutCategoryInput, IndustryUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutCategoryInput
    connect?: IndustryWhereUniqueInput
  }

  export type RevenueStreamCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput> | RevenueStreamCreateWithoutCategoryInput[] | RevenueStreamUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCategoryInput | RevenueStreamCreateOrConnectWithoutCategoryInput[]
    createMany?: RevenueStreamCreateManyCategoryInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput> | RevenueStreamCreateWithoutCategoryInput[] | RevenueStreamUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCategoryInput | RevenueStreamCreateOrConnectWithoutCategoryInput[]
    createMany?: RevenueStreamCreateManyCategoryInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutCategoryNestedInput = {
    create?: XOR<IndustryCreateWithoutCategoryInput, IndustryUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutCategoryInput
    upsert?: IndustryUpsertWithoutCategoryInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutCategoryInput, IndustryUpdateWithoutCategoryInput>, IndustryUncheckedUpdateWithoutCategoryInput>
  }

  export type RevenueStreamUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput> | RevenueStreamCreateWithoutCategoryInput[] | RevenueStreamUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCategoryInput | RevenueStreamCreateOrConnectWithoutCategoryInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutCategoryInput | RevenueStreamUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RevenueStreamCreateManyCategoryInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutCategoryInput | RevenueStreamUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutCategoryInput | RevenueStreamUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput> | RevenueStreamCreateWithoutCategoryInput[] | RevenueStreamUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutCategoryInput | RevenueStreamCreateOrConnectWithoutCategoryInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutCategoryInput | RevenueStreamUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RevenueStreamCreateManyCategoryInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutCategoryInput | RevenueStreamUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutCategoryInput | RevenueStreamUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutSourceInput = {
    create?: XOR<IndustryCreateWithoutSourceInput, IndustryUncheckedCreateWithoutSourceInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSourceInput
    connect?: IndustryWhereUniqueInput
  }

  export type RevenueStreamCreateNestedManyWithoutSourceInput = {
    create?: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput> | RevenueStreamCreateWithoutSourceInput[] | RevenueStreamUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSourceInput | RevenueStreamCreateOrConnectWithoutSourceInput[]
    createMany?: RevenueStreamCreateManySourceInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput> | RevenueStreamCreateWithoutSourceInput[] | RevenueStreamUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSourceInput | RevenueStreamCreateOrConnectWithoutSourceInput[]
    createMany?: RevenueStreamCreateManySourceInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutSourceNestedInput = {
    create?: XOR<IndustryCreateWithoutSourceInput, IndustryUncheckedCreateWithoutSourceInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSourceInput
    upsert?: IndustryUpsertWithoutSourceInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutSourceInput, IndustryUpdateWithoutSourceInput>, IndustryUncheckedUpdateWithoutSourceInput>
  }

  export type RevenueStreamUpdateManyWithoutSourceNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput> | RevenueStreamCreateWithoutSourceInput[] | RevenueStreamUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSourceInput | RevenueStreamCreateOrConnectWithoutSourceInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutSourceInput | RevenueStreamUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: RevenueStreamCreateManySourceInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutSourceInput | RevenueStreamUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutSourceInput | RevenueStreamUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput> | RevenueStreamCreateWithoutSourceInput[] | RevenueStreamUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSourceInput | RevenueStreamCreateOrConnectWithoutSourceInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutSourceInput | RevenueStreamUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: RevenueStreamCreateManySourceInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutSourceInput | RevenueStreamUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutSourceInput | RevenueStreamUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutChannelInput = {
    create?: XOR<IndustryCreateWithoutChannelInput, IndustryUncheckedCreateWithoutChannelInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutChannelInput
    connect?: IndustryWhereUniqueInput
  }

  export type RevenueStreamCreateNestedManyWithoutChannelInput = {
    create?: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput> | RevenueStreamCreateWithoutChannelInput[] | RevenueStreamUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutChannelInput | RevenueStreamCreateOrConnectWithoutChannelInput[]
    createMany?: RevenueStreamCreateManyChannelInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type UserChannelsCreateNestedManyWithoutChannelInput = {
    create?: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput> | UserChannelsCreateWithoutChannelInput[] | UserChannelsUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutChannelInput | UserChannelsCreateOrConnectWithoutChannelInput[]
    createMany?: UserChannelsCreateManyChannelInputEnvelope
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput> | RevenueStreamCreateWithoutChannelInput[] | RevenueStreamUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutChannelInput | RevenueStreamCreateOrConnectWithoutChannelInput[]
    createMany?: RevenueStreamCreateManyChannelInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type UserChannelsUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput> | UserChannelsCreateWithoutChannelInput[] | UserChannelsUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutChannelInput | UserChannelsCreateOrConnectWithoutChannelInput[]
    createMany?: UserChannelsCreateManyChannelInputEnvelope
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutChannelNestedInput = {
    create?: XOR<IndustryCreateWithoutChannelInput, IndustryUncheckedCreateWithoutChannelInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutChannelInput
    upsert?: IndustryUpsertWithoutChannelInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutChannelInput, IndustryUpdateWithoutChannelInput>, IndustryUncheckedUpdateWithoutChannelInput>
  }

  export type RevenueStreamUpdateManyWithoutChannelNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput> | RevenueStreamCreateWithoutChannelInput[] | RevenueStreamUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutChannelInput | RevenueStreamCreateOrConnectWithoutChannelInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutChannelInput | RevenueStreamUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: RevenueStreamCreateManyChannelInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutChannelInput | RevenueStreamUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutChannelInput | RevenueStreamUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type UserChannelsUpdateManyWithoutChannelNestedInput = {
    create?: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput> | UserChannelsCreateWithoutChannelInput[] | UserChannelsUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutChannelInput | UserChannelsCreateOrConnectWithoutChannelInput[]
    upsert?: UserChannelsUpsertWithWhereUniqueWithoutChannelInput | UserChannelsUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: UserChannelsCreateManyChannelInputEnvelope
    set?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    disconnect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    delete?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    update?: UserChannelsUpdateWithWhereUniqueWithoutChannelInput | UserChannelsUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: UserChannelsUpdateManyWithWhereWithoutChannelInput | UserChannelsUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput> | RevenueStreamCreateWithoutChannelInput[] | RevenueStreamUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutChannelInput | RevenueStreamCreateOrConnectWithoutChannelInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutChannelInput | RevenueStreamUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: RevenueStreamCreateManyChannelInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutChannelInput | RevenueStreamUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutChannelInput | RevenueStreamUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type UserChannelsUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput> | UserChannelsCreateWithoutChannelInput[] | UserChannelsUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: UserChannelsCreateOrConnectWithoutChannelInput | UserChannelsCreateOrConnectWithoutChannelInput[]
    upsert?: UserChannelsUpsertWithWhereUniqueWithoutChannelInput | UserChannelsUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: UserChannelsCreateManyChannelInputEnvelope
    set?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    disconnect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    delete?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    connect?: UserChannelsWhereUniqueInput | UserChannelsWhereUniqueInput[]
    update?: UserChannelsUpdateWithWhereUniqueWithoutChannelInput | UserChannelsUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: UserChannelsUpdateManyWithWhereWithoutChannelInput | UserChannelsUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutSegmentInput = {
    create?: XOR<IndustryCreateWithoutSegmentInput, IndustryUncheckedCreateWithoutSegmentInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSegmentInput
    connect?: IndustryWhereUniqueInput
  }

  export type RevenueStreamCreateNestedManyWithoutSegmentInput = {
    create?: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput> | RevenueStreamCreateWithoutSegmentInput[] | RevenueStreamUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSegmentInput | RevenueStreamCreateOrConnectWithoutSegmentInput[]
    createMany?: RevenueStreamCreateManySegmentInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type RevenueStreamUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput> | RevenueStreamCreateWithoutSegmentInput[] | RevenueStreamUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSegmentInput | RevenueStreamCreateOrConnectWithoutSegmentInput[]
    createMany?: RevenueStreamCreateManySegmentInputEnvelope
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutSegmentNestedInput = {
    create?: XOR<IndustryCreateWithoutSegmentInput, IndustryUncheckedCreateWithoutSegmentInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSegmentInput
    upsert?: IndustryUpsertWithoutSegmentInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutSegmentInput, IndustryUpdateWithoutSegmentInput>, IndustryUncheckedUpdateWithoutSegmentInput>
  }

  export type RevenueStreamUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput> | RevenueStreamCreateWithoutSegmentInput[] | RevenueStreamUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSegmentInput | RevenueStreamCreateOrConnectWithoutSegmentInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutSegmentInput | RevenueStreamUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: RevenueStreamCreateManySegmentInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutSegmentInput | RevenueStreamUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutSegmentInput | RevenueStreamUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type RevenueStreamUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput> | RevenueStreamCreateWithoutSegmentInput[] | RevenueStreamUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: RevenueStreamCreateOrConnectWithoutSegmentInput | RevenueStreamCreateOrConnectWithoutSegmentInput[]
    upsert?: RevenueStreamUpsertWithWhereUniqueWithoutSegmentInput | RevenueStreamUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: RevenueStreamCreateManySegmentInputEnvelope
    set?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    disconnect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    delete?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    connect?: RevenueStreamWhereUniqueInput | RevenueStreamWhereUniqueInput[]
    update?: RevenueStreamUpdateWithWhereUniqueWithoutSegmentInput | RevenueStreamUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: RevenueStreamUpdateManyWithWhereWithoutSegmentInput | RevenueStreamUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
  }

  export type PortfolioCreatetagsInput = {
    set: string[]
  }

  export type PortfolioCreatelooking_forInput = {
    set: string[]
  }

  export type PortfolioTagCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput> | PortfolioTagCreateWithoutPortfolioInput[] | PortfolioTagUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutPortfolioInput | PortfolioTagCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioTagCreateManyPortfolioInputEnvelope
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
  }

  export type PortfolioLookingForCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput> | PortfolioLookingForCreateWithoutPortfolioInput[] | PortfolioLookingForUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutPortfolioInput | PortfolioLookingForCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioLookingForCreateManyPortfolioInputEnvelope
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
  }

  export type FreelanceCreateNestedOneWithoutPortfolioInput = {
    create?: XOR<FreelanceCreateWithoutPortfolioInput, FreelanceUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutPortfolioInput
    connect?: FreelanceWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPortfolioInput = {
    create?: XOR<CompanyCreateWithoutPortfolioInput, CompanyUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPortfolioInput
    connect?: CompanyWhereUniqueInput
  }

  export type FavoriteCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput> | FavoriteCreateWithoutPortfolioInput[] | FavoriteUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPortfolioInput | FavoriteCreateOrConnectWithoutPortfolioInput[]
    createMany?: FavoriteCreateManyPortfolioInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PortfolioImageCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput> | PortfolioImageCreateWithoutPortfolioInput[] | PortfolioImageUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioImageCreateOrConnectWithoutPortfolioInput | PortfolioImageCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioImageCreateManyPortfolioInputEnvelope
    connect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
  }

  export type PortfolioStandardsCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput> | PortfolioStandardsCreateWithoutPortfolioInput[] | PortfolioStandardsUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutPortfolioInput | PortfolioStandardsCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioStandardsCreateManyPortfolioInputEnvelope
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
  }

  export type PortfolioCommentCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput> | PortfolioCommentCreateWithoutPortfolioInput[] | PortfolioCommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutPortfolioInput | PortfolioCommentCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioCommentCreateManyPortfolioInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput> | PortfolioTagCreateWithoutPortfolioInput[] | PortfolioTagUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutPortfolioInput | PortfolioTagCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioTagCreateManyPortfolioInputEnvelope
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
  }

  export type PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput> | PortfolioLookingForCreateWithoutPortfolioInput[] | PortfolioLookingForUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutPortfolioInput | PortfolioLookingForCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioLookingForCreateManyPortfolioInputEnvelope
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput> | FavoriteCreateWithoutPortfolioInput[] | FavoriteUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPortfolioInput | FavoriteCreateOrConnectWithoutPortfolioInput[]
    createMany?: FavoriteCreateManyPortfolioInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput> | PortfolioImageCreateWithoutPortfolioInput[] | PortfolioImageUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioImageCreateOrConnectWithoutPortfolioInput | PortfolioImageCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioImageCreateManyPortfolioInputEnvelope
    connect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
  }

  export type PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput> | PortfolioStandardsCreateWithoutPortfolioInput[] | PortfolioStandardsUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutPortfolioInput | PortfolioStandardsCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioStandardsCreateManyPortfolioInputEnvelope
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
  }

  export type PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput> | PortfolioCommentCreateWithoutPortfolioInput[] | PortfolioCommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutPortfolioInput | PortfolioCommentCreateOrConnectWithoutPortfolioInput[]
    createMany?: PortfolioCommentCreateManyPortfolioInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type PortfolioUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PortfolioUpdatelooking_forInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PortfolioTagUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput> | PortfolioTagCreateWithoutPortfolioInput[] | PortfolioTagUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutPortfolioInput | PortfolioTagCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioTagUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioTagUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioTagCreateManyPortfolioInputEnvelope
    set?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    disconnect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    delete?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    update?: PortfolioTagUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioTagUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioTagUpdateManyWithWhereWithoutPortfolioInput | PortfolioTagUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
  }

  export type PortfolioLookingForUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput> | PortfolioLookingForCreateWithoutPortfolioInput[] | PortfolioLookingForUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutPortfolioInput | PortfolioLookingForCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioLookingForUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioLookingForUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioLookingForCreateManyPortfolioInputEnvelope
    set?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    disconnect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    delete?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    update?: PortfolioLookingForUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioLookingForUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioLookingForUpdateManyWithWhereWithoutPortfolioInput | PortfolioLookingForUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
  }

  export type FreelanceUpdateOneWithoutPortfolioNestedInput = {
    create?: XOR<FreelanceCreateWithoutPortfolioInput, FreelanceUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutPortfolioInput
    upsert?: FreelanceUpsertWithoutPortfolioInput
    disconnect?: FreelanceWhereInput | boolean
    delete?: FreelanceWhereInput | boolean
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutPortfolioInput, FreelanceUpdateWithoutPortfolioInput>, FreelanceUncheckedUpdateWithoutPortfolioInput>
  }

  export type CompanyUpdateOneWithoutPortfolioNestedInput = {
    create?: XOR<CompanyCreateWithoutPortfolioInput, CompanyUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPortfolioInput
    upsert?: CompanyUpsertWithoutPortfolioInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPortfolioInput, CompanyUpdateWithoutPortfolioInput>, CompanyUncheckedUpdateWithoutPortfolioInput>
  }

  export type FavoriteUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput> | FavoriteCreateWithoutPortfolioInput[] | FavoriteUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPortfolioInput | FavoriteCreateOrConnectWithoutPortfolioInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutPortfolioInput | FavoriteUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: FavoriteCreateManyPortfolioInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutPortfolioInput | FavoriteUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutPortfolioInput | FavoriteUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PortfolioImageUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput> | PortfolioImageCreateWithoutPortfolioInput[] | PortfolioImageUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioImageCreateOrConnectWithoutPortfolioInput | PortfolioImageCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioImageUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioImageUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioImageCreateManyPortfolioInputEnvelope
    set?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    disconnect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    delete?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    connect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    update?: PortfolioImageUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioImageUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioImageUpdateManyWithWhereWithoutPortfolioInput | PortfolioImageUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioImageScalarWhereInput | PortfolioImageScalarWhereInput[]
  }

  export type PortfolioStandardsUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput> | PortfolioStandardsCreateWithoutPortfolioInput[] | PortfolioStandardsUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutPortfolioInput | PortfolioStandardsCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioStandardsUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioStandardsUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioStandardsCreateManyPortfolioInputEnvelope
    set?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    disconnect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    delete?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    update?: PortfolioStandardsUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioStandardsUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioStandardsUpdateManyWithWhereWithoutPortfolioInput | PortfolioStandardsUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
  }

  export type PortfolioCommentUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput> | PortfolioCommentCreateWithoutPortfolioInput[] | PortfolioCommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutPortfolioInput | PortfolioCommentCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioCommentUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioCommentCreateManyPortfolioInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioCommentUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutPortfolioInput | PortfolioCommentUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput> | PortfolioTagCreateWithoutPortfolioInput[] | PortfolioTagUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioTagCreateOrConnectWithoutPortfolioInput | PortfolioTagCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioTagUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioTagUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioTagCreateManyPortfolioInputEnvelope
    set?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    disconnect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    delete?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    connect?: PortfolioTagWhereUniqueInput | PortfolioTagWhereUniqueInput[]
    update?: PortfolioTagUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioTagUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioTagUpdateManyWithWhereWithoutPortfolioInput | PortfolioTagUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
  }

  export type PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput> | PortfolioLookingForCreateWithoutPortfolioInput[] | PortfolioLookingForUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioLookingForCreateOrConnectWithoutPortfolioInput | PortfolioLookingForCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioLookingForUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioLookingForUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioLookingForCreateManyPortfolioInputEnvelope
    set?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    disconnect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    delete?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    connect?: PortfolioLookingForWhereUniqueInput | PortfolioLookingForWhereUniqueInput[]
    update?: PortfolioLookingForUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioLookingForUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioLookingForUpdateManyWithWhereWithoutPortfolioInput | PortfolioLookingForUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput> | FavoriteCreateWithoutPortfolioInput[] | FavoriteUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutPortfolioInput | FavoriteCreateOrConnectWithoutPortfolioInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutPortfolioInput | FavoriteUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: FavoriteCreateManyPortfolioInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutPortfolioInput | FavoriteUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutPortfolioInput | FavoriteUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput> | PortfolioImageCreateWithoutPortfolioInput[] | PortfolioImageUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioImageCreateOrConnectWithoutPortfolioInput | PortfolioImageCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioImageUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioImageUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioImageCreateManyPortfolioInputEnvelope
    set?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    disconnect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    delete?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    connect?: PortfolioImageWhereUniqueInput | PortfolioImageWhereUniqueInput[]
    update?: PortfolioImageUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioImageUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioImageUpdateManyWithWhereWithoutPortfolioInput | PortfolioImageUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioImageScalarWhereInput | PortfolioImageScalarWhereInput[]
  }

  export type PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput> | PortfolioStandardsCreateWithoutPortfolioInput[] | PortfolioStandardsUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutPortfolioInput | PortfolioStandardsCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioStandardsUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioStandardsUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioStandardsCreateManyPortfolioInputEnvelope
    set?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    disconnect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    delete?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    update?: PortfolioStandardsUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioStandardsUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioStandardsUpdateManyWithWhereWithoutPortfolioInput | PortfolioStandardsUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput> | PortfolioCommentCreateWithoutPortfolioInput[] | PortfolioCommentUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutPortfolioInput | PortfolioCommentCreateOrConnectWithoutPortfolioInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutPortfolioInput | PortfolioCommentUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: PortfolioCommentCreateManyPortfolioInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutPortfolioInput | PortfolioCommentUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutPortfolioInput | PortfolioCommentUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type PortfolioCreateNestedOneWithoutIndustryTagsInput = {
    create?: XOR<PortfolioCreateWithoutIndustryTagsInput, PortfolioUncheckedCreateWithoutIndustryTagsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutIndustryTagsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPortfolioTagInput = {
    create?: XOR<TagCreateWithoutPortfolioTagInput, TagUncheckedCreateWithoutPortfolioTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutPortfolioTagInput
    connect?: TagWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutIndustryTagsNestedInput = {
    create?: XOR<PortfolioCreateWithoutIndustryTagsInput, PortfolioUncheckedCreateWithoutIndustryTagsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutIndustryTagsInput
    upsert?: PortfolioUpsertWithoutIndustryTagsInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutIndustryTagsInput, PortfolioUpdateWithoutIndustryTagsInput>, PortfolioUncheckedUpdateWithoutIndustryTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPortfolioTagNestedInput = {
    create?: XOR<TagCreateWithoutPortfolioTagInput, TagUncheckedCreateWithoutPortfolioTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutPortfolioTagInput
    upsert?: TagUpsertWithoutPortfolioTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPortfolioTagInput, TagUpdateWithoutPortfolioTagInput>, TagUncheckedUpdateWithoutPortfolioTagInput>
  }

  export type PortfolioCreateNestedOneWithoutIndustryLookingForInput = {
    create?: XOR<PortfolioCreateWithoutIndustryLookingForInput, PortfolioUncheckedCreateWithoutIndustryLookingForInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutIndustryLookingForInput
    connect?: PortfolioWhereUniqueInput
  }

  export type LookingForCreateNestedOneWithoutPortfolioLookingForInput = {
    create?: XOR<LookingForCreateWithoutPortfolioLookingForInput, LookingForUncheckedCreateWithoutPortfolioLookingForInput>
    connectOrCreate?: LookingForCreateOrConnectWithoutPortfolioLookingForInput
    connect?: LookingForWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutIndustryLookingForNestedInput = {
    create?: XOR<PortfolioCreateWithoutIndustryLookingForInput, PortfolioUncheckedCreateWithoutIndustryLookingForInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutIndustryLookingForInput
    upsert?: PortfolioUpsertWithoutIndustryLookingForInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutIndustryLookingForInput, PortfolioUpdateWithoutIndustryLookingForInput>, PortfolioUncheckedUpdateWithoutIndustryLookingForInput>
  }

  export type LookingForUpdateOneRequiredWithoutPortfolioLookingForNestedInput = {
    create?: XOR<LookingForCreateWithoutPortfolioLookingForInput, LookingForUncheckedCreateWithoutPortfolioLookingForInput>
    connectOrCreate?: LookingForCreateOrConnectWithoutPortfolioLookingForInput
    upsert?: LookingForUpsertWithoutPortfolioLookingForInput
    connect?: LookingForWhereUniqueInput
    update?: XOR<XOR<LookingForUpdateToOneWithWhereWithoutPortfolioLookingForInput, LookingForUpdateWithoutPortfolioLookingForInput>, LookingForUncheckedUpdateWithoutPortfolioLookingForInput>
  }

  export type PortfolioCreateNestedOneWithoutStandardsInput = {
    create?: XOR<PortfolioCreateWithoutStandardsInput, PortfolioUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutStandardsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type StandardsCreateNestedOneWithoutPortfolioStandardsInput = {
    create?: XOR<StandardsCreateWithoutPortfolioStandardsInput, StandardsUncheckedCreateWithoutPortfolioStandardsInput>
    connectOrCreate?: StandardsCreateOrConnectWithoutPortfolioStandardsInput
    connect?: StandardsWhereUniqueInput
  }

  export type PortfolioUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<PortfolioCreateWithoutStandardsInput, PortfolioUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutStandardsInput
    upsert?: PortfolioUpsertWithoutStandardsInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutStandardsInput, PortfolioUpdateWithoutStandardsInput>, PortfolioUncheckedUpdateWithoutStandardsInput>
  }

  export type StandardsUpdateOneRequiredWithoutPortfolioStandardsNestedInput = {
    create?: XOR<StandardsCreateWithoutPortfolioStandardsInput, StandardsUncheckedCreateWithoutPortfolioStandardsInput>
    connectOrCreate?: StandardsCreateOrConnectWithoutPortfolioStandardsInput
    upsert?: StandardsUpsertWithoutPortfolioStandardsInput
    connect?: StandardsWhereUniqueInput
    update?: XOR<XOR<StandardsUpdateToOneWithWhereWithoutPortfolioStandardsInput, StandardsUpdateWithoutPortfolioStandardsInput>, StandardsUncheckedUpdateWithoutPortfolioStandardsInput>
  }

  export type PortfolioCreateNestedOneWithoutImageInput = {
    create?: XOR<PortfolioCreateWithoutImageInput, PortfolioUncheckedCreateWithoutImageInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutImageInput
    connect?: PortfolioWhereUniqueInput
  }

  export type EnumPortfolioImageTypeFieldUpdateOperationsInput = {
    set?: $Enums.PortfolioImageType
  }

  export type PortfolioUpdateOneRequiredWithoutImageNestedInput = {
    create?: XOR<PortfolioCreateWithoutImageInput, PortfolioUncheckedCreateWithoutImageInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutImageInput
    upsert?: PortfolioUpsertWithoutImageInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutImageInput, PortfolioUpdateWithoutImageInput>, PortfolioUncheckedUpdateWithoutImageInput>
  }

  export type PortfolioCreateNestedOneWithoutFavoriteInput = {
    create?: XOR<PortfolioCreateWithoutFavoriteInput, PortfolioUncheckedCreateWithoutFavoriteInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutFavoriteInput
    connect?: PortfolioWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavoriteInput = {
    create?: XOR<UserCreateWithoutFavoriteInput, UserUncheckedCreateWithoutFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFavoriteActionFieldUpdateOperationsInput = {
    set?: $Enums.FavoriteAction
  }

  export type PortfolioUpdateOneRequiredWithoutFavoriteNestedInput = {
    create?: XOR<PortfolioCreateWithoutFavoriteInput, PortfolioUncheckedCreateWithoutFavoriteInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutFavoriteInput
    upsert?: PortfolioUpsertWithoutFavoriteInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutFavoriteInput, PortfolioUpdateWithoutFavoriteInput>, PortfolioUncheckedUpdateWithoutFavoriteInput>
  }

  export type UserUpdateOneRequiredWithoutFavoriteNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteInput, UserUncheckedCreateWithoutFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteInput
    upsert?: UserUpsertWithoutFavoriteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteInput, UserUpdateWithoutFavoriteInput>, UserUncheckedUpdateWithoutFavoriteInput>
  }

  export type IndustryCreateNestedOneWithoutStandardsInput = {
    create?: XOR<IndustryCreateWithoutStandardsInput, IndustryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutStandardsInput
    connect?: IndustryWhereUniqueInput
  }

  export type PortfolioStandardsCreateNestedManyWithoutStandardsInput = {
    create?: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput> | PortfolioStandardsCreateWithoutStandardsInput[] | PortfolioStandardsUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutStandardsInput | PortfolioStandardsCreateOrConnectWithoutStandardsInput[]
    createMany?: PortfolioStandardsCreateManyStandardsInputEnvelope
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
  }

  export type PortfolioStandardsUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput> | PortfolioStandardsCreateWithoutStandardsInput[] | PortfolioStandardsUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutStandardsInput | PortfolioStandardsCreateOrConnectWithoutStandardsInput[]
    createMany?: PortfolioStandardsCreateManyStandardsInputEnvelope
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
  }

  export type EnumStandardsTypeFieldUpdateOperationsInput = {
    set?: $Enums.StandardsType
  }

  export type IndustryUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<IndustryCreateWithoutStandardsInput, IndustryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutStandardsInput
    upsert?: IndustryUpsertWithoutStandardsInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutStandardsInput, IndustryUpdateWithoutStandardsInput>, IndustryUncheckedUpdateWithoutStandardsInput>
  }

  export type PortfolioStandardsUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput> | PortfolioStandardsCreateWithoutStandardsInput[] | PortfolioStandardsUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutStandardsInput | PortfolioStandardsCreateOrConnectWithoutStandardsInput[]
    upsert?: PortfolioStandardsUpsertWithWhereUniqueWithoutStandardsInput | PortfolioStandardsUpsertWithWhereUniqueWithoutStandardsInput[]
    createMany?: PortfolioStandardsCreateManyStandardsInputEnvelope
    set?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    disconnect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    delete?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    update?: PortfolioStandardsUpdateWithWhereUniqueWithoutStandardsInput | PortfolioStandardsUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: PortfolioStandardsUpdateManyWithWhereWithoutStandardsInput | PortfolioStandardsUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
  }

  export type PortfolioStandardsUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput> | PortfolioStandardsCreateWithoutStandardsInput[] | PortfolioStandardsUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: PortfolioStandardsCreateOrConnectWithoutStandardsInput | PortfolioStandardsCreateOrConnectWithoutStandardsInput[]
    upsert?: PortfolioStandardsUpsertWithWhereUniqueWithoutStandardsInput | PortfolioStandardsUpsertWithWhereUniqueWithoutStandardsInput[]
    createMany?: PortfolioStandardsCreateManyStandardsInputEnvelope
    set?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    disconnect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    delete?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    connect?: PortfolioStandardsWhereUniqueInput | PortfolioStandardsWhereUniqueInput[]
    update?: PortfolioStandardsUpdateWithWhereUniqueWithoutStandardsInput | PortfolioStandardsUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: PortfolioStandardsUpdateManyWithWhereWithoutStandardsInput | PortfolioStandardsUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
  }

  export type IndustryCreateNestedOneWithoutSkillInput = {
    create?: XOR<IndustryCreateWithoutSkillInput, IndustryUncheckedCreateWithoutSkillInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSkillInput
    connect?: IndustryWhereUniqueInput
  }

  export type FreelanceCreateNestedOneWithoutSkillsInput = {
    create?: XOR<FreelanceCreateWithoutSkillsInput, FreelanceUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutSkillsInput
    connect?: FreelanceWhereUniqueInput
  }

  export type UserSkillsCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput> | UserSkillsCreateWithoutSkillInput[] | UserSkillsUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillInput | UserSkillsCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillsCreateManySkillInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type UserSkillsUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput> | UserSkillsCreateWithoutSkillInput[] | UserSkillsUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillInput | UserSkillsCreateOrConnectWithoutSkillInput[]
    createMany?: UserSkillsCreateManySkillInputEnvelope
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
  }

  export type IndustryUpdateOneRequiredWithoutSkillNestedInput = {
    create?: XOR<IndustryCreateWithoutSkillInput, IndustryUncheckedCreateWithoutSkillInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSkillInput
    upsert?: IndustryUpsertWithoutSkillInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutSkillInput, IndustryUpdateWithoutSkillInput>, IndustryUncheckedUpdateWithoutSkillInput>
  }

  export type FreelanceUpdateOneWithoutSkillsNestedInput = {
    create?: XOR<FreelanceCreateWithoutSkillsInput, FreelanceUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: FreelanceCreateOrConnectWithoutSkillsInput
    upsert?: FreelanceUpsertWithoutSkillsInput
    disconnect?: FreelanceWhereInput | boolean
    delete?: FreelanceWhereInput | boolean
    connect?: FreelanceWhereUniqueInput
    update?: XOR<XOR<FreelanceUpdateToOneWithWhereWithoutSkillsInput, FreelanceUpdateWithoutSkillsInput>, FreelanceUncheckedUpdateWithoutSkillsInput>
  }

  export type UserSkillsUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput> | UserSkillsCreateWithoutSkillInput[] | UserSkillsUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillInput | UserSkillsCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutSkillInput | UserSkillsUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillsCreateManySkillInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutSkillInput | UserSkillsUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutSkillInput | UserSkillsUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type UserSkillsUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput> | UserSkillsCreateWithoutSkillInput[] | UserSkillsUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: UserSkillsCreateOrConnectWithoutSkillInput | UserSkillsCreateOrConnectWithoutSkillInput[]
    upsert?: UserSkillsUpsertWithWhereUniqueWithoutSkillInput | UserSkillsUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: UserSkillsCreateManySkillInputEnvelope
    set?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    disconnect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    delete?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    connect?: UserSkillsWhereUniqueInput | UserSkillsWhereUniqueInput[]
    update?: UserSkillsUpdateWithWhereUniqueWithoutSkillInput | UserSkillsUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: UserSkillsUpdateManyWithWhereWithoutSkillInput | UserSkillsUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
  }

  export type PortfolioCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutCommentsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<PortfolioCommentCreateWithoutRepliesInput, PortfolioCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutRepliesInput
    connect?: PortfolioCommentWhereUniqueInput
  }

  export type PortfolioCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput> | PortfolioCommentCreateWithoutParentInput[] | PortfolioCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutParentInput | PortfolioCommentCreateOrConnectWithoutParentInput[]
    createMany?: PortfolioCommentCreateManyParentInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type PortfolioCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput> | PortfolioCommentCreateWithoutParentInput[] | PortfolioCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutParentInput | PortfolioCommentCreateOrConnectWithoutParentInput[]
    createMany?: PortfolioCommentCreateManyParentInputEnvelope
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
  }

  export type PortfolioUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutCommentsInput
    upsert?: PortfolioUpsertWithoutCommentsInput
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutCommentsInput, PortfolioUpdateWithoutCommentsInput>, PortfolioUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type PortfolioCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutRepliesInput, PortfolioCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutRepliesInput
    upsert?: PortfolioCommentUpsertWithoutRepliesInput
    disconnect?: PortfolioCommentWhereInput | boolean
    delete?: PortfolioCommentWhereInput | boolean
    connect?: PortfolioCommentWhereUniqueInput
    update?: XOR<XOR<PortfolioCommentUpdateToOneWithWhereWithoutRepliesInput, PortfolioCommentUpdateWithoutRepliesInput>, PortfolioCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type PortfolioCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput> | PortfolioCommentCreateWithoutParentInput[] | PortfolioCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutParentInput | PortfolioCommentCreateOrConnectWithoutParentInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutParentInput | PortfolioCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PortfolioCommentCreateManyParentInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutParentInput | PortfolioCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutParentInput | PortfolioCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput> | PortfolioCommentCreateWithoutParentInput[] | PortfolioCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PortfolioCommentCreateOrConnectWithoutParentInput | PortfolioCommentCreateOrConnectWithoutParentInput[]
    upsert?: PortfolioCommentUpsertWithWhereUniqueWithoutParentInput | PortfolioCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PortfolioCommentCreateManyParentInputEnvelope
    set?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    disconnect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    delete?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    connect?: PortfolioCommentWhereUniqueInput | PortfolioCommentWhereUniqueInput[]
    update?: PortfolioCommentUpdateWithWhereUniqueWithoutParentInput | PortfolioCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PortfolioCommentUpdateManyWithWhereWithoutParentInput | PortfolioCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableFilter<$PrismaModel> | $Enums.UserType | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumUserTypeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPortfolioImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PortfolioImageType | EnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPortfolioImageTypeFilter<$PrismaModel> | $Enums.PortfolioImageType
  }

  export type NestedEnumPortfolioImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortfolioImageType | EnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PortfolioImageType[] | ListEnumPortfolioImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPortfolioImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PortfolioImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortfolioImageTypeFilter<$PrismaModel>
    _max?: NestedEnumPortfolioImageTypeFilter<$PrismaModel>
  }

  export type NestedEnumFavoriteActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FavoriteAction | EnumFavoriteActionFieldRefInput<$PrismaModel>
    in?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFavoriteActionFilter<$PrismaModel> | $Enums.FavoriteAction
  }

  export type NestedEnumFavoriteActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FavoriteAction | EnumFavoriteActionFieldRefInput<$PrismaModel>
    in?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FavoriteAction[] | ListEnumFavoriteActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFavoriteActionWithAggregatesFilter<$PrismaModel> | $Enums.FavoriteAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFavoriteActionFilter<$PrismaModel>
    _max?: NestedEnumFavoriteActionFilter<$PrismaModel>
  }

  export type NestedEnumStandardsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardsType | EnumStandardsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardsTypeFilter<$PrismaModel> | $Enums.StandardsType
  }

  export type NestedEnumStandardsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardsType | EnumStandardsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardsType[] | ListEnumStandardsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardsTypeWithAggregatesFilter<$PrismaModel> | $Enums.StandardsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardsTypeFilter<$PrismaModel>
    _max?: NestedEnumStandardsTypeFilter<$PrismaModel>
  }

  export type UserIndustryCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutUsersInput
  }

  export type UserIndustryUncheckedCreateWithoutUserInput = {
    id?: string
    industryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIndustryCreateOrConnectWithoutUserInput = {
    where: UserIndustryWhereUniqueInput
    create: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput>
  }

  export type UserIndustryCreateManyUserInputEnvelope = {
    data: UserIndustryCreateManyUserInput | UserIndustryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTagsCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: TagCreateNestedOneWithoutUserTagsInput
  }

  export type UserTagsUncheckedCreateWithoutUserInput = {
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsCreateOrConnectWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsCreateManyUserInputEnvelope = {
    data: UserTagsCreateManyUserInput | UserTagsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserChannelsCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    channel: ChannelCreateNestedOneWithoutUserChannelsInput
  }

  export type UserChannelsUncheckedCreateWithoutUserInput = {
    channelSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsCreateOrConnectWithoutUserInput = {
    where: UserChannelsWhereUniqueInput
    create: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput>
  }

  export type UserChannelsCreateManyUserInputEnvelope = {
    data: UserChannelsCreateManyUserInput | UserChannelsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillsCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutUserSkillsInput
  }

  export type UserSkillsUncheckedCreateWithoutUserInput = {
    skillSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsCreateOrConnectWithoutUserInput = {
    where: UserSkillsWhereUniqueInput
    create: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput>
  }

  export type UserSkillsCreateManyUserInputEnvelope = {
    data: UserSkillsCreateManyUserInput | UserSkillsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceCreateWithoutUserInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryCreateNestedManyWithoutFreelanceInput
    skills?: SkillCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateWithoutUserInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput
    skills?: SkillUncheckedCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceCreateOrConnectWithoutUserInput = {
    where: FreelanceWhereUniqueInput
    create: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
  }

  export type CompanyCreateWithoutUserInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutFavoriteInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    portfolioId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutCommentsInput
    parent?: PortfolioCommentCreateNestedOneWithoutRepliesInput
    replies?: PortfolioCommentCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    portfolioId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: PortfolioCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentCreateOrConnectWithoutUserInput = {
    where: PortfolioCommentWhereUniqueInput
    create: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput>
  }

  export type PortfolioCommentCreateManyUserInputEnvelope = {
    data: PortfolioCommentCreateManyUserInput | PortfolioCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserIndustryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserIndustryWhereUniqueInput
    update: XOR<UserIndustryUpdateWithoutUserInput, UserIndustryUncheckedUpdateWithoutUserInput>
    create: XOR<UserIndustryCreateWithoutUserInput, UserIndustryUncheckedCreateWithoutUserInput>
  }

  export type UserIndustryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserIndustryWhereUniqueInput
    data: XOR<UserIndustryUpdateWithoutUserInput, UserIndustryUncheckedUpdateWithoutUserInput>
  }

  export type UserIndustryUpdateManyWithWhereWithoutUserInput = {
    where: UserIndustryScalarWhereInput
    data: XOR<UserIndustryUpdateManyMutationInput, UserIndustryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserIndustryScalarWhereInput = {
    AND?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
    OR?: UserIndustryScalarWhereInput[]
    NOT?: UserIndustryScalarWhereInput | UserIndustryScalarWhereInput[]
    id?: UuidFilter<"UserIndustry"> | string
    userId?: UuidFilter<"UserIndustry"> | string
    industryId?: UuidFilter<"UserIndustry"> | string
    createdAt?: DateTimeFilter<"UserIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"UserIndustry"> | Date | string
  }

  export type UserTagsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    update: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    data: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
  }

  export type UserTagsUpdateManyWithWhereWithoutUserInput = {
    where: UserTagsScalarWhereInput
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTagsScalarWhereInput = {
    AND?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    OR?: UserTagsScalarWhereInput[]
    NOT?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    userId?: UuidFilter<"UserTags"> | string
    tagSlug?: StringFilter<"UserTags"> | string
    createdAt?: DateTimeFilter<"UserTags"> | Date | string
    updatedAt?: DateTimeFilter<"UserTags"> | Date | string
  }

  export type UserChannelsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserChannelsWhereUniqueInput
    update: XOR<UserChannelsUpdateWithoutUserInput, UserChannelsUncheckedUpdateWithoutUserInput>
    create: XOR<UserChannelsCreateWithoutUserInput, UserChannelsUncheckedCreateWithoutUserInput>
  }

  export type UserChannelsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserChannelsWhereUniqueInput
    data: XOR<UserChannelsUpdateWithoutUserInput, UserChannelsUncheckedUpdateWithoutUserInput>
  }

  export type UserChannelsUpdateManyWithWhereWithoutUserInput = {
    where: UserChannelsScalarWhereInput
    data: XOR<UserChannelsUpdateManyMutationInput, UserChannelsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChannelsScalarWhereInput = {
    AND?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
    OR?: UserChannelsScalarWhereInput[]
    NOT?: UserChannelsScalarWhereInput | UserChannelsScalarWhereInput[]
    userId?: UuidFilter<"UserChannels"> | string
    channelSlug?: StringFilter<"UserChannels"> | string
    createdAt?: DateTimeFilter<"UserChannels"> | Date | string
    updatedAt?: DateTimeFilter<"UserChannels"> | Date | string
  }

  export type UserSkillsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSkillsWhereUniqueInput
    update: XOR<UserSkillsUpdateWithoutUserInput, UserSkillsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkillsCreateWithoutUserInput, UserSkillsUncheckedCreateWithoutUserInput>
  }

  export type UserSkillsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSkillsWhereUniqueInput
    data: XOR<UserSkillsUpdateWithoutUserInput, UserSkillsUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillsUpdateManyWithWhereWithoutUserInput = {
    where: UserSkillsScalarWhereInput
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSkillsScalarWhereInput = {
    AND?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
    OR?: UserSkillsScalarWhereInput[]
    NOT?: UserSkillsScalarWhereInput | UserSkillsScalarWhereInput[]
    userId?: UuidFilter<"UserSkills"> | string
    skillSlug?: StringFilter<"UserSkills"> | string
    createdAt?: DateTimeFilter<"UserSkills"> | Date | string
    updatedAt?: DateTimeFilter<"UserSkills"> | Date | string
  }

  export type FreelanceUpsertWithoutUserInput = {
    update: XOR<FreelanceUpdateWithoutUserInput, FreelanceUncheckedUpdateWithoutUserInput>
    create: XOR<FreelanceCreateWithoutUserInput, FreelanceUncheckedCreateWithoutUserInput>
    where?: FreelanceWhereInput
  }

  export type FreelanceUpdateToOneWithWhereWithoutUserInput = {
    where?: FreelanceWhereInput
    data: XOR<FreelanceUpdateWithoutUserInput, FreelanceUncheckedUpdateWithoutUserInput>
  }

  export type FreelanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUncheckedUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type CompanyUpsertWithoutUserInput = {
    update: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUserInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: UuidFilter<"Favorite"> | string
    portfolioId?: UuidFilter<"Favorite"> | string
    userId?: UuidFilter<"Favorite"> | string
    action?: EnumFavoriteActionFilter<"Favorite"> | $Enums.FavoriteAction
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    updatedAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type PortfolioCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: PortfolioCommentWhereUniqueInput
    update: XOR<PortfolioCommentUpdateWithoutUserInput, PortfolioCommentUncheckedUpdateWithoutUserInput>
    create: XOR<PortfolioCommentCreateWithoutUserInput, PortfolioCommentUncheckedCreateWithoutUserInput>
  }

  export type PortfolioCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: PortfolioCommentWhereUniqueInput
    data: XOR<PortfolioCommentUpdateWithoutUserInput, PortfolioCommentUncheckedUpdateWithoutUserInput>
  }

  export type PortfolioCommentUpdateManyWithWhereWithoutUserInput = {
    where: PortfolioCommentScalarWhereInput
    data: XOR<PortfolioCommentUpdateManyMutationInput, PortfolioCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type PortfolioCommentScalarWhereInput = {
    AND?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
    OR?: PortfolioCommentScalarWhereInput[]
    NOT?: PortfolioCommentScalarWhereInput | PortfolioCommentScalarWhereInput[]
    id?: UuidFilter<"PortfolioComment"> | string
    content?: StringFilter<"PortfolioComment"> | string
    portfolioId?: UuidFilter<"PortfolioComment"> | string
    userId?: UuidFilter<"PortfolioComment"> | string
    parentId?: UuidNullableFilter<"PortfolioComment"> | string | null
    createdAt?: DateTimeFilter<"PortfolioComment"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioComment"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: UuidFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: UuidFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type UserCreateWithoutIndustryTagsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIndustryTagsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIndustryTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndustryTagsInput, UserUncheckedCreateWithoutIndustryTagsInput>
  }

  export type TagCreateWithoutUserTagsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutTagInput
    PortfolioTag?: PortfolioTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutUserTagsInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioTag?: PortfolioTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutUserTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutUserTagsInput, TagUncheckedCreateWithoutUserTagsInput>
  }

  export type UserUpsertWithoutIndustryTagsInput = {
    update: XOR<UserUpdateWithoutIndustryTagsInput, UserUncheckedUpdateWithoutIndustryTagsInput>
    create: XOR<UserCreateWithoutIndustryTagsInput, UserUncheckedCreateWithoutIndustryTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndustryTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndustryTagsInput, UserUncheckedUpdateWithoutIndustryTagsInput>
  }

  export type UserUpdateWithoutIndustryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIndustryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TagUpsertWithoutUserTagsInput = {
    update: XOR<TagUpdateWithoutUserTagsInput, TagUncheckedUpdateWithoutUserTagsInput>
    create: XOR<TagCreateWithoutUserTagsInput, TagUncheckedCreateWithoutUserTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutUserTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutUserTagsInput, TagUncheckedUpdateWithoutUserTagsInput>
  }

  export type TagUpdateWithoutUserTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutTagNestedInput
    PortfolioTag?: PortfolioTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutUserTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioTag?: PortfolioTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type UserCreateWithoutIndustryChannelsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIndustryChannelsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIndustryChannelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndustryChannelsInput, UserUncheckedCreateWithoutIndustryChannelsInput>
  }

  export type ChannelCreateWithoutUserChannelsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutChannelInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutUserChannelsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutUserChannelsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutUserChannelsInput, ChannelUncheckedCreateWithoutUserChannelsInput>
  }

  export type UserUpsertWithoutIndustryChannelsInput = {
    update: XOR<UserUpdateWithoutIndustryChannelsInput, UserUncheckedUpdateWithoutIndustryChannelsInput>
    create: XOR<UserCreateWithoutIndustryChannelsInput, UserUncheckedCreateWithoutIndustryChannelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndustryChannelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndustryChannelsInput, UserUncheckedUpdateWithoutIndustryChannelsInput>
  }

  export type UserUpdateWithoutIndustryChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIndustryChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChannelUpsertWithoutUserChannelsInput = {
    update: XOR<ChannelUpdateWithoutUserChannelsInput, ChannelUncheckedUpdateWithoutUserChannelsInput>
    create: XOR<ChannelCreateWithoutUserChannelsInput, ChannelUncheckedCreateWithoutUserChannelsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutUserChannelsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutUserChannelsInput, ChannelUncheckedUpdateWithoutUserChannelsInput>
  }

  export type ChannelUpdateWithoutUserChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutChannelNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutUserChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserCreateWithoutIndustrySkillsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIndustrySkillsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIndustrySkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndustrySkillsInput, UserUncheckedCreateWithoutIndustrySkillsInput>
  }

  export type SkillCreateWithoutUserSkillsInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSkillInput
    Freelance?: FreelanceCreateNestedOneWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutUserSkillsInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelanceId?: string | null
  }

  export type SkillCreateOrConnectWithoutUserSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
  }

  export type UserUpsertWithoutIndustrySkillsInput = {
    update: XOR<UserUpdateWithoutIndustrySkillsInput, UserUncheckedUpdateWithoutIndustrySkillsInput>
    create: XOR<UserCreateWithoutIndustrySkillsInput, UserUncheckedCreateWithoutIndustrySkillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndustrySkillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndustrySkillsInput, UserUncheckedUpdateWithoutIndustrySkillsInput>
  }

  export type UserUpdateWithoutIndustrySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIndustrySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SkillUpsertWithoutUserSkillsInput = {
    update: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
    create: XOR<SkillCreateWithoutUserSkillsInput, SkillUncheckedCreateWithoutUserSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutUserSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutUserSkillsInput, SkillUncheckedUpdateWithoutUserSkillsInput>
  }

  export type SkillUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSkillNestedInput
    Freelance?: FreelanceUpdateOneWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutUserSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutIndustriesRelatedInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIndustriesRelatedInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIndustriesRelatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndustriesRelatedInput, UserUncheckedCreateWithoutIndustriesRelatedInput>
  }

  export type IndustryCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutUsersInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutUsersInput, IndustryUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutIndustriesRelatedInput = {
    update: XOR<UserUpdateWithoutIndustriesRelatedInput, UserUncheckedUpdateWithoutIndustriesRelatedInput>
    create: XOR<UserCreateWithoutIndustriesRelatedInput, UserUncheckedCreateWithoutIndustriesRelatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndustriesRelatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndustriesRelatedInput, UserUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type UserUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IndustryUpsertWithoutUsersInput = {
    update: XOR<IndustryUpdateWithoutUsersInput, IndustryUncheckedUpdateWithoutUsersInput>
    create: XOR<IndustryCreateWithoutUsersInput, IndustryUncheckedCreateWithoutUsersInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutUsersInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutUsersInput, IndustryUncheckedUpdateWithoutUsersInput>
  }

  export type IndustryUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutCompanyRevenueInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    user: UserCreateNestedOneWithoutCompanyInput
    industriesRelated?: CompanyIndustryCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanyRevenueInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanyRevenueInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyRevenueInput, CompanyUncheckedCreateWithoutCompanyRevenueInput>
  }

  export type CompanyUpsertWithoutCompanyRevenueInput = {
    update: XOR<CompanyUpdateWithoutCompanyRevenueInput, CompanyUncheckedUpdateWithoutCompanyRevenueInput>
    create: XOR<CompanyCreateWithoutCompanyRevenueInput, CompanyUncheckedCreateWithoutCompanyRevenueInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyRevenueInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyRevenueInput, CompanyUncheckedUpdateWithoutCompanyRevenueInput>
  }

  export type CompanyUpdateWithoutCompanyRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    user?: UserUpdateOneRequiredWithoutCompanyNestedInput
    industriesRelated?: CompanyIndustryUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanyRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FreelanceCreateWithoutFreelanceRevenueInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryCreateNestedManyWithoutFreelanceInput
    skills?: SkillCreateNestedManyWithoutFreelanceInput
    user: UserCreateNestedOneWithoutFreelanceInput
    Portfolio?: PortfolioCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateWithoutFreelanceRevenueInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    industriesRelated?: FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput
    skills?: SkillUncheckedCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceCreateOrConnectWithoutFreelanceRevenueInput = {
    where: FreelanceWhereUniqueInput
    create: XOR<FreelanceCreateWithoutFreelanceRevenueInput, FreelanceUncheckedCreateWithoutFreelanceRevenueInput>
  }

  export type FreelanceUpsertWithoutFreelanceRevenueInput = {
    update: XOR<FreelanceUpdateWithoutFreelanceRevenueInput, FreelanceUncheckedUpdateWithoutFreelanceRevenueInput>
    create: XOR<FreelanceCreateWithoutFreelanceRevenueInput, FreelanceUncheckedCreateWithoutFreelanceRevenueInput>
    where?: FreelanceWhereInput
  }

  export type FreelanceUpdateToOneWithWhereWithoutFreelanceRevenueInput = {
    where?: FreelanceWhereInput
    data: XOR<FreelanceUpdateWithoutFreelanceRevenueInput, FreelanceUncheckedUpdateWithoutFreelanceRevenueInput>
  }

  export type FreelanceUpdateWithoutFreelanceRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUpdateManyWithoutFreelanceNestedInput
    user?: UserUpdateOneRequiredWithoutFreelanceNestedInput
    Portfolio?: PortfolioUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateWithoutFreelanceRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    industriesRelated?: FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUncheckedUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type IndustryCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutRevenueStreamInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutRevenueStreamInput, IndustryUncheckedCreateWithoutRevenueStreamInput>
  }

  export type CategoryCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type CategoryCreateOrConnectWithoutRevenueStreamInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRevenueStreamInput, CategoryUncheckedCreateWithoutRevenueStreamInput>
  }

  export type SourceCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSourceInput
  }

  export type SourceUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type SourceCreateOrConnectWithoutRevenueStreamInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutRevenueStreamInput, SourceUncheckedCreateWithoutRevenueStreamInput>
  }

  export type ChannelCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutChannelInput
    UserChannels?: UserChannelsCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
    UserChannels?: UserChannelsUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutRevenueStreamInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutRevenueStreamInput, ChannelUncheckedCreateWithoutRevenueStreamInput>
  }

  export type SegmentCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSegmentInput
  }

  export type SegmentUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industrySlug: string
  }

  export type SegmentCreateOrConnectWithoutRevenueStreamInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutRevenueStreamInput, SegmentUncheckedCreateWithoutRevenueStreamInput>
  }

  export type CompanyCreateWithoutRevenueStreamInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    user: UserCreateNestedOneWithoutCompanyInput
    industriesRelated?: CompanyIndustryCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRevenueStreamInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRevenueStreamInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRevenueStreamInput, CompanyUncheckedCreateWithoutRevenueStreamInput>
  }

  export type IndustryUpsertWithoutRevenueStreamInput = {
    update: XOR<IndustryUpdateWithoutRevenueStreamInput, IndustryUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<IndustryCreateWithoutRevenueStreamInput, IndustryUncheckedCreateWithoutRevenueStreamInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutRevenueStreamInput, IndustryUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type IndustryUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type CategoryUpsertWithoutRevenueStreamInput = {
    update: XOR<CategoryUpdateWithoutRevenueStreamInput, CategoryUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<CategoryCreateWithoutRevenueStreamInput, CategoryUncheckedCreateWithoutRevenueStreamInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutRevenueStreamInput, CategoryUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type CategoryUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUpsertWithoutRevenueStreamInput = {
    update: XOR<SourceUpdateWithoutRevenueStreamInput, SourceUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<SourceCreateWithoutRevenueStreamInput, SourceUncheckedCreateWithoutRevenueStreamInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutRevenueStreamInput, SourceUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type SourceUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type ChannelUpsertWithoutRevenueStreamInput = {
    update: XOR<ChannelUpdateWithoutRevenueStreamInput, ChannelUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<ChannelCreateWithoutRevenueStreamInput, ChannelUncheckedCreateWithoutRevenueStreamInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutRevenueStreamInput, ChannelUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type ChannelUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutChannelNestedInput
    UserChannels?: UserChannelsUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    UserChannels?: UserChannelsUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type SegmentUpsertWithoutRevenueStreamInput = {
    update: XOR<SegmentUpdateWithoutRevenueStreamInput, SegmentUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<SegmentCreateWithoutRevenueStreamInput, SegmentUncheckedCreateWithoutRevenueStreamInput>
    where?: SegmentWhereInput
  }

  export type SegmentUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: SegmentWhereInput
    data: XOR<SegmentUpdateWithoutRevenueStreamInput, SegmentUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type SegmentUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSegmentNestedInput
  }

  export type SegmentUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industrySlug?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUpsertWithoutRevenueStreamInput = {
    update: XOR<CompanyUpdateWithoutRevenueStreamInput, CompanyUncheckedUpdateWithoutRevenueStreamInput>
    create: XOR<CompanyCreateWithoutRevenueStreamInput, CompanyUncheckedCreateWithoutRevenueStreamInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRevenueStreamInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRevenueStreamInput, CompanyUncheckedUpdateWithoutRevenueStreamInput>
  }

  export type CompanyUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    user?: UserUpdateOneRequiredWithoutCompanyNestedInput
    industriesRelated?: CompanyIndustryUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRevenueStreamInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyIndustryCreateWithoutCompanyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyIndustryUncheckedCreateWithoutCompanyInput = {
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryCreateOrConnectWithoutCompanyInput = {
    where: CompanyIndustryWhereUniqueInput
    create: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyIndustryCreateManyCompanyInputEnvelope = {
    data: CompanyIndustryCreateManyCompanyInput | CompanyIndustryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyRevenueCreateWithoutCompanyInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRevenueUncheckedCreateWithoutCompanyInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRevenueCreateOrConnectWithoutCompanyInput = {
    where: CompanyRevenueWhereUniqueInput
    create: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyRevenueCreateManyCompanyInputEnvelope = {
    data: CompanyRevenueCreateManyCompanyInput | CompanyRevenueCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type RevenueStreamCreateWithoutCompanyInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutCompanyInput = {
    id?: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutCompanyInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput>
  }

  export type RevenueStreamCreateManyCompanyInputEnvelope = {
    data: RevenueStreamCreateManyCompanyInput | RevenueStreamCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCreateWithoutCompanyInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutCompanyInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput>
  }

  export type PortfolioCreateManyCompanyInputEnvelope = {
    data: PortfolioCreateManyCompanyInput | PortfolioCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCompanyInput = {
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompanyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyIndustryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyIndustryWhereUniqueInput
    update: XOR<CompanyIndustryUpdateWithoutCompanyInput, CompanyIndustryUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyIndustryCreateWithoutCompanyInput, CompanyIndustryUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyIndustryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyIndustryWhereUniqueInput
    data: XOR<CompanyIndustryUpdateWithoutCompanyInput, CompanyIndustryUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyIndustryUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyIndustryScalarWhereInput
    data: XOR<CompanyIndustryUpdateManyMutationInput, CompanyIndustryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyIndustryScalarWhereInput = {
    AND?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
    OR?: CompanyIndustryScalarWhereInput[]
    NOT?: CompanyIndustryScalarWhereInput | CompanyIndustryScalarWhereInput[]
    companyId?: UuidFilter<"CompanyIndustry"> | string
    industrySlug?: StringFilter<"CompanyIndustry"> | string
    createdAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyIndustry"> | Date | string
  }

  export type CompanyRevenueUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyRevenueWhereUniqueInput
    update: XOR<CompanyRevenueUpdateWithoutCompanyInput, CompanyRevenueUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyRevenueCreateWithoutCompanyInput, CompanyRevenueUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyRevenueUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyRevenueWhereUniqueInput
    data: XOR<CompanyRevenueUpdateWithoutCompanyInput, CompanyRevenueUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyRevenueUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyRevenueScalarWhereInput
    data: XOR<CompanyRevenueUpdateManyMutationInput, CompanyRevenueUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyRevenueScalarWhereInput = {
    AND?: CompanyRevenueScalarWhereInput | CompanyRevenueScalarWhereInput[]
    OR?: CompanyRevenueScalarWhereInput[]
    NOT?: CompanyRevenueScalarWhereInput | CompanyRevenueScalarWhereInput[]
    id?: UuidFilter<"CompanyRevenue"> | string
    year?: IntFilter<"CompanyRevenue"> | number
    total?: FloatFilter<"CompanyRevenue"> | number
    companyId?: UuidFilter<"CompanyRevenue"> | string
    createdAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyRevenue"> | Date | string
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutCompanyInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutCompanyInput, RevenueStreamUncheckedUpdateWithoutCompanyInput>
    create: XOR<RevenueStreamCreateWithoutCompanyInput, RevenueStreamUncheckedCreateWithoutCompanyInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutCompanyInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutCompanyInput, RevenueStreamUncheckedUpdateWithoutCompanyInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutCompanyInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutCompanyInput>
  }

  export type RevenueStreamScalarWhereInput = {
    AND?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
    OR?: RevenueStreamScalarWhereInput[]
    NOT?: RevenueStreamScalarWhereInput | RevenueStreamScalarWhereInput[]
    id?: UuidFilter<"RevenueStream"> | string
    year?: IntFilter<"RevenueStream"> | number
    industryTypeSlug?: StringFilter<"RevenueStream"> | string
    categorySlug?: StringFilter<"RevenueStream"> | string
    sourceSlug?: StringFilter<"RevenueStream"> | string
    channelSlug?: StringFilter<"RevenueStream"> | string
    segmentSlug?: StringFilter<"RevenueStream"> | string
    percent?: FloatFilter<"RevenueStream"> | number
    ctrPercent?: FloatFilter<"RevenueStream"> | number
    value?: FloatNullableFilter<"RevenueStream"> | number | null
    companyId?: UuidFilter<"RevenueStream"> | string
    companyJuristicId?: StringFilter<"RevenueStream"> | string
    createdAt?: DateTimeFilter<"RevenueStream"> | Date | string
    updatedAt?: DateTimeFilter<"RevenueStream"> | Date | string
  }

  export type PortfolioUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutCompanyInput, PortfolioUncheckedUpdateWithoutCompanyInput>
    create: XOR<PortfolioCreateWithoutCompanyInput, PortfolioUncheckedCreateWithoutCompanyInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutCompanyInput, PortfolioUncheckedUpdateWithoutCompanyInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutCompanyInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: UuidFilter<"Portfolio"> | string
    title?: StringFilter<"Portfolio"> | string
    title_en?: StringNullableFilter<"Portfolio"> | string | null
    description?: StringNullableFilter<"Portfolio"> | string | null
    description_en?: StringNullableFilter<"Portfolio"> | string | null
    cover_image?: StringNullableFilter<"Portfolio"> | string | null
    link?: StringNullableFilter<"Portfolio"> | string | null
    industryTypeSlug?: StringFilter<"Portfolio"> | string
    tags?: StringNullableListFilter<"Portfolio">
    looking_for?: StringNullableListFilter<"Portfolio">
    freelanceId?: UuidNullableFilter<"Portfolio"> | string | null
    companyId?: UuidNullableFilter<"Portfolio"> | string | null
    companyJuristicId?: StringNullableFilter<"Portfolio"> | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
  }

  export type CompanyCreateWithoutIndustriesRelatedInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    user: UserCreateNestedOneWithoutCompanyInput
    companyRevenue?: CompanyRevenueCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutIndustriesRelatedInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    companyRevenue?: CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutIndustriesRelatedInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutIndustriesRelatedInput, CompanyUncheckedCreateWithoutIndustriesRelatedInput>
  }

  export type IndustryCreateWithoutCompaniesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutCompaniesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutCompaniesInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutCompaniesInput, IndustryUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutIndustriesRelatedInput = {
    update: XOR<CompanyUpdateWithoutIndustriesRelatedInput, CompanyUncheckedUpdateWithoutIndustriesRelatedInput>
    create: XOR<CompanyCreateWithoutIndustriesRelatedInput, CompanyUncheckedCreateWithoutIndustriesRelatedInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutIndustriesRelatedInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutIndustriesRelatedInput, CompanyUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type CompanyUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    user?: UserUpdateOneRequiredWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    companyRevenue?: CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type IndustryUpsertWithoutCompaniesInput = {
    update: XOR<IndustryUpdateWithoutCompaniesInput, IndustryUncheckedUpdateWithoutCompaniesInput>
    create: XOR<IndustryCreateWithoutCompaniesInput, IndustryUncheckedCreateWithoutCompaniesInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutCompaniesInput, IndustryUncheckedUpdateWithoutCompaniesInput>
  }

  export type IndustryUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type FreelanceIndustryCreateWithoutFreelanceInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutFreelancersInput
  }

  export type FreelanceIndustryUncheckedCreateWithoutFreelanceInput = {
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryCreateOrConnectWithoutFreelanceInput = {
    where: FreelanceIndustryWhereUniqueInput
    create: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput>
  }

  export type FreelanceIndustryCreateManyFreelanceInputEnvelope = {
    data: FreelanceIndustryCreateManyFreelanceInput | FreelanceIndustryCreateManyFreelanceInput[]
    skipDuplicates?: boolean
  }

  export type SkillCreateWithoutFreelanceInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutSkillInput
    UserSkills?: UserSkillsCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutFreelanceInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSkills?: UserSkillsUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutFreelanceInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput>
  }

  export type SkillCreateManyFreelanceInputEnvelope = {
    data: SkillCreateManyFreelanceInput | SkillCreateManyFreelanceInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceRevenueCreateWithoutFreelanceInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceRevenueUncheckedCreateWithoutFreelanceInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceRevenueCreateOrConnectWithoutFreelanceInput = {
    where: FreelanceRevenueWhereUniqueInput
    create: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput>
  }

  export type FreelanceRevenueCreateManyFreelanceInputEnvelope = {
    data: FreelanceRevenueCreateManyFreelanceInput | FreelanceRevenueCreateManyFreelanceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFreelanceInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFreelanceInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFreelanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFreelanceInput, UserUncheckedCreateWithoutFreelanceInput>
  }

  export type PortfolioCreateWithoutFreelanceInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutFreelanceInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutFreelanceInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput>
  }

  export type PortfolioCreateManyFreelanceInputEnvelope = {
    data: PortfolioCreateManyFreelanceInput | PortfolioCreateManyFreelanceInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceIndustryUpsertWithWhereUniqueWithoutFreelanceInput = {
    where: FreelanceIndustryWhereUniqueInput
    update: XOR<FreelanceIndustryUpdateWithoutFreelanceInput, FreelanceIndustryUncheckedUpdateWithoutFreelanceInput>
    create: XOR<FreelanceIndustryCreateWithoutFreelanceInput, FreelanceIndustryUncheckedCreateWithoutFreelanceInput>
  }

  export type FreelanceIndustryUpdateWithWhereUniqueWithoutFreelanceInput = {
    where: FreelanceIndustryWhereUniqueInput
    data: XOR<FreelanceIndustryUpdateWithoutFreelanceInput, FreelanceIndustryUncheckedUpdateWithoutFreelanceInput>
  }

  export type FreelanceIndustryUpdateManyWithWhereWithoutFreelanceInput = {
    where: FreelanceIndustryScalarWhereInput
    data: XOR<FreelanceIndustryUpdateManyMutationInput, FreelanceIndustryUncheckedUpdateManyWithoutFreelanceInput>
  }

  export type FreelanceIndustryScalarWhereInput = {
    AND?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
    OR?: FreelanceIndustryScalarWhereInput[]
    NOT?: FreelanceIndustryScalarWhereInput | FreelanceIndustryScalarWhereInput[]
    freelanceId?: UuidFilter<"FreelanceIndustry"> | string
    industrySlug?: StringFilter<"FreelanceIndustry"> | string
    createdAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceIndustry"> | Date | string
  }

  export type SkillUpsertWithWhereUniqueWithoutFreelanceInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutFreelanceInput, SkillUncheckedUpdateWithoutFreelanceInput>
    create: XOR<SkillCreateWithoutFreelanceInput, SkillUncheckedCreateWithoutFreelanceInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutFreelanceInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutFreelanceInput, SkillUncheckedUpdateWithoutFreelanceInput>
  }

  export type SkillUpdateManyWithWhereWithoutFreelanceInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutFreelanceInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: UuidFilter<"Skill"> | string
    title?: StringFilter<"Skill"> | string
    slug?: StringFilter<"Skill"> | string
    group?: StringNullableFilter<"Skill"> | string | null
    industrySlug?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    freelanceId?: UuidNullableFilter<"Skill"> | string | null
  }

  export type FreelanceRevenueUpsertWithWhereUniqueWithoutFreelanceInput = {
    where: FreelanceRevenueWhereUniqueInput
    update: XOR<FreelanceRevenueUpdateWithoutFreelanceInput, FreelanceRevenueUncheckedUpdateWithoutFreelanceInput>
    create: XOR<FreelanceRevenueCreateWithoutFreelanceInput, FreelanceRevenueUncheckedCreateWithoutFreelanceInput>
  }

  export type FreelanceRevenueUpdateWithWhereUniqueWithoutFreelanceInput = {
    where: FreelanceRevenueWhereUniqueInput
    data: XOR<FreelanceRevenueUpdateWithoutFreelanceInput, FreelanceRevenueUncheckedUpdateWithoutFreelanceInput>
  }

  export type FreelanceRevenueUpdateManyWithWhereWithoutFreelanceInput = {
    where: FreelanceRevenueScalarWhereInput
    data: XOR<FreelanceRevenueUpdateManyMutationInput, FreelanceRevenueUncheckedUpdateManyWithoutFreelanceInput>
  }

  export type FreelanceRevenueScalarWhereInput = {
    AND?: FreelanceRevenueScalarWhereInput | FreelanceRevenueScalarWhereInput[]
    OR?: FreelanceRevenueScalarWhereInput[]
    NOT?: FreelanceRevenueScalarWhereInput | FreelanceRevenueScalarWhereInput[]
    id?: UuidFilter<"FreelanceRevenue"> | string
    year?: IntFilter<"FreelanceRevenue"> | number
    total?: FloatFilter<"FreelanceRevenue"> | number
    freelanceId?: UuidFilter<"FreelanceRevenue"> | string
    createdAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceRevenue"> | Date | string
  }

  export type UserUpsertWithoutFreelanceInput = {
    update: XOR<UserUpdateWithoutFreelanceInput, UserUncheckedUpdateWithoutFreelanceInput>
    create: XOR<UserCreateWithoutFreelanceInput, UserUncheckedCreateWithoutFreelanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFreelanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFreelanceInput, UserUncheckedUpdateWithoutFreelanceInput>
  }

  export type UserUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortfolioUpsertWithWhereUniqueWithoutFreelanceInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutFreelanceInput, PortfolioUncheckedUpdateWithoutFreelanceInput>
    create: XOR<PortfolioCreateWithoutFreelanceInput, PortfolioUncheckedCreateWithoutFreelanceInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutFreelanceInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutFreelanceInput, PortfolioUncheckedUpdateWithoutFreelanceInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutFreelanceInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutFreelanceInput>
  }

  export type FreelanceCreateWithoutIndustriesRelatedInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: SkillCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueCreateNestedManyWithoutFreelanceInput
    user: UserCreateNestedOneWithoutFreelanceInput
    Portfolio?: PortfolioCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateWithoutIndustriesRelatedInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    skills?: SkillUncheckedCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceCreateOrConnectWithoutIndustriesRelatedInput = {
    where: FreelanceWhereUniqueInput
    create: XOR<FreelanceCreateWithoutIndustriesRelatedInput, FreelanceUncheckedCreateWithoutIndustriesRelatedInput>
  }

  export type IndustryCreateWithoutFreelancersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutFreelancersInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutFreelancersInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutFreelancersInput, IndustryUncheckedCreateWithoutFreelancersInput>
  }

  export type FreelanceUpsertWithoutIndustriesRelatedInput = {
    update: XOR<FreelanceUpdateWithoutIndustriesRelatedInput, FreelanceUncheckedUpdateWithoutIndustriesRelatedInput>
    create: XOR<FreelanceCreateWithoutIndustriesRelatedInput, FreelanceUncheckedCreateWithoutIndustriesRelatedInput>
    where?: FreelanceWhereInput
  }

  export type FreelanceUpdateToOneWithWhereWithoutIndustriesRelatedInput = {
    where?: FreelanceWhereInput
    data: XOR<FreelanceUpdateWithoutIndustriesRelatedInput, FreelanceUncheckedUpdateWithoutIndustriesRelatedInput>
  }

  export type FreelanceUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: SkillUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUpdateManyWithoutFreelanceNestedInput
    user?: UserUpdateOneRequiredWithoutFreelanceNestedInput
    Portfolio?: PortfolioUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateWithoutIndustriesRelatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type IndustryUpsertWithoutFreelancersInput = {
    update: XOR<IndustryUpdateWithoutFreelancersInput, IndustryUncheckedUpdateWithoutFreelancersInput>
    create: XOR<IndustryCreateWithoutFreelancersInput, IndustryUncheckedCreateWithoutFreelancersInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutFreelancersInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutFreelancersInput, IndustryUncheckedUpdateWithoutFreelancersInput>
  }

  export type IndustryUpdateWithoutFreelancersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutFreelancersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type SkillCreateWithoutIndustryInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Freelance?: FreelanceCreateNestedOneWithoutSkillsInput
    UserSkills?: UserSkillsCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutIndustryInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    freelanceId?: string | null
    UserSkills?: UserSkillsUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutIndustryInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput>
  }

  export type SkillCreateManyIndustryInputEnvelope = {
    data: SkillCreateManyIndustryInput | SkillCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type SourceCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamCreateNestedManyWithoutSourceInput
  }

  export type SourceUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutSourceInput
  }

  export type SourceCreateOrConnectWithoutIndustryInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput>
  }

  export type SourceCreateManyIndustryInputEnvelope = {
    data: SourceCreateManyIndustryInput | SourceCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamCreateNestedManyWithoutChannelInput
    UserChannels?: UserChannelsCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutChannelInput
    UserChannels?: UserChannelsUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutIndustryInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput>
  }

  export type ChannelCreateManyIndustryInputEnvelope = {
    data: ChannelCreateManyIndustryInput | ChannelCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type SegmentCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamCreateNestedManyWithoutSegmentInput
  }

  export type SegmentUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentCreateOrConnectWithoutIndustryInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput>
  }

  export type SegmentCreateManyIndustryInputEnvelope = {
    data: SegmentCreateManyIndustryInput | SegmentCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutIndustryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput>
  }

  export type CategoryCreateManyIndustryInputEnvelope = {
    data: CategoryCreateManyIndustryInput | CategoryCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyIndustryCreateWithoutIndustryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutIndustriesRelatedInput
  }

  export type CompanyIndustryUncheckedCreateWithoutIndustryInput = {
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryCreateOrConnectWithoutIndustryInput = {
    where: CompanyIndustryWhereUniqueInput
    create: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type CompanyIndustryCreateManyIndustryInputEnvelope = {
    data: CompanyIndustryCreateManyIndustryInput | CompanyIndustryCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceIndustryCreateWithoutIndustryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    freelance: FreelanceCreateNestedOneWithoutIndustriesRelatedInput
  }

  export type FreelanceIndustryUncheckedCreateWithoutIndustryInput = {
    freelanceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryCreateOrConnectWithoutIndustryInput = {
    where: FreelanceIndustryWhereUniqueInput
    create: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type FreelanceIndustryCreateManyIndustryInputEnvelope = {
    data: FreelanceIndustryCreateManyIndustryInput | FreelanceIndustryCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type UserIndustryCreateWithoutIndustryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustriesRelatedInput
  }

  export type UserIndustryUncheckedCreateWithoutIndustryInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIndustryCreateOrConnectWithoutIndustryInput = {
    where: UserIndustryWhereUniqueInput
    create: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type UserIndustryCreateManyIndustryInputEnvelope = {
    data: UserIndustryCreateManyIndustryInput | UserIndustryCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type StandardsCreateWithoutIndustryInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioStandards?: PortfolioStandardsCreateNestedManyWithoutStandardsInput
  }

  export type StandardsUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioStandards?: PortfolioStandardsUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardsCreateOrConnectWithoutIndustryInput = {
    where: StandardsWhereUniqueInput
    create: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput>
  }

  export type StandardsCreateManyIndustryInputEnvelope = {
    data: StandardsCreateManyIndustryInput | StandardsCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type RevenueStreamCreateWithoutIndustryInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutIndustryInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutIndustryInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput>
  }

  export type RevenueStreamCreateManyIndustryInputEnvelope = {
    data: RevenueStreamCreateManyIndustryInput | RevenueStreamCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioTag?: PortfolioTagCreateNestedManyWithoutTagInput
    UserTags?: UserTagsCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioTag?: PortfolioTagUncheckedCreateNestedManyWithoutTagInput
    UserTags?: UserTagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutIndustryInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput>
  }

  export type TagCreateManyIndustryInputEnvelope = {
    data: TagCreateManyIndustryInput | TagCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type LookingForCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioLookingFor?: PortfolioLookingForCreateNestedManyWithoutLookingForInput
  }

  export type LookingForUncheckedCreateWithoutIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    PortfolioLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutLookingForInput
  }

  export type LookingForCreateOrConnectWithoutIndustryInput = {
    where: LookingForWhereUniqueInput
    create: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput>
  }

  export type LookingForCreateManyIndustryInputEnvelope = {
    data: LookingForCreateManyIndustryInput | LookingForCreateManyIndustryInput[]
    skipDuplicates?: boolean
  }

  export type SkillUpsertWithWhereUniqueWithoutIndustryInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutIndustryInput, SkillUncheckedUpdateWithoutIndustryInput>
    create: XOR<SkillCreateWithoutIndustryInput, SkillUncheckedCreateWithoutIndustryInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutIndustryInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutIndustryInput, SkillUncheckedUpdateWithoutIndustryInput>
  }

  export type SkillUpdateManyWithWhereWithoutIndustryInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutIndustryInput>
  }

  export type SourceUpsertWithWhereUniqueWithoutIndustryInput = {
    where: SourceWhereUniqueInput
    update: XOR<SourceUpdateWithoutIndustryInput, SourceUncheckedUpdateWithoutIndustryInput>
    create: XOR<SourceCreateWithoutIndustryInput, SourceUncheckedCreateWithoutIndustryInput>
  }

  export type SourceUpdateWithWhereUniqueWithoutIndustryInput = {
    where: SourceWhereUniqueInput
    data: XOR<SourceUpdateWithoutIndustryInput, SourceUncheckedUpdateWithoutIndustryInput>
  }

  export type SourceUpdateManyWithWhereWithoutIndustryInput = {
    where: SourceScalarWhereInput
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyWithoutIndustryInput>
  }

  export type SourceScalarWhereInput = {
    AND?: SourceScalarWhereInput | SourceScalarWhereInput[]
    OR?: SourceScalarWhereInput[]
    NOT?: SourceScalarWhereInput | SourceScalarWhereInput[]
    id?: UuidFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    slug?: StringFilter<"Source"> | string
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
    industrySlug?: StringFilter<"Source"> | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutIndustryInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutIndustryInput, ChannelUncheckedUpdateWithoutIndustryInput>
    create: XOR<ChannelCreateWithoutIndustryInput, ChannelUncheckedCreateWithoutIndustryInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutIndustryInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutIndustryInput, ChannelUncheckedUpdateWithoutIndustryInput>
  }

  export type ChannelUpdateManyWithWhereWithoutIndustryInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutIndustryInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: UuidFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    slug?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    industrySlug?: StringFilter<"Channel"> | string
  }

  export type SegmentUpsertWithWhereUniqueWithoutIndustryInput = {
    where: SegmentWhereUniqueInput
    update: XOR<SegmentUpdateWithoutIndustryInput, SegmentUncheckedUpdateWithoutIndustryInput>
    create: XOR<SegmentCreateWithoutIndustryInput, SegmentUncheckedCreateWithoutIndustryInput>
  }

  export type SegmentUpdateWithWhereUniqueWithoutIndustryInput = {
    where: SegmentWhereUniqueInput
    data: XOR<SegmentUpdateWithoutIndustryInput, SegmentUncheckedUpdateWithoutIndustryInput>
  }

  export type SegmentUpdateManyWithWhereWithoutIndustryInput = {
    where: SegmentScalarWhereInput
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyWithoutIndustryInput>
  }

  export type SegmentScalarWhereInput = {
    AND?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    OR?: SegmentScalarWhereInput[]
    NOT?: SegmentScalarWhereInput | SegmentScalarWhereInput[]
    id?: UuidFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    slug?: StringFilter<"Segment"> | string
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    industrySlug?: StringFilter<"Segment"> | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutIndustryInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutIndustryInput, CategoryUncheckedUpdateWithoutIndustryInput>
    create: XOR<CategoryCreateWithoutIndustryInput, CategoryUncheckedCreateWithoutIndustryInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutIndustryInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutIndustryInput, CategoryUncheckedUpdateWithoutIndustryInput>
  }

  export type CategoryUpdateManyWithWhereWithoutIndustryInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutIndustryInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: UuidFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    industrySlug?: StringFilter<"Category"> | string
  }

  export type CompanyIndustryUpsertWithWhereUniqueWithoutIndustryInput = {
    where: CompanyIndustryWhereUniqueInput
    update: XOR<CompanyIndustryUpdateWithoutIndustryInput, CompanyIndustryUncheckedUpdateWithoutIndustryInput>
    create: XOR<CompanyIndustryCreateWithoutIndustryInput, CompanyIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type CompanyIndustryUpdateWithWhereUniqueWithoutIndustryInput = {
    where: CompanyIndustryWhereUniqueInput
    data: XOR<CompanyIndustryUpdateWithoutIndustryInput, CompanyIndustryUncheckedUpdateWithoutIndustryInput>
  }

  export type CompanyIndustryUpdateManyWithWhereWithoutIndustryInput = {
    where: CompanyIndustryScalarWhereInput
    data: XOR<CompanyIndustryUpdateManyMutationInput, CompanyIndustryUncheckedUpdateManyWithoutIndustryInput>
  }

  export type FreelanceIndustryUpsertWithWhereUniqueWithoutIndustryInput = {
    where: FreelanceIndustryWhereUniqueInput
    update: XOR<FreelanceIndustryUpdateWithoutIndustryInput, FreelanceIndustryUncheckedUpdateWithoutIndustryInput>
    create: XOR<FreelanceIndustryCreateWithoutIndustryInput, FreelanceIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type FreelanceIndustryUpdateWithWhereUniqueWithoutIndustryInput = {
    where: FreelanceIndustryWhereUniqueInput
    data: XOR<FreelanceIndustryUpdateWithoutIndustryInput, FreelanceIndustryUncheckedUpdateWithoutIndustryInput>
  }

  export type FreelanceIndustryUpdateManyWithWhereWithoutIndustryInput = {
    where: FreelanceIndustryScalarWhereInput
    data: XOR<FreelanceIndustryUpdateManyMutationInput, FreelanceIndustryUncheckedUpdateManyWithoutIndustryInput>
  }

  export type UserIndustryUpsertWithWhereUniqueWithoutIndustryInput = {
    where: UserIndustryWhereUniqueInput
    update: XOR<UserIndustryUpdateWithoutIndustryInput, UserIndustryUncheckedUpdateWithoutIndustryInput>
    create: XOR<UserIndustryCreateWithoutIndustryInput, UserIndustryUncheckedCreateWithoutIndustryInput>
  }

  export type UserIndustryUpdateWithWhereUniqueWithoutIndustryInput = {
    where: UserIndustryWhereUniqueInput
    data: XOR<UserIndustryUpdateWithoutIndustryInput, UserIndustryUncheckedUpdateWithoutIndustryInput>
  }

  export type UserIndustryUpdateManyWithWhereWithoutIndustryInput = {
    where: UserIndustryScalarWhereInput
    data: XOR<UserIndustryUpdateManyMutationInput, UserIndustryUncheckedUpdateManyWithoutIndustryInput>
  }

  export type StandardsUpsertWithWhereUniqueWithoutIndustryInput = {
    where: StandardsWhereUniqueInput
    update: XOR<StandardsUpdateWithoutIndustryInput, StandardsUncheckedUpdateWithoutIndustryInput>
    create: XOR<StandardsCreateWithoutIndustryInput, StandardsUncheckedCreateWithoutIndustryInput>
  }

  export type StandardsUpdateWithWhereUniqueWithoutIndustryInput = {
    where: StandardsWhereUniqueInput
    data: XOR<StandardsUpdateWithoutIndustryInput, StandardsUncheckedUpdateWithoutIndustryInput>
  }

  export type StandardsUpdateManyWithWhereWithoutIndustryInput = {
    where: StandardsScalarWhereInput
    data: XOR<StandardsUpdateManyMutationInput, StandardsUncheckedUpdateManyWithoutIndustryInput>
  }

  export type StandardsScalarWhereInput = {
    AND?: StandardsScalarWhereInput | StandardsScalarWhereInput[]
    OR?: StandardsScalarWhereInput[]
    NOT?: StandardsScalarWhereInput | StandardsScalarWhereInput[]
    id?: UuidFilter<"Standards"> | string
    name?: StringFilter<"Standards"> | string
    description?: StringNullableFilter<"Standards"> | string | null
    type?: EnumStandardsTypeFilter<"Standards"> | $Enums.StandardsType
    industrySlug?: StringFilter<"Standards"> | string
    image?: StringNullableFilter<"Standards"> | string | null
    createdAt?: DateTimeFilter<"Standards"> | Date | string
    updatedAt?: DateTimeFilter<"Standards"> | Date | string
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutIndustryInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutIndustryInput, RevenueStreamUncheckedUpdateWithoutIndustryInput>
    create: XOR<RevenueStreamCreateWithoutIndustryInput, RevenueStreamUncheckedCreateWithoutIndustryInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutIndustryInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutIndustryInput, RevenueStreamUncheckedUpdateWithoutIndustryInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutIndustryInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutIndustryInput>
  }

  export type TagUpsertWithWhereUniqueWithoutIndustryInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutIndustryInput, TagUncheckedUpdateWithoutIndustryInput>
    create: XOR<TagCreateWithoutIndustryInput, TagUncheckedCreateWithoutIndustryInput>
  }

  export type TagUpdateWithWhereUniqueWithoutIndustryInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutIndustryInput, TagUncheckedUpdateWithoutIndustryInput>
  }

  export type TagUpdateManyWithWhereWithoutIndustryInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutIndustryInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: UuidFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    industrySlug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type LookingForUpsertWithWhereUniqueWithoutIndustryInput = {
    where: LookingForWhereUniqueInput
    update: XOR<LookingForUpdateWithoutIndustryInput, LookingForUncheckedUpdateWithoutIndustryInput>
    create: XOR<LookingForCreateWithoutIndustryInput, LookingForUncheckedCreateWithoutIndustryInput>
  }

  export type LookingForUpdateWithWhereUniqueWithoutIndustryInput = {
    where: LookingForWhereUniqueInput
    data: XOR<LookingForUpdateWithoutIndustryInput, LookingForUncheckedUpdateWithoutIndustryInput>
  }

  export type LookingForUpdateManyWithWhereWithoutIndustryInput = {
    where: LookingForScalarWhereInput
    data: XOR<LookingForUpdateManyMutationInput, LookingForUncheckedUpdateManyWithoutIndustryInput>
  }

  export type LookingForScalarWhereInput = {
    AND?: LookingForScalarWhereInput | LookingForScalarWhereInput[]
    OR?: LookingForScalarWhereInput[]
    NOT?: LookingForScalarWhereInput | LookingForScalarWhereInput[]
    id?: UuidFilter<"LookingFor"> | string
    name?: StringFilter<"LookingFor"> | string
    slug?: StringFilter<"LookingFor"> | string
    industrySlug?: StringFilter<"LookingFor"> | string
    createdAt?: DateTimeFilter<"LookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"LookingFor"> | Date | string
  }

  export type IndustryCreateWithoutTagInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutTagInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutTagInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutTagInput, IndustryUncheckedCreateWithoutTagInput>
  }

  export type PortfolioTagCreateWithoutTagInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutIndustryTagsInput
  }

  export type PortfolioTagUncheckedCreateWithoutTagInput = {
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagCreateOrConnectWithoutTagInput = {
    where: PortfolioTagWhereUniqueInput
    create: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput>
  }

  export type PortfolioTagCreateManyTagInputEnvelope = {
    data: PortfolioTagCreateManyTagInput | PortfolioTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type UserTagsCreateWithoutTagInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustryTagsInput
  }

  export type UserTagsUncheckedCreateWithoutTagInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsCreateOrConnectWithoutTagInput = {
    where: UserTagsWhereUniqueInput
    create: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput>
  }

  export type UserTagsCreateManyTagInputEnvelope = {
    data: UserTagsCreateManyTagInput | UserTagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutTagInput = {
    update: XOR<IndustryUpdateWithoutTagInput, IndustryUncheckedUpdateWithoutTagInput>
    create: XOR<IndustryCreateWithoutTagInput, IndustryUncheckedCreateWithoutTagInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutTagInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutTagInput, IndustryUncheckedUpdateWithoutTagInput>
  }

  export type IndustryUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type PortfolioTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PortfolioTagWhereUniqueInput
    update: XOR<PortfolioTagUpdateWithoutTagInput, PortfolioTagUncheckedUpdateWithoutTagInput>
    create: XOR<PortfolioTagCreateWithoutTagInput, PortfolioTagUncheckedCreateWithoutTagInput>
  }

  export type PortfolioTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PortfolioTagWhereUniqueInput
    data: XOR<PortfolioTagUpdateWithoutTagInput, PortfolioTagUncheckedUpdateWithoutTagInput>
  }

  export type PortfolioTagUpdateManyWithWhereWithoutTagInput = {
    where: PortfolioTagScalarWhereInput
    data: XOR<PortfolioTagUpdateManyMutationInput, PortfolioTagUncheckedUpdateManyWithoutTagInput>
  }

  export type PortfolioTagScalarWhereInput = {
    AND?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
    OR?: PortfolioTagScalarWhereInput[]
    NOT?: PortfolioTagScalarWhereInput | PortfolioTagScalarWhereInput[]
    portfolioId?: UuidFilter<"PortfolioTag"> | string
    tagSlug?: StringFilter<"PortfolioTag"> | string
    createdAt?: DateTimeFilter<"PortfolioTag"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioTag"> | Date | string
  }

  export type UserTagsUpsertWithWhereUniqueWithoutTagInput = {
    where: UserTagsWhereUniqueInput
    update: XOR<UserTagsUpdateWithoutTagInput, UserTagsUncheckedUpdateWithoutTagInput>
    create: XOR<UserTagsCreateWithoutTagInput, UserTagsUncheckedCreateWithoutTagInput>
  }

  export type UserTagsUpdateWithWhereUniqueWithoutTagInput = {
    where: UserTagsWhereUniqueInput
    data: XOR<UserTagsUpdateWithoutTagInput, UserTagsUncheckedUpdateWithoutTagInput>
  }

  export type UserTagsUpdateManyWithWhereWithoutTagInput = {
    where: UserTagsScalarWhereInput
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyWithoutTagInput>
  }

  export type IndustryCreateWithoutLookingForInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutLookingForInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutLookingForInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutLookingForInput, IndustryUncheckedCreateWithoutLookingForInput>
  }

  export type PortfolioLookingForCreateWithoutLookingForInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutIndustryLookingForInput
  }

  export type PortfolioLookingForUncheckedCreateWithoutLookingForInput = {
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForCreateOrConnectWithoutLookingForInput = {
    where: PortfolioLookingForWhereUniqueInput
    create: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput>
  }

  export type PortfolioLookingForCreateManyLookingForInputEnvelope = {
    data: PortfolioLookingForCreateManyLookingForInput | PortfolioLookingForCreateManyLookingForInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutLookingForInput = {
    update: XOR<IndustryUpdateWithoutLookingForInput, IndustryUncheckedUpdateWithoutLookingForInput>
    create: XOR<IndustryCreateWithoutLookingForInput, IndustryUncheckedCreateWithoutLookingForInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutLookingForInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutLookingForInput, IndustryUncheckedUpdateWithoutLookingForInput>
  }

  export type IndustryUpdateWithoutLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type PortfolioLookingForUpsertWithWhereUniqueWithoutLookingForInput = {
    where: PortfolioLookingForWhereUniqueInput
    update: XOR<PortfolioLookingForUpdateWithoutLookingForInput, PortfolioLookingForUncheckedUpdateWithoutLookingForInput>
    create: XOR<PortfolioLookingForCreateWithoutLookingForInput, PortfolioLookingForUncheckedCreateWithoutLookingForInput>
  }

  export type PortfolioLookingForUpdateWithWhereUniqueWithoutLookingForInput = {
    where: PortfolioLookingForWhereUniqueInput
    data: XOR<PortfolioLookingForUpdateWithoutLookingForInput, PortfolioLookingForUncheckedUpdateWithoutLookingForInput>
  }

  export type PortfolioLookingForUpdateManyWithWhereWithoutLookingForInput = {
    where: PortfolioLookingForScalarWhereInput
    data: XOR<PortfolioLookingForUpdateManyMutationInput, PortfolioLookingForUncheckedUpdateManyWithoutLookingForInput>
  }

  export type PortfolioLookingForScalarWhereInput = {
    AND?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
    OR?: PortfolioLookingForScalarWhereInput[]
    NOT?: PortfolioLookingForScalarWhereInput | PortfolioLookingForScalarWhereInput[]
    portfolioId?: UuidFilter<"PortfolioLookingFor"> | string
    lookingForSlug?: StringFilter<"PortfolioLookingFor"> | string
    createdAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioLookingFor"> | Date | string
  }

  export type IndustryCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutCategoryInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutCategoryInput, IndustryUncheckedCreateWithoutCategoryInput>
  }

  export type RevenueStreamCreateWithoutCategoryInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutCategoryInput = {
    id?: string
    year: number
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutCategoryInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput>
  }

  export type RevenueStreamCreateManyCategoryInputEnvelope = {
    data: RevenueStreamCreateManyCategoryInput | RevenueStreamCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutCategoryInput = {
    update: XOR<IndustryUpdateWithoutCategoryInput, IndustryUncheckedUpdateWithoutCategoryInput>
    create: XOR<IndustryCreateWithoutCategoryInput, IndustryUncheckedCreateWithoutCategoryInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutCategoryInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutCategoryInput, IndustryUncheckedUpdateWithoutCategoryInput>
  }

  export type IndustryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutCategoryInput, RevenueStreamUncheckedUpdateWithoutCategoryInput>
    create: XOR<RevenueStreamCreateWithoutCategoryInput, RevenueStreamUncheckedCreateWithoutCategoryInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutCategoryInput, RevenueStreamUncheckedUpdateWithoutCategoryInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutCategoryInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutCategoryInput>
  }

  export type IndustryCreateWithoutSourceInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutSourceInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutSourceInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutSourceInput, IndustryUncheckedCreateWithoutSourceInput>
  }

  export type RevenueStreamCreateWithoutSourceInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutSourceInput = {
    id?: string
    year: number
    categorySlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutSourceInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput>
  }

  export type RevenueStreamCreateManySourceInputEnvelope = {
    data: RevenueStreamCreateManySourceInput | RevenueStreamCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutSourceInput = {
    update: XOR<IndustryUpdateWithoutSourceInput, IndustryUncheckedUpdateWithoutSourceInput>
    create: XOR<IndustryCreateWithoutSourceInput, IndustryUncheckedCreateWithoutSourceInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutSourceInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutSourceInput, IndustryUncheckedUpdateWithoutSourceInput>
  }

  export type IndustryUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutSourceInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutSourceInput, RevenueStreamUncheckedUpdateWithoutSourceInput>
    create: XOR<RevenueStreamCreateWithoutSourceInput, RevenueStreamUncheckedCreateWithoutSourceInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutSourceInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutSourceInput, RevenueStreamUncheckedUpdateWithoutSourceInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutSourceInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutSourceInput>
  }

  export type IndustryCreateWithoutChannelInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutChannelInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutChannelInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutChannelInput, IndustryUncheckedCreateWithoutChannelInput>
  }

  export type RevenueStreamCreateWithoutChannelInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    segment: SegmentCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutChannelInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutChannelInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput>
  }

  export type RevenueStreamCreateManyChannelInputEnvelope = {
    data: RevenueStreamCreateManyChannelInput | RevenueStreamCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type UserChannelsCreateWithoutChannelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustryChannelsInput
  }

  export type UserChannelsUncheckedCreateWithoutChannelInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsCreateOrConnectWithoutChannelInput = {
    where: UserChannelsWhereUniqueInput
    create: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput>
  }

  export type UserChannelsCreateManyChannelInputEnvelope = {
    data: UserChannelsCreateManyChannelInput | UserChannelsCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutChannelInput = {
    update: XOR<IndustryUpdateWithoutChannelInput, IndustryUncheckedUpdateWithoutChannelInput>
    create: XOR<IndustryCreateWithoutChannelInput, IndustryUncheckedCreateWithoutChannelInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutChannelInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutChannelInput, IndustryUncheckedUpdateWithoutChannelInput>
  }

  export type IndustryUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutChannelInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutChannelInput, RevenueStreamUncheckedUpdateWithoutChannelInput>
    create: XOR<RevenueStreamCreateWithoutChannelInput, RevenueStreamUncheckedCreateWithoutChannelInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutChannelInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutChannelInput, RevenueStreamUncheckedUpdateWithoutChannelInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutChannelInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutChannelInput>
  }

  export type UserChannelsUpsertWithWhereUniqueWithoutChannelInput = {
    where: UserChannelsWhereUniqueInput
    update: XOR<UserChannelsUpdateWithoutChannelInput, UserChannelsUncheckedUpdateWithoutChannelInput>
    create: XOR<UserChannelsCreateWithoutChannelInput, UserChannelsUncheckedCreateWithoutChannelInput>
  }

  export type UserChannelsUpdateWithWhereUniqueWithoutChannelInput = {
    where: UserChannelsWhereUniqueInput
    data: XOR<UserChannelsUpdateWithoutChannelInput, UserChannelsUncheckedUpdateWithoutChannelInput>
  }

  export type UserChannelsUpdateManyWithWhereWithoutChannelInput = {
    where: UserChannelsScalarWhereInput
    data: XOR<UserChannelsUpdateManyMutationInput, UserChannelsUncheckedUpdateManyWithoutChannelInput>
  }

  export type IndustryCreateWithoutSegmentInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutSegmentInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutSegmentInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutSegmentInput, IndustryUncheckedCreateWithoutSegmentInput>
  }

  export type RevenueStreamCreateWithoutSegmentInput = {
    id?: string
    year: number
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutRevenueStreamInput
    category: CategoryCreateNestedOneWithoutRevenueStreamInput
    source: SourceCreateNestedOneWithoutRevenueStreamInput
    channel: ChannelCreateNestedOneWithoutRevenueStreamInput
    company: CompanyCreateNestedOneWithoutRevenueStreamInput
  }

  export type RevenueStreamUncheckedCreateWithoutSegmentInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateOrConnectWithoutSegmentInput = {
    where: RevenueStreamWhereUniqueInput
    create: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput>
  }

  export type RevenueStreamCreateManySegmentInputEnvelope = {
    data: RevenueStreamCreateManySegmentInput | RevenueStreamCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutSegmentInput = {
    update: XOR<IndustryUpdateWithoutSegmentInput, IndustryUncheckedUpdateWithoutSegmentInput>
    create: XOR<IndustryCreateWithoutSegmentInput, IndustryUncheckedCreateWithoutSegmentInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutSegmentInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutSegmentInput, IndustryUncheckedUpdateWithoutSegmentInput>
  }

  export type IndustryUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type RevenueStreamUpsertWithWhereUniqueWithoutSegmentInput = {
    where: RevenueStreamWhereUniqueInput
    update: XOR<RevenueStreamUpdateWithoutSegmentInput, RevenueStreamUncheckedUpdateWithoutSegmentInput>
    create: XOR<RevenueStreamCreateWithoutSegmentInput, RevenueStreamUncheckedCreateWithoutSegmentInput>
  }

  export type RevenueStreamUpdateWithWhereUniqueWithoutSegmentInput = {
    where: RevenueStreamWhereUniqueInput
    data: XOR<RevenueStreamUpdateWithoutSegmentInput, RevenueStreamUncheckedUpdateWithoutSegmentInput>
  }

  export type RevenueStreamUpdateManyWithWhereWithoutSegmentInput = {
    where: RevenueStreamScalarWhereInput
    data: XOR<RevenueStreamUpdateManyMutationInput, RevenueStreamUncheckedUpdateManyWithoutSegmentInput>
  }

  export type PortfolioTagCreateWithoutPortfolioInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: TagCreateNestedOneWithoutPortfolioTagInput
  }

  export type PortfolioTagUncheckedCreateWithoutPortfolioInput = {
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioTagWhereUniqueInput
    create: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioTagCreateManyPortfolioInputEnvelope = {
    data: PortfolioTagCreateManyPortfolioInput | PortfolioTagCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioLookingForCreateWithoutPortfolioInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    lookingFor: LookingForCreateNestedOneWithoutPortfolioLookingForInput
  }

  export type PortfolioLookingForUncheckedCreateWithoutPortfolioInput = {
    lookingForSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioLookingForWhereUniqueInput
    create: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioLookingForCreateManyPortfolioInputEnvelope = {
    data: PortfolioLookingForCreateManyPortfolioInput | PortfolioLookingForCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceCreateWithoutPortfolioInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryCreateNestedManyWithoutFreelanceInput
    skills?: SkillCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueCreateNestedManyWithoutFreelanceInput
    user: UserCreateNestedOneWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateWithoutPortfolioInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    industriesRelated?: FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput
    skills?: SkillUncheckedCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceCreateOrConnectWithoutPortfolioInput = {
    where: FreelanceWhereUniqueInput
    create: XOR<FreelanceCreateWithoutPortfolioInput, FreelanceUncheckedCreateWithoutPortfolioInput>
  }

  export type CompanyCreateWithoutPortfolioInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    user: UserCreateNestedOneWithoutCompanyInput
    industriesRelated?: CompanyIndustryCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPortfolioInput = {
    id?: string
    juristicId: string
    nameTh: string
    nameEn?: string | null
    description?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    registerdCapital?: number | null
    employeeCount?: number | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industries?: CompanyCreateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedCreateNestedManyWithoutCompanyInput
    companyRevenue?: CompanyRevenueUncheckedCreateNestedManyWithoutCompanyInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPortfolioInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPortfolioInput, CompanyUncheckedCreateWithoutPortfolioInput>
  }

  export type FavoriteCreateWithoutPortfolioInput = {
    id?: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteInput
  }

  export type FavoriteUncheckedCreateWithoutPortfolioInput = {
    id?: string
    userId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutPortfolioInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput>
  }

  export type FavoriteCreateManyPortfolioInputEnvelope = {
    data: FavoriteCreateManyPortfolioInput | FavoriteCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioImageCreateWithoutPortfolioInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioImageUncheckedCreateWithoutPortfolioInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioImageCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioImageWhereUniqueInput
    create: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioImageCreateManyPortfolioInputEnvelope = {
    data: PortfolioImageCreateManyPortfolioInput | PortfolioImageCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioStandardsCreateWithoutPortfolioInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    standards: StandardsCreateNestedOneWithoutPortfolioStandardsInput
  }

  export type PortfolioStandardsUncheckedCreateWithoutPortfolioInput = {
    id?: string
    standardsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioStandardsWhereUniqueInput
    create: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioStandardsCreateManyPortfolioInputEnvelope = {
    data: PortfolioStandardsCreateManyPortfolioInput | PortfolioStandardsCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCommentCreateWithoutPortfolioInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: PortfolioCommentCreateNestedOneWithoutRepliesInput
    replies?: PortfolioCommentCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentUncheckedCreateWithoutPortfolioInput = {
    id?: string
    content: string
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: PortfolioCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentCreateOrConnectWithoutPortfolioInput = {
    where: PortfolioCommentWhereUniqueInput
    create: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioCommentCreateManyPortfolioInputEnvelope = {
    data: PortfolioCommentCreateManyPortfolioInput | PortfolioCommentCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioTagUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioTagWhereUniqueInput
    update: XOR<PortfolioTagUpdateWithoutPortfolioInput, PortfolioTagUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioTagCreateWithoutPortfolioInput, PortfolioTagUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioTagUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioTagWhereUniqueInput
    data: XOR<PortfolioTagUpdateWithoutPortfolioInput, PortfolioTagUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioTagUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioTagScalarWhereInput
    data: XOR<PortfolioTagUpdateManyMutationInput, PortfolioTagUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioLookingForUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioLookingForWhereUniqueInput
    update: XOR<PortfolioLookingForUpdateWithoutPortfolioInput, PortfolioLookingForUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioLookingForCreateWithoutPortfolioInput, PortfolioLookingForUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioLookingForUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioLookingForWhereUniqueInput
    data: XOR<PortfolioLookingForUpdateWithoutPortfolioInput, PortfolioLookingForUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioLookingForUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioLookingForScalarWhereInput
    data: XOR<PortfolioLookingForUpdateManyMutationInput, PortfolioLookingForUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type FreelanceUpsertWithoutPortfolioInput = {
    update: XOR<FreelanceUpdateWithoutPortfolioInput, FreelanceUncheckedUpdateWithoutPortfolioInput>
    create: XOR<FreelanceCreateWithoutPortfolioInput, FreelanceUncheckedCreateWithoutPortfolioInput>
    where?: FreelanceWhereInput
  }

  export type FreelanceUpdateToOneWithWhereWithoutPortfolioInput = {
    where?: FreelanceWhereInput
    data: XOR<FreelanceUpdateWithoutPortfolioInput, FreelanceUncheckedUpdateWithoutPortfolioInput>
  }

  export type FreelanceUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUpdateManyWithoutFreelanceNestedInput
    user?: UserUpdateOneRequiredWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    industriesRelated?: FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput
    skills?: SkillUncheckedUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type CompanyUpsertWithoutPortfolioInput = {
    update: XOR<CompanyUpdateWithoutPortfolioInput, CompanyUncheckedUpdateWithoutPortfolioInput>
    create: XOR<CompanyCreateWithoutPortfolioInput, CompanyUncheckedCreateWithoutPortfolioInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPortfolioInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPortfolioInput, CompanyUncheckedUpdateWithoutPortfolioInput>
  }

  export type CompanyUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    user?: UserUpdateOneRequiredWithoutCompanyNestedInput
    industriesRelated?: CompanyIndustryUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    juristicId?: StringFieldUpdateOperationsInput | string
    nameTh?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    registerdCapital?: NullableFloatFieldUpdateOperationsInput | number | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industries?: CompanyUpdateindustriesInput | string[]
    industriesRelated?: CompanyIndustryUncheckedUpdateManyWithoutCompanyNestedInput
    companyRevenue?: CompanyRevenueUncheckedUpdateManyWithoutCompanyNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FavoriteUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutPortfolioInput, FavoriteUncheckedUpdateWithoutPortfolioInput>
    create: XOR<FavoriteCreateWithoutPortfolioInput, FavoriteUncheckedCreateWithoutPortfolioInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutPortfolioInput, FavoriteUncheckedUpdateWithoutPortfolioInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutPortfolioInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioImageUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioImageWhereUniqueInput
    update: XOR<PortfolioImageUpdateWithoutPortfolioInput, PortfolioImageUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioImageCreateWithoutPortfolioInput, PortfolioImageUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioImageUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioImageWhereUniqueInput
    data: XOR<PortfolioImageUpdateWithoutPortfolioInput, PortfolioImageUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioImageUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioImageScalarWhereInput
    data: XOR<PortfolioImageUpdateManyMutationInput, PortfolioImageUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioImageScalarWhereInput = {
    AND?: PortfolioImageScalarWhereInput | PortfolioImageScalarWhereInput[]
    OR?: PortfolioImageScalarWhereInput[]
    NOT?: PortfolioImageScalarWhereInput | PortfolioImageScalarWhereInput[]
    id?: UuidFilter<"PortfolioImage"> | string
    url?: StringFilter<"PortfolioImage"> | string
    description?: StringNullableFilter<"PortfolioImage"> | string | null
    type?: EnumPortfolioImageTypeFilter<"PortfolioImage"> | $Enums.PortfolioImageType
    portfolioId?: UuidFilter<"PortfolioImage"> | string
    createdAt?: DateTimeFilter<"PortfolioImage"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioImage"> | Date | string
  }

  export type PortfolioStandardsUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioStandardsWhereUniqueInput
    update: XOR<PortfolioStandardsUpdateWithoutPortfolioInput, PortfolioStandardsUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioStandardsCreateWithoutPortfolioInput, PortfolioStandardsUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioStandardsUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioStandardsWhereUniqueInput
    data: XOR<PortfolioStandardsUpdateWithoutPortfolioInput, PortfolioStandardsUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioStandardsUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioStandardsScalarWhereInput
    data: XOR<PortfolioStandardsUpdateManyMutationInput, PortfolioStandardsUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioStandardsScalarWhereInput = {
    AND?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
    OR?: PortfolioStandardsScalarWhereInput[]
    NOT?: PortfolioStandardsScalarWhereInput | PortfolioStandardsScalarWhereInput[]
    id?: UuidFilter<"PortfolioStandards"> | string
    portfolioId?: UuidFilter<"PortfolioStandards"> | string
    standardsId?: UuidFilter<"PortfolioStandards"> | string
    createdAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioStandards"> | Date | string
  }

  export type PortfolioCommentUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioCommentWhereUniqueInput
    update: XOR<PortfolioCommentUpdateWithoutPortfolioInput, PortfolioCommentUncheckedUpdateWithoutPortfolioInput>
    create: XOR<PortfolioCommentCreateWithoutPortfolioInput, PortfolioCommentUncheckedCreateWithoutPortfolioInput>
  }

  export type PortfolioCommentUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: PortfolioCommentWhereUniqueInput
    data: XOR<PortfolioCommentUpdateWithoutPortfolioInput, PortfolioCommentUncheckedUpdateWithoutPortfolioInput>
  }

  export type PortfolioCommentUpdateManyWithWhereWithoutPortfolioInput = {
    where: PortfolioCommentScalarWhereInput
    data: XOR<PortfolioCommentUpdateManyMutationInput, PortfolioCommentUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioCreateWithoutIndustryTagsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutIndustryTagsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutIndustryTagsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutIndustryTagsInput, PortfolioUncheckedCreateWithoutIndustryTagsInput>
  }

  export type TagCreateWithoutPortfolioTagInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutTagInput
    UserTags?: UserTagsCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutPortfolioTagInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserTags?: UserTagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutPortfolioTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPortfolioTagInput, TagUncheckedCreateWithoutPortfolioTagInput>
  }

  export type PortfolioUpsertWithoutIndustryTagsInput = {
    update: XOR<PortfolioUpdateWithoutIndustryTagsInput, PortfolioUncheckedUpdateWithoutIndustryTagsInput>
    create: XOR<PortfolioCreateWithoutIndustryTagsInput, PortfolioUncheckedCreateWithoutIndustryTagsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutIndustryTagsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutIndustryTagsInput, PortfolioUncheckedUpdateWithoutIndustryTagsInput>
  }

  export type PortfolioUpdateWithoutIndustryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutIndustryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type TagUpsertWithoutPortfolioTagInput = {
    update: XOR<TagUpdateWithoutPortfolioTagInput, TagUncheckedUpdateWithoutPortfolioTagInput>
    create: XOR<TagCreateWithoutPortfolioTagInput, TagUncheckedCreateWithoutPortfolioTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPortfolioTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPortfolioTagInput, TagUncheckedUpdateWithoutPortfolioTagInput>
  }

  export type TagUpdateWithoutPortfolioTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutTagNestedInput
    UserTags?: UserTagsUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutPortfolioTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserTags?: UserTagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type PortfolioCreateWithoutIndustryLookingForInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutIndustryLookingForInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutIndustryLookingForInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutIndustryLookingForInput, PortfolioUncheckedCreateWithoutIndustryLookingForInput>
  }

  export type LookingForCreateWithoutPortfolioLookingForInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutLookingForInput
  }

  export type LookingForUncheckedCreateWithoutPortfolioLookingForInput = {
    id?: string
    name: string
    slug: string
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LookingForCreateOrConnectWithoutPortfolioLookingForInput = {
    where: LookingForWhereUniqueInput
    create: XOR<LookingForCreateWithoutPortfolioLookingForInput, LookingForUncheckedCreateWithoutPortfolioLookingForInput>
  }

  export type PortfolioUpsertWithoutIndustryLookingForInput = {
    update: XOR<PortfolioUpdateWithoutIndustryLookingForInput, PortfolioUncheckedUpdateWithoutIndustryLookingForInput>
    create: XOR<PortfolioCreateWithoutIndustryLookingForInput, PortfolioUncheckedCreateWithoutIndustryLookingForInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutIndustryLookingForInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutIndustryLookingForInput, PortfolioUncheckedUpdateWithoutIndustryLookingForInput>
  }

  export type PortfolioUpdateWithoutIndustryLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutIndustryLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type LookingForUpsertWithoutPortfolioLookingForInput = {
    update: XOR<LookingForUpdateWithoutPortfolioLookingForInput, LookingForUncheckedUpdateWithoutPortfolioLookingForInput>
    create: XOR<LookingForCreateWithoutPortfolioLookingForInput, LookingForUncheckedCreateWithoutPortfolioLookingForInput>
    where?: LookingForWhereInput
  }

  export type LookingForUpdateToOneWithWhereWithoutPortfolioLookingForInput = {
    where?: LookingForWhereInput
    data: XOR<LookingForUpdateWithoutPortfolioLookingForInput, LookingForUncheckedUpdateWithoutPortfolioLookingForInput>
  }

  export type LookingForUpdateWithoutPortfolioLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutLookingForNestedInput
  }

  export type LookingForUncheckedUpdateWithoutPortfolioLookingForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateWithoutStandardsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutStandardsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutStandardsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutStandardsInput, PortfolioUncheckedCreateWithoutStandardsInput>
  }

  export type StandardsCreateWithoutPortfolioStandardsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industry: IndustryCreateNestedOneWithoutStandardsInput
  }

  export type StandardsUncheckedCreateWithoutPortfolioStandardsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    industrySlug: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardsCreateOrConnectWithoutPortfolioStandardsInput = {
    where: StandardsWhereUniqueInput
    create: XOR<StandardsCreateWithoutPortfolioStandardsInput, StandardsUncheckedCreateWithoutPortfolioStandardsInput>
  }

  export type PortfolioUpsertWithoutStandardsInput = {
    update: XOR<PortfolioUpdateWithoutStandardsInput, PortfolioUncheckedUpdateWithoutStandardsInput>
    create: XOR<PortfolioCreateWithoutStandardsInput, PortfolioUncheckedCreateWithoutStandardsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutStandardsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutStandardsInput, PortfolioUncheckedUpdateWithoutStandardsInput>
  }

  export type PortfolioUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type StandardsUpsertWithoutPortfolioStandardsInput = {
    update: XOR<StandardsUpdateWithoutPortfolioStandardsInput, StandardsUncheckedUpdateWithoutPortfolioStandardsInput>
    create: XOR<StandardsCreateWithoutPortfolioStandardsInput, StandardsUncheckedCreateWithoutPortfolioStandardsInput>
    where?: StandardsWhereInput
  }

  export type StandardsUpdateToOneWithWhereWithoutPortfolioStandardsInput = {
    where?: StandardsWhereInput
    data: XOR<StandardsUpdateWithoutPortfolioStandardsInput, StandardsUncheckedUpdateWithoutPortfolioStandardsInput>
  }

  export type StandardsUpdateWithoutPortfolioStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutStandardsNestedInput
  }

  export type StandardsUncheckedUpdateWithoutPortfolioStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    industrySlug?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateWithoutImageInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutImageInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutImageInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutImageInput, PortfolioUncheckedCreateWithoutImageInput>
  }

  export type PortfolioUpsertWithoutImageInput = {
    update: XOR<PortfolioUpdateWithoutImageInput, PortfolioUncheckedUpdateWithoutImageInput>
    create: XOR<PortfolioCreateWithoutImageInput, PortfolioUncheckedCreateWithoutImageInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutImageInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutImageInput, PortfolioUncheckedUpdateWithoutImageInput>
  }

  export type PortfolioUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateWithoutFavoriteInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutFavoriteInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutFavoriteInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutFavoriteInput, PortfolioUncheckedCreateWithoutFavoriteInput>
  }

  export type UserCreateWithoutFavoriteInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    comments?: PortfolioCommentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoriteInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    comments?: PortfolioCommentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteInput, UserUncheckedCreateWithoutFavoriteInput>
  }

  export type PortfolioUpsertWithoutFavoriteInput = {
    update: XOR<PortfolioUpdateWithoutFavoriteInput, PortfolioUncheckedUpdateWithoutFavoriteInput>
    create: XOR<PortfolioCreateWithoutFavoriteInput, PortfolioUncheckedCreateWithoutFavoriteInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutFavoriteInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutFavoriteInput, PortfolioUncheckedUpdateWithoutFavoriteInput>
  }

  export type PortfolioUpdateWithoutFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type UserUpsertWithoutFavoriteInput = {
    update: XOR<UserUpdateWithoutFavoriteInput, UserUncheckedUpdateWithoutFavoriteInput>
    create: XOR<UserCreateWithoutFavoriteInput, UserUncheckedCreateWithoutFavoriteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteInput, UserUncheckedUpdateWithoutFavoriteInput>
  }

  export type UserUpdateWithoutFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    comments?: PortfolioCommentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IndustryCreateWithoutStandardsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillCreateNestedManyWithoutIndustryInput
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutStandardsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Skill?: SkillUncheckedCreateNestedManyWithoutIndustryInput
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutStandardsInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutStandardsInput, IndustryUncheckedCreateWithoutStandardsInput>
  }

  export type PortfolioStandardsCreateWithoutStandardsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutStandardsInput
  }

  export type PortfolioStandardsUncheckedCreateWithoutStandardsInput = {
    id?: string
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsCreateOrConnectWithoutStandardsInput = {
    where: PortfolioStandardsWhereUniqueInput
    create: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput>
  }

  export type PortfolioStandardsCreateManyStandardsInputEnvelope = {
    data: PortfolioStandardsCreateManyStandardsInput | PortfolioStandardsCreateManyStandardsInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutStandardsInput = {
    update: XOR<IndustryUpdateWithoutStandardsInput, IndustryUncheckedUpdateWithoutStandardsInput>
    create: XOR<IndustryCreateWithoutStandardsInput, IndustryUncheckedCreateWithoutStandardsInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutStandardsInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutStandardsInput, IndustryUncheckedUpdateWithoutStandardsInput>
  }

  export type IndustryUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUpdateManyWithoutIndustryNestedInput
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Skill?: SkillUncheckedUpdateManyWithoutIndustryNestedInput
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type PortfolioStandardsUpsertWithWhereUniqueWithoutStandardsInput = {
    where: PortfolioStandardsWhereUniqueInput
    update: XOR<PortfolioStandardsUpdateWithoutStandardsInput, PortfolioStandardsUncheckedUpdateWithoutStandardsInput>
    create: XOR<PortfolioStandardsCreateWithoutStandardsInput, PortfolioStandardsUncheckedCreateWithoutStandardsInput>
  }

  export type PortfolioStandardsUpdateWithWhereUniqueWithoutStandardsInput = {
    where: PortfolioStandardsWhereUniqueInput
    data: XOR<PortfolioStandardsUpdateWithoutStandardsInput, PortfolioStandardsUncheckedUpdateWithoutStandardsInput>
  }

  export type PortfolioStandardsUpdateManyWithWhereWithoutStandardsInput = {
    where: PortfolioStandardsScalarWhereInput
    data: XOR<PortfolioStandardsUpdateManyMutationInput, PortfolioStandardsUncheckedUpdateManyWithoutStandardsInput>
  }

  export type IndustryCreateWithoutSkillInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Source?: SourceCreateNestedManyWithoutIndustryInput
    Channel?: ChannelCreateNestedManyWithoutIndustryInput
    Segment?: SegmentCreateNestedManyWithoutIndustryInput
    Category?: CategoryCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryCreateNestedManyWithoutIndustryInput
    users?: UserIndustryCreateNestedManyWithoutIndustryInput
    Standards?: StandardsCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamCreateNestedManyWithoutIndustryInput
    Tag?: TagCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateWithoutSkillInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Source?: SourceUncheckedCreateNestedManyWithoutIndustryInput
    Channel?: ChannelUncheckedCreateNestedManyWithoutIndustryInput
    Segment?: SegmentUncheckedCreateNestedManyWithoutIndustryInput
    Category?: CategoryUncheckedCreateNestedManyWithoutIndustryInput
    companies?: CompanyIndustryUncheckedCreateNestedManyWithoutIndustryInput
    freelancers?: FreelanceIndustryUncheckedCreateNestedManyWithoutIndustryInput
    users?: UserIndustryUncheckedCreateNestedManyWithoutIndustryInput
    Standards?: StandardsUncheckedCreateNestedManyWithoutIndustryInput
    RevenueStream?: RevenueStreamUncheckedCreateNestedManyWithoutIndustryInput
    Tag?: TagUncheckedCreateNestedManyWithoutIndustryInput
    LookingFor?: LookingForUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryCreateOrConnectWithoutSkillInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutSkillInput, IndustryUncheckedCreateWithoutSkillInput>
  }

  export type FreelanceCreateWithoutSkillsInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: FreelanceIndustryCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueCreateNestedManyWithoutFreelanceInput
    user: UserCreateNestedOneWithoutFreelanceInput
    Portfolio?: PortfolioCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceUncheckedCreateWithoutSkillsInput = {
    id?: string
    firstNameTh: string
    lastNameTh: string
    firstNameEn?: string | null
    lastNameEn?: string | null
    image?: string | null
    cover_image?: string | null
    address?: string | null
    subDistrict?: string | null
    district?: string | null
    province?: string | null
    postalCode?: string | null
    phoneNumber?: string | null
    email?: string | null
    juristicId?: string | null
    industryTypes?: FreelanceCreateindustryTypesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    industriesRelated?: FreelanceIndustryUncheckedCreateNestedManyWithoutFreelanceInput
    freelanceRevenue?: FreelanceRevenueUncheckedCreateNestedManyWithoutFreelanceInput
    Portfolio?: PortfolioUncheckedCreateNestedManyWithoutFreelanceInput
  }

  export type FreelanceCreateOrConnectWithoutSkillsInput = {
    where: FreelanceWhereUniqueInput
    create: XOR<FreelanceCreateWithoutSkillsInput, FreelanceUncheckedCreateWithoutSkillsInput>
  }

  export type UserSkillsCreateWithoutSkillInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIndustrySkillsInput
  }

  export type UserSkillsUncheckedCreateWithoutSkillInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsCreateOrConnectWithoutSkillInput = {
    where: UserSkillsWhereUniqueInput
    create: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillsCreateManySkillInputEnvelope = {
    data: UserSkillsCreateManySkillInput | UserSkillsCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type IndustryUpsertWithoutSkillInput = {
    update: XOR<IndustryUpdateWithoutSkillInput, IndustryUncheckedUpdateWithoutSkillInput>
    create: XOR<IndustryCreateWithoutSkillInput, IndustryUncheckedCreateWithoutSkillInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutSkillInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutSkillInput, IndustryUncheckedUpdateWithoutSkillInput>
  }

  export type IndustryUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Source?: SourceUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUpdateManyWithoutIndustryNestedInput
    Tag?: TagUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Source?: SourceUncheckedUpdateManyWithoutIndustryNestedInput
    Channel?: ChannelUncheckedUpdateManyWithoutIndustryNestedInput
    Segment?: SegmentUncheckedUpdateManyWithoutIndustryNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutIndustryNestedInput
    companies?: CompanyIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    freelancers?: FreelanceIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    users?: UserIndustryUncheckedUpdateManyWithoutIndustryNestedInput
    Standards?: StandardsUncheckedUpdateManyWithoutIndustryNestedInput
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutIndustryNestedInput
    Tag?: TagUncheckedUpdateManyWithoutIndustryNestedInput
    LookingFor?: LookingForUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type FreelanceUpsertWithoutSkillsInput = {
    update: XOR<FreelanceUpdateWithoutSkillsInput, FreelanceUncheckedUpdateWithoutSkillsInput>
    create: XOR<FreelanceCreateWithoutSkillsInput, FreelanceUncheckedCreateWithoutSkillsInput>
    where?: FreelanceWhereInput
  }

  export type FreelanceUpdateToOneWithWhereWithoutSkillsInput = {
    where?: FreelanceWhereInput
    data: XOR<FreelanceUpdateWithoutSkillsInput, FreelanceUncheckedUpdateWithoutSkillsInput>
  }

  export type FreelanceUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: FreelanceIndustryUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUpdateManyWithoutFreelanceNestedInput
    user?: UserUpdateOneRequiredWithoutFreelanceNestedInput
    Portfolio?: PortfolioUpdateManyWithoutFreelanceNestedInput
  }

  export type FreelanceUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstNameTh?: StringFieldUpdateOperationsInput | string
    lastNameTh?: StringFieldUpdateOperationsInput | string
    firstNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    lastNameEn?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    juristicId?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypes?: FreelanceUpdateindustryTypesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    industriesRelated?: FreelanceIndustryUncheckedUpdateManyWithoutFreelanceNestedInput
    freelanceRevenue?: FreelanceRevenueUncheckedUpdateManyWithoutFreelanceNestedInput
    Portfolio?: PortfolioUncheckedUpdateManyWithoutFreelanceNestedInput
  }

  export type UserSkillsUpsertWithWhereUniqueWithoutSkillInput = {
    where: UserSkillsWhereUniqueInput
    update: XOR<UserSkillsUpdateWithoutSkillInput, UserSkillsUncheckedUpdateWithoutSkillInput>
    create: XOR<UserSkillsCreateWithoutSkillInput, UserSkillsUncheckedCreateWithoutSkillInput>
  }

  export type UserSkillsUpdateWithWhereUniqueWithoutSkillInput = {
    where: UserSkillsWhereUniqueInput
    data: XOR<UserSkillsUpdateWithoutSkillInput, UserSkillsUncheckedUpdateWithoutSkillInput>
  }

  export type UserSkillsUpdateManyWithWhereWithoutSkillInput = {
    where: UserSkillsScalarWhereInput
    data: XOR<UserSkillsUpdateManyMutationInput, UserSkillsUncheckedUpdateManyWithoutSkillInput>
  }

  export type PortfolioCreateWithoutCommentsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForCreateNestedManyWithoutPortfolioInput
    freelance?: FreelanceCreateNestedOneWithoutPortfolioInput
    company?: CompanyCreateNestedOneWithoutPortfolioInput
    Favorite?: FavoriteCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industryTags?: PortfolioTagUncheckedCreateNestedManyWithoutPortfolioInput
    industryLookingFor?: PortfolioLookingForUncheckedCreateNestedManyWithoutPortfolioInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutPortfolioInput
    Image?: PortfolioImageUncheckedCreateNestedManyWithoutPortfolioInput
    standards?: PortfolioStandardsUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutCommentsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryCreateNestedManyWithoutUserInput
    industryTags?: UserTagsCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsCreateNestedManyWithoutUserInput
    freelance?: FreelanceCreateNestedOneWithoutUserInput
    company?: CompanyCreateNestedOneWithoutUserInput
    Favorite?: FavoriteCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    fullnameTh?: string | null
    fullnameEn?: string | null
    about?: string | null
    phoneNumber?: string | null
    email: string
    website?: string | null
    address?: string | null
    image?: string | null
    industries?: UserCreateindustriesInput | string[]
    tags?: UserCreatetagsInput | InputJsonValue[]
    channels?: UserCreatechannelsInput | InputJsonValue[]
    specialists?: UserCreatespecialistsInput | InputJsonValue[]
    userType?: $Enums.UserType | null
    role?: $Enums.UserType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    industriesRelated?: UserIndustryUncheckedCreateNestedManyWithoutUserInput
    industryTags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    industryChannels?: UserChannelsUncheckedCreateNestedManyWithoutUserInput
    industrySkills?: UserSkillsUncheckedCreateNestedManyWithoutUserInput
    freelance?: FreelanceUncheckedCreateNestedOneWithoutUserInput
    company?: CompanyUncheckedCreateNestedOneWithoutUserInput
    Favorite?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PortfolioCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: PortfolioCommentCreateNestedOneWithoutRepliesInput
  }

  export type PortfolioCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    portfolioId: string
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCommentCreateOrConnectWithoutRepliesInput = {
    where: PortfolioCommentWhereUniqueInput
    create: XOR<PortfolioCommentCreateWithoutRepliesInput, PortfolioCommentUncheckedCreateWithoutRepliesInput>
  }

  export type PortfolioCommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio: PortfolioCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: PortfolioCommentCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    portfolioId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: PortfolioCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type PortfolioCommentCreateOrConnectWithoutParentInput = {
    where: PortfolioCommentWhereUniqueInput
    create: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput>
  }

  export type PortfolioCommentCreateManyParentInputEnvelope = {
    data: PortfolioCommentCreateManyParentInput | PortfolioCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioUpsertWithoutCommentsInput = {
    update: XOR<PortfolioUpdateWithoutCommentsInput, PortfolioUncheckedUpdateWithoutCommentsInput>
    create: XOR<PortfolioCreateWithoutCommentsInput, PortfolioUncheckedCreateWithoutCommentsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutCommentsInput, PortfolioUncheckedUpdateWithoutCommentsInput>
  }

  export type PortfolioUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUpdateOneWithoutUserNestedInput
    company?: CompanyUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullnameTh?: NullableStringFieldUpdateOperationsInput | string | null
    fullnameEn?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    industries?: UserUpdateindustriesInput | string[]
    tags?: UserUpdatetagsInput | InputJsonValue[]
    channels?: UserUpdatechannelsInput | InputJsonValue[]
    specialists?: UserUpdatespecialistsInput | InputJsonValue[]
    userType?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    role?: NullableEnumUserTypeFieldUpdateOperationsInput | $Enums.UserType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industriesRelated?: UserIndustryUncheckedUpdateManyWithoutUserNestedInput
    industryTags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    industryChannels?: UserChannelsUncheckedUpdateManyWithoutUserNestedInput
    industrySkills?: UserSkillsUncheckedUpdateManyWithoutUserNestedInput
    freelance?: FreelanceUncheckedUpdateOneWithoutUserNestedInput
    company?: CompanyUncheckedUpdateOneWithoutUserNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortfolioCommentUpsertWithoutRepliesInput = {
    update: XOR<PortfolioCommentUpdateWithoutRepliesInput, PortfolioCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<PortfolioCommentCreateWithoutRepliesInput, PortfolioCommentUncheckedCreateWithoutRepliesInput>
    where?: PortfolioCommentWhereInput
  }

  export type PortfolioCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: PortfolioCommentWhereInput
    data: XOR<PortfolioCommentUpdateWithoutRepliesInput, PortfolioCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type PortfolioCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: PortfolioCommentUpdateOneWithoutRepliesNestedInput
  }

  export type PortfolioCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: PortfolioCommentWhereUniqueInput
    update: XOR<PortfolioCommentUpdateWithoutParentInput, PortfolioCommentUncheckedUpdateWithoutParentInput>
    create: XOR<PortfolioCommentCreateWithoutParentInput, PortfolioCommentUncheckedCreateWithoutParentInput>
  }

  export type PortfolioCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: PortfolioCommentWhereUniqueInput
    data: XOR<PortfolioCommentUpdateWithoutParentInput, PortfolioCommentUncheckedUpdateWithoutParentInput>
  }

  export type PortfolioCommentUpdateManyWithWhereWithoutParentInput = {
    where: PortfolioCommentScalarWhereInput
    data: XOR<PortfolioCommentUpdateManyMutationInput, PortfolioCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserIndustryCreateManyUserInput = {
    id?: string
    industryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsCreateManyUserInput = {
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsCreateManyUserInput = {
    channelSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsCreateManyUserInput = {
    skillSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    portfolioId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCommentCreateManyUserInput = {
    id?: string
    content: string
    portfolioId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    issuedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type UserIndustryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserIndustryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    industryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    industryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutUserTagsNestedInput
  }

  export type UserTagsUncheckedUpdateWithoutUserInput = {
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyWithoutUserInput = {
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: ChannelUpdateOneRequiredWithoutUserChannelsNestedInput
  }

  export type UserChannelsUncheckedUpdateWithoutUserInput = {
    channelSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsUncheckedUpdateManyWithoutUserInput = {
    channelSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutUserSkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateWithoutUserInput = {
    skillSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsUncheckedUpdateManyWithoutUserInput = {
    skillSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutFavoriteNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutCommentsNestedInput
    parent?: PortfolioCommentUpdateOneWithoutRepliesNestedInput
    replies?: PortfolioCommentUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: PortfolioCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyIndustryCreateManyCompanyInput = {
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyRevenueCreateManyCompanyInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateManyCompanyInput = {
    id?: string
    year: number
    industryTypeSlug: string
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCreateManyCompanyInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    freelanceId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryUpdateWithoutCompanyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyIndustryUncheckedUpdateWithoutCompanyInput = {
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyIndustryUncheckedUpdateManyWithoutCompanyInput = {
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRevenueUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRevenueUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRevenueUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    freelance?: FreelanceUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryCreateManyFreelanceInput = {
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillCreateManyFreelanceInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    industrySlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceRevenueCreateManyFreelanceInput = {
    id?: string
    year: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCreateManyFreelanceInput = {
    id?: string
    title: string
    title_en?: string | null
    description?: string | null
    description_en?: string | null
    cover_image?: string | null
    link?: string | null
    industryTypeSlug: string
    tags?: PortfolioCreatetagsInput | string[]
    looking_for?: PortfolioCreatelooking_forInput | string[]
    companyId?: string | null
    companyJuristicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryUpdateWithoutFreelanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutFreelancersNestedInput
  }

  export type FreelanceIndustryUncheckedUpdateWithoutFreelanceInput = {
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryUncheckedUpdateManyWithoutFreelanceInput = {
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutSkillNestedInput
    UserSkills?: UserSkillsUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSkills?: UserSkillsUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    industrySlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueUncheckedUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceRevenueUncheckedUpdateManyWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUpdateManyWithoutPortfolioNestedInput
    company?: CompanyUpdateOneWithoutPortfolioNestedInput
    Favorite?: FavoriteUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industryTags?: PortfolioTagUncheckedUpdateManyWithoutPortfolioNestedInput
    industryLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutPortfolioNestedInput
    Favorite?: FavoriteUncheckedUpdateManyWithoutPortfolioNestedInput
    Image?: PortfolioImageUncheckedUpdateManyWithoutPortfolioNestedInput
    standards?: PortfolioStandardsUncheckedUpdateManyWithoutPortfolioNestedInput
    comments?: PortfolioCommentUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateManyWithoutFreelanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    cover_image?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    industryTypeSlug?: StringFieldUpdateOperationsInput | string
    tags?: PortfolioUpdatetagsInput | string[]
    looking_for?: PortfolioUpdatelooking_forInput | string[]
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyJuristicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateManyIndustryInput = {
    id?: string
    title: string
    slug: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    freelanceId?: string | null
  }

  export type SourceCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyIndustryCreateManyIndustryInput = {
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceIndustryCreateManyIndustryInput = {
    freelanceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIndustryCreateManyIndustryInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardsCreateManyIndustryInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.StandardsType
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamCreateManyIndustryInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LookingForCreateManyIndustryInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Freelance?: FreelanceUpdateOneWithoutSkillsNestedInput
    UserSkills?: UserSkillsUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
    UserSkills?: UserSkillsUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelanceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUpdateManyWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUpdateManyWithoutChannelNestedInput
    UserChannels?: UserChannelsUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutChannelNestedInput
    UserChannels?: UserChannelsUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RevenueStream?: RevenueStreamUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyIndustryUpdateWithoutIndustryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutIndustriesRelatedNestedInput
  }

  export type CompanyIndustryUncheckedUpdateWithoutIndustryInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyIndustryUncheckedUpdateManyWithoutIndustryInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryUpdateWithoutIndustryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelance?: FreelanceUpdateOneRequiredWithoutIndustriesRelatedNestedInput
  }

  export type FreelanceIndustryUncheckedUpdateWithoutIndustryInput = {
    freelanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceIndustryUncheckedUpdateManyWithoutIndustryInput = {
    freelanceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustriesRelatedNestedInput
  }

  export type UserIndustryUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIndustryUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardsUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioStandards?: PortfolioStandardsUpdateManyWithoutStandardsNestedInput
  }

  export type StandardsUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioStandards?: PortfolioStandardsUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardsUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumStandardsTypeFieldUpdateOperationsInput | $Enums.StandardsType
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioTag?: PortfolioTagUpdateManyWithoutTagNestedInput
    UserTags?: UserTagsUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioTag?: PortfolioTagUncheckedUpdateManyWithoutTagNestedInput
    UserTags?: UserTagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LookingForUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioLookingFor?: PortfolioLookingForUpdateManyWithoutLookingForNestedInput
  }

  export type LookingForUncheckedUpdateWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PortfolioLookingFor?: PortfolioLookingForUncheckedUpdateManyWithoutLookingForNestedInput
  }

  export type LookingForUncheckedUpdateManyWithoutIndustryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagCreateManyTagInput = {
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagsCreateManyTagInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutIndustryTagsNestedInput
  }

  export type PortfolioTagUncheckedUpdateWithoutTagInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagUncheckedUpdateManyWithoutTagInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustryTagsNestedInput
  }

  export type UserTagsUncheckedUpdateWithoutTagInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyWithoutTagInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForCreateManyLookingForInput = {
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForUpdateWithoutLookingForInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutIndustryLookingForNestedInput
  }

  export type PortfolioLookingForUncheckedUpdateWithoutLookingForInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForUncheckedUpdateManyWithoutLookingForInput = {
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateManyCategoryInput = {
    id?: string
    year: number
    sourceSlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateManySourceInput = {
    id?: string
    year: number
    categorySlug: string
    channelSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateManyChannelInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    segmentSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserChannelsCreateManyChannelInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    segment?: SegmentUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    segmentSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsUpdateWithoutChannelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustryChannelsNestedInput
  }

  export type UserChannelsUncheckedUpdateWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChannelsUncheckedUpdateManyWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamCreateManySegmentInput = {
    id?: string
    year: number
    categorySlug: string
    sourceSlug: string
    channelSlug: string
    percent: number
    ctrPercent: number
    value?: number | null
    companyId: string
    companyJuristicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueStreamUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    industry?: IndustryUpdateOneRequiredWithoutRevenueStreamNestedInput
    category?: CategoryUpdateOneRequiredWithoutRevenueStreamNestedInput
    source?: SourceUpdateOneRequiredWithoutRevenueStreamNestedInput
    channel?: ChannelUpdateOneRequiredWithoutRevenueStreamNestedInput
    company?: CompanyUpdateOneRequiredWithoutRevenueStreamNestedInput
  }

  export type RevenueStreamUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueStreamUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    categorySlug?: StringFieldUpdateOperationsInput | string
    sourceSlug?: StringFieldUpdateOperationsInput | string
    channelSlug?: StringFieldUpdateOperationsInput | string
    percent?: FloatFieldUpdateOperationsInput | number
    ctrPercent?: FloatFieldUpdateOperationsInput | number
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    companyId?: StringFieldUpdateOperationsInput | string
    companyJuristicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagCreateManyPortfolioInput = {
    tagSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioLookingForCreateManyPortfolioInput = {
    lookingForSlug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyPortfolioInput = {
    id?: string
    userId: string
    action: $Enums.FavoriteAction
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioImageCreateManyPortfolioInput = {
    id?: string
    url: string
    description?: string | null
    type?: $Enums.PortfolioImageType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsCreateManyPortfolioInput = {
    id?: string
    standardsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCommentCreateManyPortfolioInput = {
    id?: string
    content: string
    userId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioTagUpdateWithoutPortfolioInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutPortfolioTagNestedInput
  }

  export type PortfolioTagUncheckedUpdateWithoutPortfolioInput = {
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioTagUncheckedUpdateManyWithoutPortfolioInput = {
    tagSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForUpdateWithoutPortfolioInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lookingFor?: LookingForUpdateOneRequiredWithoutPortfolioLookingForNestedInput
  }

  export type PortfolioLookingForUncheckedUpdateWithoutPortfolioInput = {
    lookingForSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioLookingForUncheckedUpdateManyWithoutPortfolioInput = {
    lookingForSlug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumFavoriteActionFieldUpdateOperationsInput | $Enums.FavoriteAction
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioImageUncheckedUpdateManyWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPortfolioImageTypeFieldUpdateOperationsInput | $Enums.PortfolioImageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    standards?: StandardsUpdateOneRequiredWithoutPortfolioStandardsNestedInput
  }

  export type PortfolioStandardsUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsUncheckedUpdateManyWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCommentUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: PortfolioCommentUpdateOneWithoutRepliesNestedInput
    replies?: PortfolioCommentUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: PortfolioCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsCreateManyStandardsInput = {
    id?: string
    portfolioId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioStandardsUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutStandardsNestedInput
  }

  export type PortfolioStandardsUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioStandardsUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsCreateManySkillInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSkillsUpdateWithoutSkillInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIndustrySkillsNestedInput
  }

  export type UserSkillsUncheckedUpdateWithoutSkillInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillsUncheckedUpdateManyWithoutSkillInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCommentCreateManyParentInput = {
    id?: string
    content: string
    portfolioId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: PortfolioCommentUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: PortfolioCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PortfolioCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    portfolioId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}